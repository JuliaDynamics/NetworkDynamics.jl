<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · NetworkDynamics</title><meta name="title" content="API · NetworkDynamics"/><meta property="og:title" content="API · NetworkDynamics"/><meta property="twitter:title" content="API · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><a class="tocitem" href="../mathematical_model/">Mathematical Model</a></li><li><a class="tocitem" href="../network_construction/">Network Construction</a></li><li><a class="tocitem" href="../data_structure/">Data Structure</a></li><li><span class="tocitem">Features</span><ul><li><a class="tocitem" href="../symbolic_indexing/">Symbolic Indexing</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../callbacks/">Callbacks and Events</a></li><li><a class="tocitem" href="../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../sparsity_detection/">Sparsity Detection</a></li><li><a class="tocitem" href="../external_inputs/">External Inputs</a></li><li><a class="tocitem" href="../inspector/">Interactive Solution Inspection</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Network-Construction-API"><span>Network Construction API</span></a></li><li><a class="tocitem" href="#Component-Models"><span>Component Models</span></a></li><li><a class="tocitem" href="#Component-Models-with-MTK"><span>Component Models with MTK</span></a></li><li><a class="tocitem" href="#Symbolic-Indexing-API"><span>Symbolic Indexing API</span></a></li><li><a class="tocitem" href="#Metadata-API"><span>Metadata API</span></a></li><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#Linear-Stability-Analysis"><span>Linear Stability Analysis</span></a></li><li><a class="tocitem" href="#Callbacks-API"><span>Callbacks API</span></a></li><li><a class="tocitem" href="#Sparsity-Detection"><span>Sparsity Detection</span></a></li><li><a class="tocitem" href="#Execution-Types"><span>Execution Types</span></a></li><li><a class="tocitem" href="#Aggregators"><span>Aggregators</span></a></li><li><a class="tocitem" href="#Utils"><span>Utils</span></a></li><li><a class="tocitem" href="#NetworkDynamicsInspector-API"><span>NetworkDynamicsInspector API</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../generated/heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../generated/init_tutorial/">Initialization</a></li><li><a class="tocitem" href="../generated/cascading_failure/">Cascading Failure</a></li><li><a class="tocitem" href="../generated/gas_network/">Gas Network</a></li><li><a class="tocitem" href="../generated/stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../generated/directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/src/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The following functions are designed for public use.</p><h2 id="Network-Construction-API"><a class="docs-heading-anchor" href="#Network-Construction-API">Network Construction API</a><a id="Network-Construction-API-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Construction-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.Network"><a class="docstring-binding" href="#NetworkDynamics.Network"><code>NetworkDynamics.Network</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Network([g,] vertexf, edgef; kwarg...)</code></pre><p>Construct a <code>Network</code> object from a graph <code>g</code> and edge and component models <code>vertexf</code> and <code>edgef</code>.</p><p>Arguments:</p><ul><li><p><code>g::AbstractGraph</code>: The graph on which the network is defined.  Optional, can be ommittet if all component models have a defined <code>graphelement</code>.  See <code>vidx</code> and <code>src</code>/<code>dst</code> keywors for <a href="#NetworkDynamics.VertexModel-Tuple{}"><code>VertexModel</code></a> and <a href="#NetworkDynamics.EdgeModel-Tuple{}"><code>EdgeModel</code></a> constructors respectively.</p></li><li><p><code>vertexm</code>:  A single <a href="#NetworkDynamics.VertexModel-Tuple{}"><code>VertexModel</code></a> or a vector of <a href="#NetworkDynamics.VertexModel-Tuple{}"><code>VertexModel</code></a> objects.  The order of the vertex models must mirror the order of the <code>vertices(g)</code> iterator.</p></li><li><p><code>edgem</code>: A single <a href="#NetworkDynamics.EdgeModel-Tuple{}"><code>EdgeModel</code></a> or a vector of <a href="#NetworkDynamics.EdgeModel-Tuple{}"><code>EdgeModel</code></a> objects.  The order of the edge models must mirror the order of the <code>edges(g)</code> iterator.</p></li></ul><p>Optional keyword arguments:</p><ul><li><code>execution=SequentialExecution{true}()</code>:  Execution model of the network. E.g. <a href="#NetworkDynamics.SequentialExecution"><code>SequentialExecution</code></a>, <a href="#NetworkDynamics.KAExecution"><code>KAExecution</code></a>, <a href="#NetworkDynamics.PolyesterExecution"><code>PolyesterExecution</code></a> or <a href="#NetworkDynamics.ThreadedExecution"><code>ThreadedExecution</code></a>.</li><li><code>aggregator=execution isa SequentialExecution ? SequentialAggregator(+) : PolyesterAggregator(+)</code>:  Aggregation function applied to the edge models. E.g. <a href="#NetworkDynamics.SequentialAggregator"><code>SequentialAggregator</code></a>, <a href="#NetworkDynamics.PolyesterAggregator"><code>PolyesterAggregator</code></a>, <a href="#NetworkDynamics.ThreadedAggregator"><code>ThreadedAggregator</code></a>, <a href="#NetworkDynamics.SparseAggregator"><code>SparseAggregator</code></a>.</li><li><code>check_graphelement=true</code>:  Check if the <code>graphelement</code> metadata is consistent with the graph.</li><li><code>dealias=false</code>  Check if the components alias eachother and create copies if necessary.  This is necessary if the same component model is referenced in multiple places in the Network but you want to  dynamicially asign metadata, such as initialization information to specific instances.</li><li><code>verbose=false</code>:  Show additional information during construction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/construction.jl#L1-L30">source</a></section><section><div><pre><code class="language-julia hljs">Network(nw::Network; g, vertexm, edgem, kwargs...)</code></pre><p>Rebuild the Network with same graph and vertex/edge models but possibly different kwargs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/construction.jl#L435-L439">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_graph"><a class="docstring-binding" href="#NetworkDynamics.get_graph"><code>NetworkDynamics.get_graph</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_graph(nw::Network)</code></pre><p>Extracts the underlying graph of the network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/network_structure.jl#L111-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.dim-Tuple{Network}"><a class="docstring-binding" href="#NetworkDynamics.dim-Tuple{Network}"><code>NetworkDynamics.dim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dim(nw::Network)</code></pre><p>Returns the number of dynamic states in the network, corresponts to the length of the flat state vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/network_structure.jl#L92-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.pdim-Tuple{Network}"><a class="docstring-binding" href="#NetworkDynamics.pdim-Tuple{Network}"><code>NetworkDynamics.pdim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pdim(nw::Network)</code></pre><p>Returns the number of parameters in the network, corresponts to the length of the flat parameter vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/network_structure.jl#L100-L105">source</a></section></details></article><h2 id="Component-Models"><a class="docs-heading-anchor" href="#Component-Models">Component Models</a><a id="Component-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Models" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.VertexModel-Tuple{}"><a class="docstring-binding" href="#NetworkDynamics.VertexModel-Tuple{}"><code>NetworkDynamics.VertexModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VertexModel(; kwargs...)</code></pre><p>Build a <code>VertexModel</code> according to the keyword arguments.</p><p>Main Arguments:</p><ul><li><code>f=nothing</code>: Dynamic function of the component. Can be nothing if <code>dim</code> is 0.</li><li><code>g</code>: Output function of the component. Usefull helpers: <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a></li><li><code>sym</code>/<code>dim</code>: Symbolic names of the states. If <code>dim</code> is provided, <code>sym</code> is set automaticially.</li><li><code>outsym</code>/<code>outdim</code>:  Symbolic names of the outputs. If <code>outdim</code> is provided, <code>outsym</code> is set automaticially.  Can be infered automaticially if <code>g</code> isa <code>StateMask</code>.</li><li><code>psym</code>/<code>pdim=0</code>: Symbolic names of the parameters. If <code>pdim</code> is provided, <code>psym</code> is set automaticially.</li><li><code>mass_matrix=I</code>: Mass matrix of component. Can be a vector <code>v</code> and is then interpreted as <code>Diagonal(v)</code>.</li><li><code>name=dim&gt;0 ? :VertexM : :StaticVertexM</code>: Name of the component.</li></ul><p>Optional Arguments:</p><ul><li><code>insym</code>/<code>indim</code>: Symbolic names of the inputs. If <code>indim</code> is provided, <code>insym</code> is set automaticially.</li><li><code>vidx</code>: Index of the vertex in the graph, enables graphless constructor.</li><li><code>ff</code>: <code>FeedForwardType</code> of component. Will be typically infered from <code>g</code> automaticially.</li><li><code>obssym</code>/<code>obsf</code>: Define additional &quot;observable&quot; states.</li><li><code>symmetadata</code>/<code>metadata</code>: Provide prefilled metadata dictionaries.</li><li><code>extin=nothing</code>:  Define &quot;external&quot; inputs for the model with Network indices, i.e. <code>extin=[VIndex(7,:x), ..]</code>.  Those inputs will be provided as another input vector <code>f(x, in, extin, p, t)</code> and <code>g(y, x, in, extin, p, t)</code>.</li></ul><p>All Symbol arguments can be used to set default values, i.e. <code>psym=[:K=&gt;1, :p]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L274-L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.EdgeModel-Tuple{}"><a class="docstring-binding" href="#NetworkDynamics.EdgeModel-Tuple{}"><code>NetworkDynamics.EdgeModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EdgeModel(; kwargs...)</code></pre><p>Build a <code>EdgeModel</code> according to the keyword arguments.</p><p>Main Arguments:</p><ul><li><code>f=nothing</code>: Dynamic function of the component. Can be nothing if <code>dim</code> is 0.</li><li><code>g</code>: Output function of the component. Usefull helpers: <a href="#NetworkDynamics.AntiSymmetric"><code>AntiSymmetric</code></a>, <a href="#NetworkDynamics.Symmetric"><code>Symmetric</code></a>, <a href="#NetworkDynamics.Fiducial"><code>Fiducial</code></a>, <a href="#NetworkDynamics.Directed"><code>Directed</code></a> and <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</li><li><code>sym</code>/<code>dim</code>: Symbolic names of the states. If <code>dim</code> is provided, <code>sym</code> is set automaticially.</li><li><code>outsym</code>/<code>outdim</code>:  Symbolic names of the outputs. If <code>outdim</code> is provided, <code>outsym</code> is set automaticially.  In general, outsym for edges isa named tuple <code>(; src, dst)</code>. However, depending on the <code>g</code> function,  it might be enough to provide a single vector or even nothing (e.g. <code>AntiSymmetric(StateMask(1:2))</code>).  See <a href="../network_construction/#Building-EdgeModels">Building <code>EdgeModel</code>s</a> for examples.</li><li><code>psym</code>/<code>pdim=0</code>: Symbolic names of the parameters. If <code>pdim</code> is provided, <code>psym</code> is set automaticially.</li><li><code>mass_matrix=I</code>: Mass matrix of component. Can be a vector <code>v</code> and is then interpreted as <code>Diagonal(v)</code>.</li><li><code>name=dim&gt;0 ? :EdgeM : :StaticEdgeM</code>: Name of the component.</li></ul><p>Optional Arguments:</p><ul><li><code>insym</code>/<code>indim</code>: Symbolic names of the inputs. If <code>indim</code> is provided, <code>insym</code> is set automaticially.  For edges, <code>insym</code> is a named tuple <code>(; src, dst)</code>. If give as vector tuple is created automaticially.</li><li><code>src</code>/<code>dst</code>: Index or name of the vertices at src and dst end. Enables graphless constructor.</li><li><code>ff</code>: <code>FeedForwardType</code> of component. Will be typically infered from <code>g</code> automaticially.</li><li><code>obssym</code>/<code>obsf</code>: Define additional &quot;observable&quot; states.</li><li><code>symmetadata</code>/<code>metadata</code>: Provide prefilled metadata dictionaries.</li><li><code>extin=nothing</code>:  Define &quot;external&quot; inputs for the model with Network indices, i.e. <code>extin=[VIndex(7,:x), ..]</code>.  Those inputs will be provided as another input vector <code>f(x, insrc, indst, extin, p, t)</code> and <code>g(ysrc, ydst, x, insrc, indst, extin, p, t)</code>.</li></ul><p>All Symbol arguments can be used to set default values, i.e. <code>psym=[:K=&gt;1, :p]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L329-L359">source</a></section></details></article><h2 id="Component-Models-with-MTK"><a class="docs-heading-anchor" href="#Component-Models-with-MTK">Component Models with MTK</a><a id="Component-Models-with-MTK-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Models-with-MTK" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.VertexModel-Tuple{System, Any, Any}"><a class="docstring-binding" href="#NetworkDynamics.VertexModel-Tuple{System, Any, Any}"><code>NetworkDynamics.VertexModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">VertexModel(sys::System, inputs, outputs;
            verbose=false, name=getname(sys), extin=nothing, ff_to_constraint=true, kwargs...)</code></pre><p>Create a <code>VertexModel</code> object from a given <code>System</code> created with ModelingToolkit. You need to provide 2 lists of symbolic names (<code>Symbol</code> or <code>Vector{Symbols}</code>):</p><ul><li><code>inputs</code>: names of variables in you equation representing the aggregated edge states</li><li><code>outputs</code>: names of variables in you equation representing the node output</li></ul><p>Additional kw arguments:</p><ul><li><code>name</code>: Set name of the component model. Will be lifted from the System name.</li><li><code>extin=nothing</code>: Provide external inputs as pairs, i.e. <code>extin=[:extvar =&gt; VIndex(1, :a)]</code>  will bound the variable <code>extvar(t)</code> in the equations to the state <code>a</code> of the first vertex.</li><li><code>ff_to_constraint=true</code>: Controls, whether output transformations <code>g</code> which depend on inputs should be transformed into constraints. Defaults to true since ND.jl does not handle vertices with FF yet.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/ext/NetworkDynamicsMTKExt.jl#L26-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.EdgeModel-Tuple{System, Vararg{Any, 4}}"><a class="docstring-binding" href="#NetworkDynamics.EdgeModel-Tuple{System, Vararg{Any, 4}}"><code>NetworkDynamics.EdgeModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EdgeModel(sys::System, srcin, dstin, srcout, dstout;
          verbose=false, name=getname(sys), extin=nothing, ff_to_constraint=false, kwargs...)</code></pre><p>Create a <code>EdgeModel</code> object from a given <code>System</code> created with ModelingToolkit. You need to provide 4 lists of symbolic names (<code>Symbol</code> or <code>Vector{Symbols}</code>):</p><ul><li><code>srcin</code>: names of variables in you equation representing the node state at the source</li><li><code>dstin</code>: names of variables in you equation representing the node state at the destination</li><li><code>srcout</code>: names of variables in you equation representing the output at the source</li><li><code>dstout</code>: names of variables in you equation representing the output at the destination</li></ul><p>Additional kw arguments:</p><ul><li><code>name</code>: Set name of the component model. Will be lifted from the System name.</li><li><code>extin=nothing</code>: Provide external inputs as pairs, i.e. <code>extin=[:extvar =&gt; VIndex(1, :a)]</code>  will bound the variable <code>extvar(t)</code> in the equations to the state <code>a</code> of the first vertex.</li><li><code>ff_to_constraint=false</code>: Controls, whether output transformations <code>g</code> which depend on inputs should be transformed into constraints.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/ext/NetworkDynamicsMTKExt.jl#L114-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.EdgeModel-Tuple{System, Any, Any, Any}"><a class="docstring-binding" href="#NetworkDynamics.EdgeModel-Tuple{System, Any, Any, Any}"><code>NetworkDynamics.EdgeModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EdgeModel(sys::System, srcin, dstin, AntiSymmetric(dstout); kwargs...)</code></pre><p>Create a <code>EdgeModel</code> object from a given <code>System</code> created with ModelingToolkit for <strong>single sided models</strong>.</p><p>Here you only need to provide one list of output symbols: <code>dstout</code>. To make it clear how to handle the single-sided output definition, you must wrap the symbol vector in</p><ul><li><code>AntiSymmetric(dstout)</code>,</li><li><code>Symmetric(dstout)</code>, or</li><li><code>Directed(dstout)</code>.</li></ul><p>Additional <code>kwargs</code> are the same as for the double-sided EdgeModel MTK constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/ext/NetworkDynamicsMTKExt.jl#L98-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ComponentPostprocessing"><a class="docstring-binding" href="#NetworkDynamics.ComponentPostprocessing"><code>NetworkDynamics.ComponentPostprocessing</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ComponentPostprocessing</code></pre><p>Custom MTK metadata type, you can add it to register a postprocessing function <code>f</code> for your model</p><pre><code class="language-julia hljs">function my_postproc(cm::Union{VertexModel, EdgeModel}, namespace)
    # alter the cm as needed, for example add callbacks
end
@mtkmodel MyModel begin
    ...
    @metadata begin
        ComponentPostprocessing = my_postproc
    end
    ...
end</code></pre><p>The postprocessing function will be called at the end of the <code>VertexModel</code>/<code>EdgeModel</code> construction after the model compilation. You can use it to add custom callbacks or init functions/metadata to the generated component. The function gets both the component model to <em>modify</em> and the namespace (as string) of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/utils.jl#L377-L397">source</a></section></details></article><h3 id="Output-Function-Helpers/Wrappers"><a class="docs-heading-anchor" href="#Output-Function-Helpers/Wrappers">Output Function Helpers/Wrappers</a><a id="Output-Function-Helpers/Wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Output-Function-Helpers/Wrappers" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.StateMask"><a class="docstring-binding" href="#NetworkDynamics.StateMask"><code>NetworkDynamics.StateMask</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateMask(i::AbstractArray)
StateMaks(i::Number)</code></pre><p>A <code>StateMask</code> is a predefined output function. It can be used to define the output of a component model by picking from the internal state.</p><p>I.e. <code>g=StateMask(2:3)</code> in a vertex function will output the internal states 2 and 3. In many contexts, <code>StateMask</code>s can be constructed implicitly by just providing the indices, e.g. <code>g=1:2</code>.</p><p>For <a href="#NetworkDynamics.EdgeModel-Tuple{}"><code>EdgeModel</code></a> this needs to be combined with a <a href="#NetworkDynamics.Directed"><code>Directed</code></a>, <a href="#NetworkDynamics.Symmetric"><code>Symmetric</code></a>, <a href="#NetworkDynamics.AntiSymmetric"><code>AntiSymmetric</code></a> or <a href="#NetworkDynamics.Fiducial"><code>Fiducial</code></a> coupling, e.g. <code>g=Fiducial(1:2, 3:4)</code> forwards states 1:2 to dst and states 3:4 to src.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L66-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.Symmetric"><a class="docstring-binding" href="#NetworkDynamics.Symmetric"><code>NetworkDynamics.Symmetric</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Symmetric(g)</code></pre><p>Wraps a single-sided output function <code>g</code> turns it into a double sided output function which applies</p><pre><code class="language-julia hljs">y_dst = g(...)
y_src = y_dst</code></pre><p><code>g</code> can be a <code>Number</code>/<code>AbstractArray</code> to impicitly wrap the corresponding <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p><p>See also <a href="#NetworkDynamics.AntiSymmetric"><code>AntiSymmetric</code></a>, <a href="#NetworkDynamics.Directed"><code>Directed</code></a>, <a href="#NetworkDynamics.Fiducial"><code>Fiducial</code></a> and <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L129-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.AntiSymmetric"><a class="docstring-binding" href="#NetworkDynamics.AntiSymmetric"><code>NetworkDynamics.AntiSymmetric</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AntiSymmetric(g_dst)</code></pre><p>Wraps a single-sided output function <code>g_dst</code> turns it into a double sided output function which applies</p><pre><code class="language-julia hljs">y_dst = g_dst(...)
y_src = -y_dst</code></pre><p><code>g_dst</code> can be a <code>Number</code>/<code>AbstractArray</code> to impicitly wrap the corresponding <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p><p>See also <a href="#NetworkDynamics.Symmetric"><code>Symmetric</code></a>, <a href="#NetworkDynamics.Directed"><code>Directed</code></a>, <a href="#NetworkDynamics.Fiducial"><code>Fiducial</code></a> and <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L104-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.Directed"><a class="docstring-binding" href="#NetworkDynamics.Directed"><code>NetworkDynamics.Directed</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Directed(g_dst)</code></pre><p>Wraps a single-sided output function <code>g_dst</code> turns it into a double sided output function which applies</p><pre><code class="language-julia hljs">y_dst = g_dst(...)</code></pre><p>With <code>Directed</code> there is no output for the <code>src</code> side. <code>g_dst</code> can be a <code>Number</code>/<code>AbstractArray</code> to impicitly wrap the corresponding <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p><p>See also <a href="#NetworkDynamics.AntiSymmetric"><code>AntiSymmetric</code></a>, <a href="#NetworkDynamics.Symmetric"><code>Symmetric</code></a>, <a href="#NetworkDynamics.Fiducial"><code>Fiducial</code></a> and <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L154-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.Fiducial"><a class="docstring-binding" href="#NetworkDynamics.Fiducial"><code>NetworkDynamics.Fiducial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Fiducial(g_src, g_dst)</code></pre><p>Wraps two single-sided output function <code>g_src</code> and <code>g_dst</code> and turns them into a double sided output function which applies</p><pre><code class="language-julia hljs">y_dst = g_src(...)
y_src = g_dst(...)</code></pre><p><code>g</code> can be a <code>Number</code>/<code>AbstractArray</code> to impicitly wrap the corresponding <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p><p>See also <a href="#NetworkDynamics.AntiSymmetric"><code>AntiSymmetric</code></a>, <a href="#NetworkDynamics.Directed"><code>Directed</code></a>, <a href="#NetworkDynamics.Fiducial"><code>Fiducial</code></a> and <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L176-L188">source</a></section></details></article><h3 id="Accessors-for-Component-Properties"><a class="docs-heading-anchor" href="#Accessors-for-Component-Properties">Accessors for Component Properties</a><a id="Accessors-for-Component-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Accessors-for-Component-Properties" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.fftype"><a class="docstring-binding" href="#NetworkDynamics.fftype"><code>NetworkDynamics.fftype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fftype(x)</code></pre><p>Retrieve the feed forward trait of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L51-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.dim-Tuple{NetworkDynamics.ComponentModel}"><a class="docstring-binding" href="#NetworkDynamics.dim-Tuple{NetworkDynamics.ComponentModel}"><code>NetworkDynamics.dim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dim(c::ComponentModel)::Int</code></pre><p>Retrieve the dimension of the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L384-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.sym"><a class="docstring-binding" href="#NetworkDynamics.sym"><code>NetworkDynamics.sym</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sym(c::ComponentModel)::Vector{Symbol}</code></pre><p>Retrieve the symbols of the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L391-L395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.outdim"><a class="docstring-binding" href="#NetworkDynamics.outdim"><code>NetworkDynamics.outdim</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">outdim(c::VertexModel)::Int
outdim(c::EdgeModel)::@NamedTuple(src::Int, dst::Int)</code></pre><p>Retrieve the output dimension of the component</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L399-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.outsym"><a class="docstring-binding" href="#NetworkDynamics.outsym"><code>NetworkDynamics.outsym</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>outsym(c::VertexModel)::Vector{Symbol}    outsym(c::EdgeModel)::@NamedTuple{src::Vector{Symbol}, dst::Vector{Symbol}}</p><p>Retrieve the output symbols of the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L411-L416">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.pdim-Tuple{NetworkDynamics.ComponentModel}"><a class="docstring-binding" href="#NetworkDynamics.pdim-Tuple{NetworkDynamics.ComponentModel}"><code>NetworkDynamics.pdim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pdim(c::ComponentModel)::Int</code></pre><p>Retrieve the parameter dimension of the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L419-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.psym"><a class="docstring-binding" href="#NetworkDynamics.psym"><code>NetworkDynamics.psym</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">psym(c::ComponentModel)::Vector{Symbol}</code></pre><p>Retrieve the parameter symbols of the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L426-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.obssym"><a class="docstring-binding" href="#NetworkDynamics.obssym"><code>NetworkDynamics.obssym</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">obssym(c::ComponentModel)::Vector{Symbol}</code></pre><p>Retrieve the observation symbols of the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L440-L444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.hasinsym"><a class="docstring-binding" href="#NetworkDynamics.hasinsym"><code>NetworkDynamics.hasinsym</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hasinsym(c::ComponentModel)</code></pre><p>Checks if the optioan field <code>insym</code> is present in the component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L466-L470">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.insym"><a class="docstring-binding" href="#NetworkDynamics.insym"><code>NetworkDynamics.insym</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">insym(c::VertexModel)::Vector{Symbol}
insym(c::EdgeModel)::@NamedTuple{src::Vector{Symbol}, dst::Vector{Symbol}}</code></pre><p>Musst be called <em>after</em> <a href="#NetworkDynamics.hasinsym"><code>hasinsym</code></a>/<a href="#NetworkDynamics.hasindim"><code>hasindim</code></a> returned true. Gives the <code>insym</code> vector(s). For vertex model just a single vector, for edges it returns a named tuple <code>(; src, dst)</code> with two symbol vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L479-L486">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.hasindim"><a class="docstring-binding" href="#NetworkDynamics.hasindim"><code>NetworkDynamics.hasindim</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hasindim(c::ComponentModel)</code></pre><p>Checks if the optioan field <code>insym</code> is present in the component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L472-L476">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.indim"><a class="docstring-binding" href="#NetworkDynamics.indim"><code>NetworkDynamics.indim</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">indim(c::VertexModel)::Int
indim(c::EdgeModel)::@NamedTuple{src::Int,dst::Int}</code></pre><p>Musst be called <em>after</em> <a href="#NetworkDynamics.hasinsym"><code>hasinsym</code></a>/<a href="#NetworkDynamics.hasindim"><code>hasindim</code></a> returned true. Gives the input dimension(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L495-L501">source</a></section></details></article><h3 id="FeedForwardType-Traits"><a class="docs-heading-anchor" href="#FeedForwardType-Traits"><code>FeedForwardType</code>-Traits</a><a id="FeedForwardType-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#FeedForwardType-Traits" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.FeedForwardType"><a class="docstring-binding" href="#NetworkDynamics.FeedForwardType"><code>NetworkDynamics.FeedForwardType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type FeedForwardType end</code></pre><p>Abstract supertype for the FeedForwardType traits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.PureFeedForward"><a class="docstring-binding" href="#NetworkDynamics.PureFeedForward"><code>NetworkDynamics.PureFeedForward</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PureFeedForward &lt;: FeedForwardType</code></pre><p>Trait for component output functions <code>g</code> that have pure feed forward behavior (do not depend on x):</p><pre><code class="language-julia hljs">g!(outs..., ins..., p, t)</code></pre><p>See also <a href="#NetworkDynamics.FeedForward"><code>FeedForward</code></a>, <a href="#NetworkDynamics.NoFeedForward"><code>NoFeedForward</code></a> and <a href="#NetworkDynamics.PureStateMap"><code>PureStateMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L7-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.FeedForward"><a class="docstring-binding" href="#NetworkDynamics.FeedForward"><code>NetworkDynamics.FeedForward</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FeedForward &lt;: FeedForwardType</code></pre><p>Trait for component output functions <code>g</code> that have feed forward behavior. May depend on everything:</p><pre><code class="language-julia hljs">g!(outs..., x, ins..., p, t)</code></pre><p>See also <a href="#NetworkDynamics.PureFeedForward"><code>PureFeedForward</code></a>, <a href="#NetworkDynamics.NoFeedForward"><code>NoFeedForward</code></a> and <a href="#NetworkDynamics.PureStateMap"><code>PureStateMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L18-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NoFeedForward"><a class="docstring-binding" href="#NetworkDynamics.NoFeedForward"><code>NetworkDynamics.NoFeedForward</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoFeedForward &lt;: FeedForwardType</code></pre><p>Trait for component output functions <code>g</code> that have no feed forward behavior (do not depend on inputs):</p><pre><code class="language-julia hljs">g!(outs..., x, p, t)</code></pre><p>See also <a href="#NetworkDynamics.PureFeedForward"><code>PureFeedForward</code></a>, <a href="#NetworkDynamics.FeedForward"><code>FeedForward</code></a> and <a href="#NetworkDynamics.PureStateMap"><code>PureStateMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L29-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.PureStateMap"><a class="docstring-binding" href="#NetworkDynamics.PureStateMap"><code>NetworkDynamics.PureStateMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PureStateMap &lt;: FeedForwardType</code></pre><p>Trait for component output functions <code>g</code> that only depends on state:</p><pre><code class="language-julia hljs">g!(outs..., x)</code></pre><p>See also <a href="#NetworkDynamics.PureFeedForward"><code>PureFeedForward</code></a>, <a href="#NetworkDynamics.FeedForward"><code>FeedForward</code></a> and <a href="#NetworkDynamics.NoFeedForward"><code>NoFeedForward</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L40-L48">source</a></section></details></article><h2 id="Symbolic-Indexing-API"><a class="docs-heading-anchor" href="#Symbolic-Indexing-API">Symbolic Indexing API</a><a id="Symbolic-Indexing-API-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Indexing-API" title="Permalink"></a></h2><h3 id="Network-Parameter-Object"><a class="docs-heading-anchor" href="#Network-Parameter-Object">Network Parameter Object</a><a id="Network-Parameter-Object-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Parameter-Object" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWParameter"><a class="docstring-binding" href="#NetworkDynamics.NWParameter"><code>NetworkDynamics.NWParameter</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NWParameter(nw_or_nw_wrapper, pflat)</code></pre><p>Indexable wrapper for flat parameter array <code>pflat</code>. Needs Network or wrapper of Network, e.g. <code>ODEProblem</code>.</p><pre><code class="language-julia hljs">p = NWParameter(nw)
p.v[idx, :sym]               # get parameter :sym of vertex idx
p.e[idx, :sym]               # get parameter :sym of edge idx
p[VIndex(idx, :sym)]         # get parameter using VIndex
p[VIndex(idx, ParamIdx(1))]  # get first parameter by numeric index</code></pre><p>Using the special <code>.v</code> and <code>.e</code> properties, you get a <a href="#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> object which allows for interactive filtering, inspection and changing of parameters. See <a href="#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> for details.</p><p>Get flat array representation using <a href="#NetworkDynamics.pflat"><code>pflat</code></a>. The order of parameters in the flat representation corresponds to the order given by <a href="#SymbolicIndexingInterface.parameter_symbols"><code>parameter_symbols</code></a>.</p><p>See also: <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="#NetworkDynamics.EIndex"><code>EIndex</code></a>, <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a>, <a href="#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L5-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWParameter-Tuple{Any}"><a class="docstring-binding" href="#NetworkDynamics.NWParameter-Tuple{Any}"><code>NetworkDynamics.NWParameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NWParameter(nw_or_nw_wrapper;
            ptype=Vector{Float64}, pfill=filltype(ptype), default=true)</code></pre><p>Creates &quot;empty&quot; <code>NWParameter</code> object for the Network/Wrapper <code>nw</code> with flat type <code>ptype</code>. The array will be prefilled with <code>pfill</code> (defaults to NaN).</p><p>If <code>default=true</code> the default parameter values attached to the network components will be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L39-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWParameter-Tuple{NWParameter}"><a class="docstring-binding" href="#NetworkDynamics.NWParameter-Tuple{NWParameter}"><code>NetworkDynamics.NWParameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NWParameter(p::NWParameter; ptype=typeof(p.pflat))</code></pre><p>Create <code>NWParameter</code> based on other parameter object, just convert type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L62-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWParameter-Tuple{SciMLBase.DEIntegrator}"><a class="docstring-binding" href="#NetworkDynamics.NWParameter-Tuple{SciMLBase.DEIntegrator}"><code>NetworkDynamics.NWParameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NWParameter(int::SciMLBase.DEIntegrator)</code></pre><p>Create <code>NWParameter</code> object from <code>integrator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L71-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.pflat"><a class="docstring-binding" href="#NetworkDynamics.pflat"><code>NetworkDynamics.pflat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pflat(p::NWParameter)
pflat(s::NWState)</code></pre><p>Retrieve the wrapped flat array representation of the parameters. The order of parameters in this flat representation corresponds exactly to the order given by <a href="#SymbolicIndexingInterface.parameter_symbols"><code>parameter_symbols</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L250-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicIndexingInterface.parameter_symbols"><a class="docstring-binding" href="#SymbolicIndexingInterface.parameter_symbols"><code>SymbolicIndexingInterface.parameter_symbols</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SymbolicIndexingInterface.parameter_symbols(nw::Network)</code></pre><p>Returns a vector of all symbolic network indices which in the same order as the flat parameter vector.</p><p>See also: <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a>, <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.pflat"><code>pflat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L468-L475">source</a></section></details></article><h3 id="Network-State-Object"><a class="docs-heading-anchor" href="#Network-State-Object">Network State Object</a><a id="Network-State-Object-1"></a><a class="docs-heading-anchor-permalink" href="#Network-State-Object" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWState"><a class="docstring-binding" href="#NetworkDynamics.NWState"><code>NetworkDynamics.NWState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NWState(nw_or_nw_wrapper, uflat, [pflat], [t])</code></pre><p>Indexable wrapper for flat state &amp; parameter array. Needs Network or wrapper of Network, e.g. <code>ODEProblem</code>.</p><pre><code class="language-julia hljs">s = NWState(nw)
s.v[idx, :sym]                   # get state :sym of vertex idx
s.e[idx, :sym]                   # get state :sym of edge idx
s.p.v[idx, :sym]                 # get parameter :sym of vertex idx
s.p.e[idx, :sym]                 # get parameter :sym of edge idx
s[VIndex(idx, :sym)]             # get state using VIndex
s[VIndex(idx, StateIdx(1))]      # get first state by numeric index
s[VIndex(idx, ParamIdx(1))]      # get first parameter by numeric index</code></pre><p>Using the special <code>.v</code> and <code>.e</code> properties, you get a <a href="#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> object which allows for interactive filtering, inspection and changing of states. See <a href="#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> for details.</p><p>Get flat array representation using <a href="#NetworkDynamics.uflat"><code>uflat</code></a> and <a href="#NetworkDynamics.pflat"><code>pflat</code></a>. The order of states in the flat representation corresponds to the order given by <a href="#SymbolicIndexingInterface.variable_symbols"><code>variable_symbols</code></a>, and the order of parameters corresponds to <a href="#SymbolicIndexingInterface.parameter_symbols"><code>parameter_symbols</code></a>.</p><p>See also: <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a>, <a href="#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="#NetworkDynamics.EIndex"><code>EIndex</code></a>, <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a>, <a href="#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L79-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWState-Tuple{Any}"><a class="docstring-binding" href="#NetworkDynamics.NWState-Tuple{Any}"><code>NetworkDynamics.NWState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NWState(nw_or_nw_wrapper;
        utype=Vector{Float64}, ufill=filltype(utype),
        ptype=Vector{Float64}, pfill=filltype(ptype), default=true)</code></pre><p>Creates &quot;empty&quot; <code>NWState</code> object for the Network/Wrapper <code>nw</code> with flat types <code>utype</code> &amp; <code>ptype</code>. The arrays will be prefilled with <code>ufill</code> and <code>pfill</code> respectively (defaults to NaN).</p><p>If <code>default=true</code> the default state &amp; parameter values attached to the network components will be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L120-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWState-Tuple{NWState}"><a class="docstring-binding" href="#NetworkDynamics.NWState-Tuple{NWState}"><code>NetworkDynamics.NWState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NWState(s::NWState; utype=typeof(uflat(s)), ptype=typeof(pflat(s)))</code></pre><p>Create <code>NWState</code> based on other state object, just convert types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L148-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWState-Tuple{NWParameter}"><a class="docstring-binding" href="#NetworkDynamics.NWState-Tuple{NWParameter}"><code>NetworkDynamics.NWState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NWState(p::NWParameter; utype=Vector{Float64}, ufill=filltype(utype), default=true)</code></pre><p>Create <code>NWState</code> based on existing <code>NWParameter</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L160-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.NWState-Tuple{SciMLBase.DEIntegrator}"><a class="docstring-binding" href="#NetworkDynamics.NWState-Tuple{SciMLBase.DEIntegrator}"><code>NetworkDynamics.NWState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NWState(int::SciMLBase.DEIntegrator)</code></pre><p>Create <code>NWState</code> object from <code>integrator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L180-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.uflat"><a class="docstring-binding" href="#NetworkDynamics.uflat"><code>NetworkDynamics.uflat</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">uflat(s::NWState)</code></pre><p>Retrieve the wrapped flat array representation of the state. The order of states in this flat representation corresponds exactly to the order given by <a href="#SymbolicIndexingInterface.variable_symbols"><code>variable_symbols</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L243-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicIndexingInterface.variable_symbols"><a class="docstring-binding" href="#SymbolicIndexingInterface.variable_symbols"><code>SymbolicIndexingInterface.variable_symbols</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">SymbolicIndexingInterface.variable_symbols(nw::Network)</code></pre><p>Returns a vector of all symbolic network indices which in the same order as the flat state vector.</p><p>See also: <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.uflat"><code>uflat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L412-L419">source</a></section></details></article><h3 id="Symbolic-Indices"><a class="docs-heading-anchor" href="#Symbolic-Indices">Symbolic Indices</a><a id="Symbolic-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Indices" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.VIndex"><a class="docstring-binding" href="#NetworkDynamics.VIndex"><code>NetworkDynamics.VIndex</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VIndex{C,S} &lt;: SymbolicIndex{C,S}
idx = VIndex(comp, sub)</code></pre><p>A symbolic index for a vertex variable.</p><ul><li><code>comp</code>: the component index, either int, symbol or a collection</li><li><code>sub</code>: the subindex, either int, symbol or a collection of those.</li></ul><p>Symbolic indices are rather flexible and can potentially point to states, parameters, inputs, outputs, or observables.</p><p>The most basic form is <code>VIndex(1, :P)</code> which points to the variable with the name <code>:P</code> in the first vertex model. The component can be also given by unique name, so <code>VIndex(:a, :P)</code> would point to the vertex with unique name <code>:a</code>.</p><p>It is also possible to have &quot;collections&quot; of indices, such as</p><pre><code class="language-julia hljs">VIndex(1:5, 1)     # first state of vertices 1 to 5
VIndex(7, (:x,:y)) # states :x and :y of vertex 7</code></pre><p>They can be used to index into objects supporting the <code>SymbolicIndexingInterface</code>, e.g. <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a> or <code>ODESolution</code>.</p><p>It is also possible to construct vertices without a sub index, in which case they point to a component rather than a specific variable:</p><pre><code class="language-julia hljs">VIndex(2)          # references the second vertex model
VIndex(:a)         # references vertex with unique name :a</code></pre><p>For example <code>nw[VIndex(2)]</code> would return the 2nd <a href="#NetworkDynamics.VertexModel-Tuple{}"><code>VertexModel</code></a> in the <code>Network</code>.</p><p>See also: <a href="#NetworkDynamics.EIndex"><code>EIndex</code></a>, <a href="#NetworkDynamics.StateIdx"><code>StateIdx</code></a>, <a href="#NetworkDynamics.ParamIdx"><code>ParamIdx</code></a>, <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a>, <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L95-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.EIndex"><a class="docstring-binding" href="#NetworkDynamics.EIndex"><code>NetworkDynamics.EIndex</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EIndex{C,S} &lt;: SymbolicIndex{C,S}
idx = EIndex(comp, sub)</code></pre><p>A symbolic index for an edge variable.</p><ul><li><code>comp</code>: the component index, either int, symbol, pair or a collection</li><li><code>sub</code>: the subindex, either int, symbol or a collection of those.</li></ul><p>Symbolic indices are rather flexible and can potentially point to states, parameters, inputs, outputs, or observables.</p><p>The most basic form is <code>EIndex(1, :P)</code> which points to the variable with the name <code>:P</code> in the first edge model. The component can be also given by unique name, so <code>EIndex(:a, :P)</code> would point to the edge with unique name <code>:a</code>. For edges, the component can also be specified as a source-destination pair:</p><pre><code class="language-julia hljs">EIndex(1=&gt;2, :P)    # variable :P in edge from vertex 1 to vertex 2
EIndex(:a=&gt;:b, :P)  # variable :P in edge from vertex :a to vertex :b</code></pre><p>It is also possible to have &quot;collections&quot; of indices, such as</p><pre><code class="language-julia hljs">EIndex(1:5, 1)     # first state of edges 1 to 5
EIndex(7, (:x,:y)) # states :x and :y of edge 7</code></pre><p>They can be used to index into objects supporting the <code>SymbolicIndexingInterface</code>, e.g. <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a> or <code>ODESolution</code>.</p><p>It is also possible to construct edges without a sub index, in which case they point to a component rather than a specific variable:</p><pre><code class="language-julia hljs">EIndex(2)          # references the second edge model
EIndex(1=&gt;2)       # references edge from v1 to v2
EIndex(:a=&gt;:b)     # references edge from vertex :a to vertex :b</code></pre><p>For example <code>nw[EIndex(2)]</code> would return the 2nd <a href="#NetworkDynamics.EdgeModel-Tuple{}"><code>EdgeModel</code></a> in the <code>Network</code>.</p><p>See also: <a href="#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="#NetworkDynamics.StateIdx"><code>StateIdx</code></a>, <a href="#NetworkDynamics.ParamIdx"><code>ParamIdx</code></a>, <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a>, <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L136-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ParamIdx"><a class="docstring-binding" href="#NetworkDynamics.ParamIdx"><code>NetworkDynamics.ParamIdx</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ParamIdx{T} &lt;: NumericSubIndex{T}</code></pre><p>Wrapper type for indexing into parameters by index rather than symbol. <code>VPIndex(:name, 1)</code> is equivalent to <code>VIndex(:name, ParamIdx(1))</code> and tells NetworkDynamics that you mean the first parameter of the component in contrast to the first state of the component. Similarly, <code>ParamIdx(:)</code>, <code>ParamIdx(1:3)</code> or <code>ParamIdx([1,2,3])</code> can be used to access multiple parameters by numeric index at once.</p><p>See also: <a href="#NetworkDynamics.StateIdx"><code>StateIdx</code></a>, <a href="#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="#NetworkDynamics.EIndex"><code>EIndex</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L4-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.StateIdx"><a class="docstring-binding" href="#NetworkDynamics.StateIdx"><code>NetworkDynamics.StateIdx</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateIdx{T} &lt;: NumericSubIndex{T}</code></pre><p>Wrapper type for indexing into states by index rather than symbol. <code>VIndex(:name, 1)</code> is equivalent to <code>VIndex(:name, StateIdx(1))</code> and tells NetworkDynamics that you mean the first state of the component in contrast to the first parameter of the component. Similarly, <code>StateIdx(:)</code>, <code>StateIdx(1:3)</code> or <code>StateIdx([1,2,3])</code> can be used to access multiple states by numeric index at once.</p><p>See also: <a href="#NetworkDynamics.ParamIdx"><code>ParamIdx</code></a>, <a href="#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="#NetworkDynamics.EIndex"><code>EIndex</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L23-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.@obsex"><a class="docstring-binding" href="#NetworkDynamics.@obsex"><code>NetworkDynamics.@obsex</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@obsex([name =] expression)</code></pre><p>Define observable expressions, which are simple combinations of known states/parameters/observables. <code>@obsex(...)</code> returns an <code>ObservableExpression</code> which can be used as an symbolic index. This is mainly intended for quick plotting or export of common &quot;derived&quot; variables, such as the argument of a 2-component complex state. For example:</p><pre><code class="language-julia hljs">sol(t; idxs=@obsex(arg = atan(VIndex(1,:u_i), VIndex(1,:u_r))]
sol(t; idxs=@obsex(δrel = VIndex(1,:δ) - VIndex(2,:δ)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L986-L998">source</a></section></details></article><p>Retained for backward compatibility:</p><article><details class="docstring" open="true"><summary id="NetworkDynamics.VPIndex"><a class="docstring-binding" href="#NetworkDynamics.VPIndex"><code>NetworkDynamics.VPIndex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">VPIndex(c, s)</code></pre><p>Backward compatibility constructor for vertex parameter indices. Wraps integer-like subindices in <code>ParamIdx</code>, leaves other types unchanged. Equivalent to <code>VIndex(c, ParamIdx(s))</code> when <code>s</code> is integer-like, otherwise <code>VIndex(c, s)</code>.</p><p>See also: <a href="#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="#NetworkDynamics.ParamIdx"><code>ParamIdx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L190-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.EPIndex"><a class="docstring-binding" href="#NetworkDynamics.EPIndex"><code>NetworkDynamics.EPIndex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">EPIndex(c, s)</code></pre><p>Backward compatibility constructor for edge parameter indices. Wraps integer-like subindices in <code>ParamIdx</code>, leaves other types unchanged. Equivalent to <code>EIndex(c, ParamIdx(s))</code> when <code>s</code> is integer-like, otherwise <code>EIndex(c, s)</code>.</p><p>See also: <a href="#NetworkDynamics.EIndex"><code>EIndex</code></a>, <a href="#NetworkDynamics.ParamIdx"><code>ParamIdx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L202-L210">source</a></section></details></article><h3 id="Index-generators"><a class="docs-heading-anchor" href="#Index-generators">Index generators</a><a id="Index-generators-1"></a><a class="docs-heading-anchor-permalink" href="#Index-generators" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.generate_indices"><a class="docstring-binding" href="#NetworkDynamics.generate_indices"><code>NetworkDynamics.generate_indices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">generate_indices(inpr, compfilter=nothing, varfilter=nothing;
                s=true, p=true, out=true, obs=true, in=true, just_count=false)</code></pre><p>Generate collections of valid symbolic indices with flexible filtering criteria.</p><p><strong>Arguments</strong></p><ul><li><code>inpr</code>: Index provider - Network or Network wrapper like <code>NWState</code>, <code>NWParameter</code>, <code>sol</code>, etc.</li><li><code>compfilter</code><ul><li><code>nothing</code> - matches all components (default)</li><li><code>VIndex(1)</code> - matches component by number</li><li><code>VIndex(:name)</code> - matches by exact component name</li><li><code>VIndex(&quot;pattern&quot;)</code> or <code>VIndex(r&quot;pattern&quot;)</code> - matches by <code>contains(name, pattern)</code></li><li>Vector-like: <code>VIndex(1:10)</code> matches vertices 1-10, <code>[VIndex(:), EIndex(:)]</code> matches all vertices and edges</li><li><code>EIndex(src=&gt;dst)</code> - matches edges where src and dst vertices match (can be Int, Symbol, Regex, ...)</li></ul></li><li><code>varfilter</code><ul><li><code>nothing</code> - matches all variables (default)</li><li><code>:name</code> - matches variable <code>:name</code> exactly</li><li><code>&quot;namepart&quot;</code> or <code>r&quot;namepart&quot;</code> - matches by <code>contains(variable_name, pattern)</code></li><li><code>StateIdx(1)</code> or <code>ParamIdx(1)</code> - matches by numeric position</li><li>Vector-like: <code>[:foo, StateIdx(1), r&quot;part&quot;]</code> matches any of the filters</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>s=true</code> - include states</li><li><code>p=true</code> - include parameters</li><li><code>out=true</code> - include outputs</li><li><code>obs=false</code> - include observables</li><li><code>in=false</code> - include inputs</li><li><code>just_count=false</code> - return count instead of indices</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># All vertex states and parameters
generate_indices(nw, VIndex(:))

# Parameters of vertex with name :generator
generate_indices(nw, VIndex(:generator); s=false, p=true, out=false)

# All variables containing &quot;voltage&quot; in vertices 1-5
generate_indices(nw, VIndex(1:5), &quot;voltage&quot;)

# First parameter of all vertices using numeric indexing
generate_indices(nw, VIndex(:), ParamIdx(1); s=false, out=false)</code></pre><p>See also: <a href="#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a>, <a href="#NetworkDynamics.vidxs"><code>vidxs</code></a>, <a href="#NetworkDynamics.eidxs"><code>eidxs</code></a>, <a href="#NetworkDynamics.vpidxs"><code>vpidxs</code></a>, <a href="#NetworkDynamics.epidxs"><code>epidxs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L406-L452">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.vidxs"><a class="docstring-binding" href="#NetworkDynamics.vidxs"><code>NetworkDynamics.vidxs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vidxs(nw, cf=:, vf=nothing; kwargs...)</code></pre><p>Generate vertex indices for states, parameters, inputs, outputs, and observables. Equivalent to <code>generate_indices(nw, VIndex(cf), vf; s=true, p=true, in=true, out=true, obs=true, kwargs...)</code>.</p><p>See also: <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L587-L594">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.eidxs"><a class="docstring-binding" href="#NetworkDynamics.eidxs"><code>NetworkDynamics.eidxs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">eidxs(nw, cf=:, vf=nothing; kwargs...)</code></pre><p>Generate edge indices for states, parameters, inputs, outputs, and observables. Equivalent to <code>generate_indices(nw, EIndex(cf), vf; s=true, p=true, in=true, out=true, obs=true, kwargs...)</code>.</p><p>See also: <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L599-L606">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.vpidxs"><a class="docstring-binding" href="#NetworkDynamics.vpidxs"><code>NetworkDynamics.vpidxs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vpidxs(nw, cf=:, vf=nothing; kwargs...)</code></pre><p>Generate vertex parameter indices. Equivalent to <code>generate_indices(nw, VIndex(cf), vf; s=false, p=true, in=false, out=false, obs=false, kwargs...)</code>.</p><p>See also: <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L611-L618">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.epidxs"><a class="docstring-binding" href="#NetworkDynamics.epidxs"><code>NetworkDynamics.epidxs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">epidxs(nw, cf=:, vf=nothing; kwargs...)</code></pre><p>Generate edge parameter indices. Equivalent to <code>generate_indices(nw, EIndex(cf), vf; s=false, p=true, in=false, out=false, obs=false, kwargs...)</code>.</p><p>See also: <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L623-L630">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.FilteringProxy"><a class="docstring-binding" href="#NetworkDynamics.FilteringProxy"><code>NetworkDynamics.FilteringProxy</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FilteringProxy{S,CF,VF} &lt;: IndexingProxy{S}
FilteringProxy(s::NWState)
FilteringProxy(p::NWParameter)
(s::NWState).v # creates a FilteringProxy</code></pre><p>Interactive filtering proxy for exploring and accessing states/parameters in NetworkDynamics objects.</p><p><code>FilteringProxy</code> provides a flexible, interactive way to filter and access network variables through a progressive refinement system. It acts as a &quot;proxy&quot; that changes indexing rules while operating on the same underlying data, allowing both exploration and modification of network states/parameters.</p><p><strong>Core Concept</strong></p><p>The proxy uses a filter refinement approach where each indexing operation either:</p><ul><li>Returns a more refined <code>FilteringProxy</code> (if the filter needs more specificity)</li><li>Returns the actual values (if the filter is fully specified)</li></ul><p>All filtering operations translate to equivalent <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a> calls under the hood.</p><p><strong>Stage 1: Component Filtering</strong></p><p>Access vertices and edges using <code>.v</code> and <code>.e</code> properties:</p><pre><code class="language-julia hljs">s = NWState(nw)
s.v          # FilteringProxy for all vertices
s.e          # FilteringProxy for all edges
s.v[1]       # Refine to vertex 1
s.v[:gen]    # Refine to vertices named :gen
s.v[r&quot;load&quot;] # Refine to vertices matching pattern
FilteringProxy(s)[[VIndex(1), EIndex(2)]] # filter down to the first vertex and second edge</code></pre><p><strong>Stage 2: Variable Filtering</strong></p><p>Once the component filter is set, the next indexing operation will refine the variable filter.</p><pre><code class="language-julia hljs">s.v[1][:voltage]          # value of Vertex(1) + variable called :voltage
s.v[:][r&quot;δ&quot;]              # value of all variables containing &quot;δ&quot; of all vertices
s.e[1=&gt;2].s[StateIdx(1)]  # First state of edge from vertex 1 to 2</code></pre><p><strong>Variable Type Filtering</strong></p><p>Use type switches to select specific variable categories:</p><pre><code class="language-julia hljs">s.v.p        # Parameters only
s.v.s        # States only
s.v.out      # Outputs only
s.v.obs      # Observables only
s.v.in       # Inputs only
s.v.all      # All variable types
s.v(; p=true, s=true) # fine grade filter update using function call syntax</code></pre><p><strong>Function Call Syntax</strong></p><p>Use function call syntax <code>proxy(args...)</code> to refine without collapsing to values:</p><pre><code class="language-julia hljs">proxy = s.v(1)(:voltage)  # Build filter without accessing values
value = proxy[]           # Access value when ready</code></pre><p>The function call syntax can also be used to refine any other properties. The properties match the argument names of <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a></p><pre><code class="language-julia hljs">s.v[1](; p=true)            # equivalent to s.v[1].p
s.v(; compfilter=EIndex(:)) # resets the compfilter and now matches all edges</code></pre><p><strong>Utility Methods</strong></p><ul><li><code>keys(proxy)</code> - Get matching symbolic indices via <code>generate_indices</code></li><li><code>values(proxy) / proxy[]</code> - Get actual values for all matching indices</li></ul><p>See also: <a href="#NetworkDynamics.generate_indices"><code>generate_indices</code></a>, <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a>, <a href="#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="#NetworkDynamics.EIndex"><code>EIndex</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L652-L727">source</a></section></details></article><h2 id="Metadata-API"><a class="docs-heading-anchor" href="#Metadata-API">Metadata API</a><a id="Metadata-API-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata-API" title="Permalink"></a></h2><h3 id="Component-Metadata-API"><a class="docs-heading-anchor" href="#Component-Metadata-API">Component Metadata API</a><a id="Component-Metadata-API-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Metadata-API" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.metadata"><a class="docstring-binding" href="#NetworkDynamics.metadata"><code>NetworkDynamics.metadata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">metadata(c::ComponentModel)</code></pre><p>Retrieve metadata object for the component.</p><p>See also <a href="#NetworkDynamics.metadata"><code>metadata</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L457-L463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}"><a class="docstring-binding" href="#NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}"><code>NetworkDynamics.has_metadata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_metadata(c::ComponentModel, key::Symbol)
has_metadata(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)</code></pre><p>Checks if metadata <code>key</code> is present for the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L445-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}"><a class="docstring-binding" href="#NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}"><code>NetworkDynamics.get_metadata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_metadata(c::ComponentModel, key::Symbol)
get_metadata(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)</code></pre><p>Retrieves the metadata <code>key</code> for the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L457-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><a class="docstring-binding" href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>NetworkDynamics.set_metadata!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_metadata!(c::ComponentModel, key::Symbol, value)
set_metadata!(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol, value)</code></pre><p>Sets the metadata <code>key</code> for the component to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L467-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol}"><a class="docstring-binding" href="#NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol}"><code>NetworkDynamics.delete_metadata!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">delete_metadata!(c::ComponentModel, key::Symbol)
delete_metadata!(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)</code></pre><p>Removes the component-wide metadata <code>key</code> from the component model, or from a component referenced by <code>idx</code> in a network. Returns <code>true</code> if the metadata existed and was removed, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L477-L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_graphelement"><a class="docstring-binding" href="#NetworkDynamics.has_graphelement"><code>NetworkDynamics.has_graphelement</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_graphelement(c::ComponentModel)
has_graphelement(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Checks if the edge or vertex function has the <code>graphelement</code> metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L498-L503">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_graphelement"><a class="docstring-binding" href="#NetworkDynamics.get_graphelement"><code>NetworkDynamics.get_graphelement</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_graphelement(c::EdgeModel)::@NamedTuple{src::T, dst::T}
get_graphelement(c::VertexModel)::Int
get_graphelement(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Retrieves the <code>graphelement</code> metadata for the component model. For edges this returns a named tuple <code>(;src, dst)</code> where both are either integers (vertex index) or symbols (vertex name).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L508-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_graphelement!"><a class="docstring-binding" href="#NetworkDynamics.set_graphelement!"><code>NetworkDynamics.set_graphelement!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_graphelement!(c::EdgeModel, nt::@NamedTuple{src::T, dst::T})
set_graphelement!(c::EdgeModel, p::Pair)
set_graphelement!(c::VertexModel, vidx::Int)
set_graphelement!(nw::Network, idx::Union{VIndex,EIndex}, value)</code></pre><p>Sets the <code>graphelement</code> metadata for the component. For edges this takes a named tuple <code>(;src, dst)</code> where both are either integer (vertex index) or symbol (vertex name). For vertices it takes a single integer <code>vidx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L522-L531">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_position"><a class="docstring-binding" href="#NetworkDynamics.has_position"><code>NetworkDynamics.has_position</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_position(v::VertexModel)
has_position(nw::Network, vidx::VIndex)</code></pre><p>Checks if vertex <code>v</code> has <code>position</code> metadata.</p><p>See also: <a href="#NetworkDynamics.get_position"><code>get_position</code></a>, <a href="#NetworkDynamics.set_position!"><code>set_position!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L926-L933">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_position"><a class="docstring-binding" href="#NetworkDynamics.get_position"><code>NetworkDynamics.get_position</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_position(v::VertexModel)
get_position(nw::Network, vidx::VIndex)</code></pre><p>Returns the <code>position</code> metadata of vertex <code>v</code>. Might error if not present.</p><p>See also: <a href="#NetworkDynamics.has_position"><code>has_position</code></a>, <a href="#NetworkDynamics.set_position!"><code>set_position!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L937-L944">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_position!"><a class="docstring-binding" href="#NetworkDynamics.set_position!"><code>NetworkDynamics.set_position!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_position!(v::VertexModel, val)
set_position!(nw::Network, vidx::VIndex, val)</code></pre><p>Sets the <code>position</code> metadata of vertex <code>v</code> to <code>val</code>.</p><p>See also: <a href="#NetworkDynamics.has_position"><code>has_position</code></a>, <a href="#NetworkDynamics.get_position"><code>get_position</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L948-L955">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_marker"><a class="docstring-binding" href="#NetworkDynamics.has_marker"><code>NetworkDynamics.has_marker</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_marker(v::VertexModel)
has_marker(nw::Network, vidx::VIndex)</code></pre><p>Checks if vertex <code>v</code> has <code>marker</code> metadata.</p><p>See also: <a href="#NetworkDynamics.get_marker"><code>get_marker</code></a>, <a href="#NetworkDynamics.set_marker!"><code>set_marker!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L926-L933">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_marker"><a class="docstring-binding" href="#NetworkDynamics.get_marker"><code>NetworkDynamics.get_marker</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_marker(v::VertexModel)
get_marker(nw::Network, vidx::VIndex)</code></pre><p>Returns the <code>marker</code> metadata of vertex <code>v</code>. Might error if not present.</p><p>See also: <a href="#NetworkDynamics.has_marker"><code>has_marker</code></a>, <a href="#NetworkDynamics.set_marker!"><code>set_marker!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L937-L944">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_marker!"><a class="docstring-binding" href="#NetworkDynamics.set_marker!"><code>NetworkDynamics.set_marker!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_marker!(v::VertexModel, val)
set_marker!(nw::Network, vidx::VIndex, val)</code></pre><p>Sets the <code>marker</code> metadata of vertex <code>v</code> to <code>val</code>.</p><p>See also: <a href="#NetworkDynamics.has_marker"><code>has_marker</code></a>, <a href="#NetworkDynamics.get_marker"><code>get_marker</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L948-L955">source</a></section></details></article><h3 id="Per-Symbol-Metadata-API"><a class="docs-heading-anchor" href="#Per-Symbol-Metadata-API">Per-Symbol Metadata API</a><a id="Per-Symbol-Metadata-API-1"></a><a class="docs-heading-anchor-permalink" href="#Per-Symbol-Metadata-API" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.symmetadata"><a class="docstring-binding" href="#NetworkDynamics.symmetadata"><code>NetworkDynamics.symmetadata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetadata(c::ComponentModel)::Dict{Symbol,Dict{Symbol,Any}}</code></pre><p>Retrieve the metadata dictionary for the symbols. Keys are the names of the symbols as they appear in <a href="#NetworkDynamics.sym"><code>sym</code></a>, <a href="#NetworkDynamics.psym"><code>psym</code></a>, <a href="#NetworkDynamics.obssym"><code>obssym</code></a> and <a href="#NetworkDynamics.insym"><code>insym</code></a>.</p><p>See also <a href="#NetworkDynamics.symmetadata"><code>symmetadata</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L447-L454">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}"><a class="docstring-binding" href="#NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}"><code>NetworkDynamics.get_metadata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_metadata(c::ComponentModel, sym::Symbol, key::Symbol)
get_metadata(nw::Network, sni::SymbolicIndex, key::Symbol)</code></pre><p>Retrieves the metadata <code>key</code> for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can also be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>Throws an error if the symbol does not exist in the component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L63-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}"><a class="docstring-binding" href="#NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}"><code>NetworkDynamics.has_metadata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_metadata(c::ComponentModel, sym::Symbol, key::Symbol)
has_metadata(nw::Network, sni::SymbolicIndex, key::Symbol)</code></pre><p>Checks if symbol metadata <code>key</code> is present for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can also be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>Throws an error if the symbol does not exist in the component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L39-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol, Any}"><a class="docstring-binding" href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol, Any}"><code>NetworkDynamics.set_metadata!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_metadata!(c::ComponentModel, sym::Symbol, key::Symbol, value)
set_metadata!(nw::Network, sni::SymbolicIndex, key::Symbol, value)
set_metadata!(c::ComponentModel, sym::Symbol, pair::Pair)
set_metadata!(nw::Network, sni::SymbolicIndex, pair::Pair)</code></pre><p>Sets the metadata <code>key</code> for symbol <code>sym</code> to <code>value</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p>For component models, you can also use a <code>String</code> or <code>Regex</code> pattern to match symbol names:</p><ul><li>String patterns use substring matching (e.g., <code>&quot;δ&quot;</code> matches <code>machine₊δ</code>)</li><li>Regex patterns use full regex matching (e.g., <code>r&quot;P$&quot;</code> matches symbols ending with &quot;P&quot;)</li></ul><p>This will error if there are none or multiple matches.</p><p>If the pattern matches multiple symbols, an error is thrown. Use a more specific pattern. Throws an error if the symbol does not exist in the component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L86-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}"><a class="docstring-binding" href="#NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}"><code>NetworkDynamics.delete_metadata!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">delete_metadata!(c::ComponentModel, sym::Symbol, key::Symbol)
delete_metadata!(nw::Network, sni::SymbolicIndex, key::Symbol)</code></pre><p>Removes the metadata <code>key</code> for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can also be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>Returns <code>true</code> if the metadata existed and was removed, <code>false</code> otherwise. Throws an error if the symbol does not exist in the component model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L123-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.strip_metadata!"><a class="docstring-binding" href="#NetworkDynamics.strip_metadata!"><code>NetworkDynamics.strip_metadata!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">strip_metadata!(c::ComponentModel, key::Symbol)</code></pre><p>Remove all metadata of type <code>key</code> from the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L153-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_default"><a class="docstring-binding" href="#NetworkDynamics.has_default"><code>NetworkDynamics.has_default</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_default(c::ComponentModel, sym::Symbol)
has_default(nw::Network, sni::SymbolicIndex)</code></pre><p>Checks if a <code>default</code> value is present for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.get_default"><code>get_default</code></a>, <a href="#NetworkDynamics.set_default!"><code>set_default!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L181-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_default"><a class="docstring-binding" href="#NetworkDynamics.get_default"><code>NetworkDynamics.get_default</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_default(c::ComponentModel, sym::Symbol)
get_default(nw::Network, sni::SymbolicIndex)</code></pre><p>Returns the <code>default</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_default"><code>has_default</code></a>, <a href="#NetworkDynamics.set_default!"><code>set_default!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L194-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_default!"><a class="docstring-binding" href="#NetworkDynamics.set_default!"><code>NetworkDynamics.set_default!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_default!(c::ComponentModel, sym::Symbol, value)
set_default!(nw::Network, sni::SymbolicIndex, value)</code></pre><p>Sets the <code>default</code> value for symbol <code>sym</code> to <code>value</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p>If <code>value</code> is <code>nothing</code> or <code>missing</code>, the metadata is removed.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_default"><code>has_default</code></a>, <a href="#NetworkDynamics.get_default"><code>get_default</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L207-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_default!"><a class="docstring-binding" href="#NetworkDynamics.delete_default!"><code>NetworkDynamics.delete_default!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_default!(c::ComponentModel, sym::Symbol)
delete_default!(nw::Network, sni::SymbolicIndex)</code></pre><p>Removes the <code>default</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_default"><code>has_default</code></a>, <a href="#NetworkDynamics.set_default!"><code>set_default!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L228-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.strip_defaults!"><a class="docstring-binding" href="#NetworkDynamics.strip_defaults!"><code>NetworkDynamics.strip_defaults!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">strip_default!(c::ComponentModel)
strip_default!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes all <code>default</code> values from a component model, or from a component referenced by <code>idx</code> in a network.</p><p>See also <a href="#NetworkDynamics.delete_default!"><code>delete_default!</code></a>, <a href="#NetworkDynamics.set_default!"><code>set_default!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L241-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_guess"><a class="docstring-binding" href="#NetworkDynamics.has_guess"><code>NetworkDynamics.has_guess</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_guess(c::ComponentModel, sym::Symbol)
has_guess(nw::Network, sni::SymbolicIndex)</code></pre><p>Checks if a <code>guess</code> value is present for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.get_guess"><code>get_guess</code></a>, <a href="#NetworkDynamics.set_guess!"><code>set_guess!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L181-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_guess"><a class="docstring-binding" href="#NetworkDynamics.get_guess"><code>NetworkDynamics.get_guess</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_guess(c::ComponentModel, sym::Symbol)
get_guess(nw::Network, sni::SymbolicIndex)</code></pre><p>Returns the <code>guess</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_guess"><code>has_guess</code></a>, <a href="#NetworkDynamics.set_guess!"><code>set_guess!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L194-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_guess!"><a class="docstring-binding" href="#NetworkDynamics.set_guess!"><code>NetworkDynamics.set_guess!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_guess!(c::ComponentModel, sym::Symbol, value)
set_guess!(nw::Network, sni::SymbolicIndex, value)</code></pre><p>Sets the <code>guess</code> value for symbol <code>sym</code> to <code>value</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p>If <code>value</code> is <code>nothing</code> or <code>missing</code>, the metadata is removed.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_guess"><code>has_guess</code></a>, <a href="#NetworkDynamics.get_guess"><code>get_guess</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L207-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_guess!"><a class="docstring-binding" href="#NetworkDynamics.delete_guess!"><code>NetworkDynamics.delete_guess!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_guess!(c::ComponentModel, sym::Symbol)
delete_guess!(nw::Network, sni::SymbolicIndex)</code></pre><p>Removes the <code>guess</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_guess"><code>has_guess</code></a>, <a href="#NetworkDynamics.set_guess!"><code>set_guess!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L228-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.strip_guesses!"><a class="docstring-binding" href="#NetworkDynamics.strip_guesses!"><code>NetworkDynamics.strip_guesses!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">strip_guess!(c::ComponentModel)
strip_guess!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes all <code>guess</code> values from a component model, or from a component referenced by <code>idx</code> in a network.</p><p>See also <a href="#NetworkDynamics.delete_guess!"><code>delete_guess!</code></a>, <a href="#NetworkDynamics.set_guess!"><code>set_guess!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L241-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_init"><a class="docstring-binding" href="#NetworkDynamics.has_init"><code>NetworkDynamics.has_init</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_init(c::ComponentModel, sym::Symbol)
has_init(nw::Network, sni::SymbolicIndex)</code></pre><p>Checks if a <code>init</code> value is present for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.get_init"><code>get_init</code></a>, <a href="#NetworkDynamics.set_init!"><code>set_init!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L181-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_init"><a class="docstring-binding" href="#NetworkDynamics.get_init"><code>NetworkDynamics.get_init</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_init(c::ComponentModel, sym::Symbol)
get_init(nw::Network, sni::SymbolicIndex)</code></pre><p>Returns the <code>init</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_init"><code>has_init</code></a>, <a href="#NetworkDynamics.set_init!"><code>set_init!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L194-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_init!"><a class="docstring-binding" href="#NetworkDynamics.set_init!"><code>NetworkDynamics.set_init!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_init!(c::ComponentModel, sym::Symbol, value)
set_init!(nw::Network, sni::SymbolicIndex, value)</code></pre><p>Sets the <code>init</code> value for symbol <code>sym</code> to <code>value</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p>If <code>value</code> is <code>nothing</code> or <code>missing</code>, the metadata is removed.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_init"><code>has_init</code></a>, <a href="#NetworkDynamics.get_init"><code>get_init</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L207-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_init!"><a class="docstring-binding" href="#NetworkDynamics.delete_init!"><code>NetworkDynamics.delete_init!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_init!(c::ComponentModel, sym::Symbol)
delete_init!(nw::Network, sni::SymbolicIndex)</code></pre><p>Removes the <code>init</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_init"><code>has_init</code></a>, <a href="#NetworkDynamics.set_init!"><code>set_init!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L228-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.strip_inits!"><a class="docstring-binding" href="#NetworkDynamics.strip_inits!"><code>NetworkDynamics.strip_inits!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">strip_init!(c::ComponentModel)
strip_init!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes all <code>init</code> values from a component model, or from a component referenced by <code>idx</code> in a network.</p><p>See also <a href="#NetworkDynamics.delete_init!"><code>delete_init!</code></a>, <a href="#NetworkDynamics.set_init!"><code>set_init!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L241-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_bounds"><a class="docstring-binding" href="#NetworkDynamics.has_bounds"><code>NetworkDynamics.has_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_bounds(c::ComponentModel, sym::Symbol)
has_bounds(nw::Network, sni::SymbolicIndex)</code></pre><p>Checks if a <code>bounds</code> value is present for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.get_bounds"><code>get_bounds</code></a>, <a href="#NetworkDynamics.set_bounds!"><code>set_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L181-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_bounds"><a class="docstring-binding" href="#NetworkDynamics.get_bounds"><code>NetworkDynamics.get_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_bounds(c::ComponentModel, sym::Symbol)
get_bounds(nw::Network, sni::SymbolicIndex)</code></pre><p>Returns the <code>bounds</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_bounds"><code>has_bounds</code></a>, <a href="#NetworkDynamics.set_bounds!"><code>set_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L194-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_bounds!"><a class="docstring-binding" href="#NetworkDynamics.set_bounds!"><code>NetworkDynamics.set_bounds!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_bounds!(c::ComponentModel, sym::Symbol, value)
set_bounds!(nw::Network, sni::SymbolicIndex, value)</code></pre><p>Sets the <code>bounds</code> value for symbol <code>sym</code> to <code>value</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p>If <code>value</code> is <code>nothing</code> or <code>missing</code>, the metadata is removed.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_bounds"><code>has_bounds</code></a>, <a href="#NetworkDynamics.get_bounds"><code>get_bounds</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L207-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_bounds!"><a class="docstring-binding" href="#NetworkDynamics.delete_bounds!"><code>NetworkDynamics.delete_bounds!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_bounds!(c::ComponentModel, sym::Symbol)
delete_bounds!(nw::Network, sni::SymbolicIndex)</code></pre><p>Removes the <code>bounds</code> value for symbol <code>sym</code> in a component model, or for a symbol referenced by <code>sni</code> in a network.</p><p><code>sym</code> can be a String or Regex, to address the only symbol containing the pattern, see <a href="#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}"><code>set_metadata!</code></a> for details.</p><p>See also <a href="#NetworkDynamics.has_bounds"><code>has_bounds</code></a>, <a href="#NetworkDynamics.set_bounds!"><code>set_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L228-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.strip_bounds!"><a class="docstring-binding" href="#NetworkDynamics.strip_bounds!"><code>NetworkDynamics.strip_bounds!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">strip_bounds!(c::ComponentModel)
strip_bounds!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes all <code>bounds</code> values from a component model, or from a component referenced by <code>idx</code> in a network.</p><p>See also <a href="#NetworkDynamics.delete_bounds!"><code>delete_bounds!</code></a>, <a href="#NetworkDynamics.set_bounds!"><code>set_bounds!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L241-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_defaults!"><a class="docstring-binding" href="#NetworkDynamics.set_defaults!"><code>NetworkDynamics.set_defaults!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_defaults!(nw::Network, s::NWState)</code></pre><p>Set the default values of the network to the values of the given state. Can be used to &quot;store&quot; the found fixpoint in the network metadata.</p><p>Values of <code>missing</code>, <code>nothing</code> or <code>NaN</code> are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L408-L415">source</a></section><section><div><pre><code class="language-julia hljs">set_defaults!(nw::Network, p::NWParameter)</code></pre><p>Set the parameter default values of the network to the values of the given parameter object.</p><p>Values of <code>missing</code>, <code>nothing</code> or <code>NaN</code> are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L426-L432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_interface_defaults!"><a class="docstring-binding" href="#NetworkDynamics.set_interface_defaults!"><code>NetworkDynamics.set_interface_defaults!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_interface_defaults!(nw::Network, s::NWState; verbose=false)</code></pre><p>Sets the <strong>interface</strong> (i.e., node and edge inputs/outputs) defaults of a given network to the ones defined by the given state. Notably, while the graph topology and interface dimensions of the target network <code>nw</code> and the source network of <code>s</code> must be identical, the systems may differ in the dynamical components.</p><p>This is mainly intended for initialization purposes: solve the interface values with a simpler – possibly static – network and &quot;transfer&quot; the steady state interface values to the full network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L1301-L1313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_defaults_dict"><a class="docstring-binding" href="#NetworkDynamics.get_defaults_dict"><code>NetworkDynamics.get_defaults_dict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_defaults_dict(c::ComponentModel)</code></pre><p>Returns a dictionary mapping symbols to their default values. Only includes symbols that have default values set.</p><p>See also: <a href="#NetworkDynamics.get_guesses_dict"><code>get_guesses_dict</code></a>, <a href="#NetworkDynamics.get_inits_dict"><code>get_inits_dict</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L357-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_guesses_dict"><a class="docstring-binding" href="#NetworkDynamics.get_guesses_dict"><code>NetworkDynamics.get_guesses_dict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_guesses_dict(c::ComponentModel)</code></pre><p>Returns a dictionary mapping symbols to their guess values. Only includes symbols that have guess values set.</p><p>See also: <a href="#NetworkDynamics.get_defaults_dict"><code>get_defaults_dict</code></a>, <a href="#NetworkDynamics.get_inits_dict"><code>get_inits_dict</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L366-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_bounds_dict"><a class="docstring-binding" href="#NetworkDynamics.get_bounds_dict"><code>NetworkDynamics.get_bounds_dict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_bounds_dict(c::ComponentModel)</code></pre><p>Returns a dictionary mapping symbols to their bounds values. Only includes symbols that have bounds values set.</p><p>See also: <a href="#NetworkDynamics.get_defaults_dict"><code>get_defaults_dict</code></a>, <a href="#NetworkDynamics.get_guesses_dict"><code>get_guesses_dict</code></a>, <a href="#NetworkDynamics.get_inits_dict"><code>get_inits_dict</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L384-L391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_inits_dict"><a class="docstring-binding" href="#NetworkDynamics.get_inits_dict"><code>NetworkDynamics.get_inits_dict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_inits_dict(c::ComponentModel)</code></pre><p>Returns a dictionary mapping symbols to their initialization values. Only includes symbols that have initialization values set.</p><p>See also: <a href="#NetworkDynamics.get_defaults_dict"><code>get_defaults_dict</code></a>, <a href="#NetworkDynamics.get_guesses_dict"><code>get_guesses_dict</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L375-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.free_u"><a class="docstring-binding" href="#NetworkDynamics.free_u"><code>NetworkDynamics.free_u</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">free_u(nw::Network)
free_u(cf::ComponentModel)</code></pre><p>Returns the &quot;free&quot; variables/states (variables without default values) for the given system.</p><p><strong>Returns</strong></p><ul><li>Vector of variable/state symbols that do not have default values set</li></ul><p>See also: <a href="#NetworkDynamics.free_p"><code>free_p</code></a>, <a href="#NetworkDynamics.has_default"><code>has_default</code></a>, <a href="#NetworkDynamics.set_default!"><code>set_default!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L1275-L1285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.free_p"><a class="docstring-binding" href="#NetworkDynamics.free_p"><code>NetworkDynamics.free_p</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">free_p(cf::ComponentModel)
free_p(nw::Network)</code></pre><p>Returns the &quot;free&quot; parameters (parameters without default values) for the given system.</p><p><strong>Returns</strong></p><ul><li>Vector of parameter symbols that do not have default values set</li></ul><p>See also: <a href="#NetworkDynamics.free_u"><code>free_u</code></a>, <a href="#NetworkDynamics.has_default"><code>has_default</code></a>, <a href="#NetworkDynamics.set_default!"><code>set_default!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L1257-L1267">source</a></section></details></article><h3 id="Metadata-and-Inspection-Utils"><a class="docs-heading-anchor" href="#Metadata-and-Inspection-Utils">Metadata and Inspection Utils</a><a id="Metadata-and-Inspection-Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata-and-Inspection-Utils" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.dump_state"><a class="docstring-binding" href="#NetworkDynamics.dump_state"><code>NetworkDynamics.dump_state</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dump_state([IO=stdout], sol, t, idx; sigdigits=5)</code></pre><p>Takes a Network solution <code>sol</code> and prints the state at <code>t</code> as well as the initial state of the specified component model to <code>IO</code> (defaults to <code>stdout</code>).</p><p><code>idx</code> musst a valid component index, i.e. <code>VIndex</code> or <code>EIndex</code> without symbol specification.</p><pre><code class="language-julia hljs">dump_state(sol, 1.0, VIndex(4))
dump_state(sol, 1.0, EIndex(2))</code></pre><p>See also: <a href="#NetworkDynamics.dump_initial_state"><code>dump_initial_state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L1136-L1148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.dump_initial_state"><a class="docstring-binding" href="#NetworkDynamics.dump_initial_state"><code>NetworkDynamics.dump_initial_state</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dump_initial_state([IO=stdout], cf::ComponentModel,
                   [defaults=get_defaults_dict(cf)],
                   [inits=get_inits_dict(cf)],
                   [guesses=get_guesses_dict(cf)],
                   [bounds=get_bounds_dict(cf)];
                   sigdigits=5, p=true, obs=true)</code></pre><p>Prints the initial state of the component model <code>cf</code> to <code>IO</code> (defaults to stdout). Optionally contains parameters and observed.</p><p>See also: <a href="#NetworkDynamics.get_initial_state"><code>get_initial_state</code></a> and <a href="#NetworkDynamics.dump_state"><code>dump_state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L1011-L1023">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_initial_state"><a class="docstring-binding" href="#NetworkDynamics.get_initial_state"><code>NetworkDynamics.get_initial_state</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_initial_state(c::ComponentModel, [state=get_defaults_or_inits_dict(c)], syms; missing_val=nothing)
get_initial_state(nw::Network, sni::SymbolicIndex; missing_val=nothing)</code></pre><p>Returns the initial state for symbol <code>sym</code> (single symbol or vector) of the component model <code>c</code>. Returns <code>missing_val</code> if the symbol is not initialized. Also works for observed symbols.</p><p>See also: <a href="#NetworkDynamics.dump_initial_state"><code>dump_initial_state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L964-L972">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.describe_vertices"><a class="docstring-binding" href="#NetworkDynamics.describe_vertices"><code>NetworkDynamics.describe_vertices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">describe_vertices(nw::Network, extras...; parameters=true, states=true, batch=nothing)</code></pre><p>Creates a DataFrame containing information about the vertices in a Network.</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The network to describe</li><li><code>extras...</code>: Additional pairs of (key, function) to include as columns,  where the function gets the <a href="#NetworkDynamics.VertexModel-Tuple{}"><code>VertexModel</code></a> as its only parameter  to extract a custom metadata field for example..</li><li><code>parameters=true</code>: Whether to include parameter values</li><li><code>states=true</code>: Whether to include state values</li><li><code>batch=nothing</code>: Optionally filter by specific batches</li></ul><p><strong>Returns</strong></p><p>A DataFrame with columns for vertex indices, names, batch numbers, and any parameter/state values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/ext/NetworkDynamicsDataFramesExt.jl#L33-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.describe_edges"><a class="docstring-binding" href="#NetworkDynamics.describe_edges"><code>NetworkDynamics.describe_edges</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">describe_edges(nw::Network, extras...; parameters=true, states=true, batch=nothing)</code></pre><p>Creates a DataFrame containing information about the edges in a Network.</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The network to describe</li><li><code>extras...</code>: Additional pairs of (key, function) to include as columns,  where the function gets the <a href="#NetworkDynamics.EdgeModel-Tuple{}"><code>EdgeModel</code></a> as its only parameter  to extract a custom metadata field for example..</li><li><code>parameters=true</code>: Whether to include parameter values</li><li><code>states=true</code>: Whether to include state values</li><li><code>batch=nothing</code>: Optionally filter by specific batches</li></ul><p><strong>Returns</strong></p><p>A DataFrame with columns for edge indices, source-destination pairs, names, batch numbers, and any parameter/state values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/ext/NetworkDynamicsDataFramesExt.jl#L81-L97">source</a></section></details></article><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.find_fixpoint"><a class="docstring-binding" href="#NetworkDynamics.find_fixpoint"><code>NetworkDynamics.find_fixpoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_fixpoint(nw::Network, [x0::NWState=NWState(nw)], [p::NWParameter=x0.p]; kwargs...)
find_fixpoint(nw::Network, x0::AbstractVector, p::AbstractVector; kwargs...)</code></pre><p>Find a steady-state (fixed-point) solution of the network dynamics by solving the nonlinear equation <code>f(u, p, t) = 0</code>, where <code>f</code> represents the network&#39;s right-hand side function.</p><p>This is a convenience wrapper around <code>SteadyStateProblem</code> from the SciML ecosystem that constructs and solves the steady state problem, returning the solution as an <code>NWState</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The network dynamics to find a fixed point for</li><li><code>x0</code>: Initial guess for the state variables. Can be:<ul><li><code>NWState</code>: Complete network state (default: <code>NWState(nw; ufill=0)</code>)</li><li><code>AbstractVector</code>: Flat state vector</li></ul></li><li><code>p</code>: Network parameters. Can be:<ul><li><code>NWParameter</code>: Complete parameter object (default: extracted from <code>x0</code> or <code>NWParameter(nw)</code>)</li><li><code>AbstractVector</code>: Flat parameter vector</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>alg=SSRootfind()</code>: Steady state solver algorithm from NonlinearSolve.jl</li><li><code>t=NaN</code>: Time at which to evaluate the system (for time-dependent networks)</li><li>Additional <code>kwargs</code> are passed to the SciML <code>solve</code> function</li></ul><p><strong>Returns</strong></p><ul><li><code>NWState</code>: Network state at the found fixed point</li></ul><p>See also: <a href="#NetworkDynamics.NWState"><code>NWState</code></a>, <a href="#NetworkDynamics.NWParameter"><code>NWParameter</code></a>, <a href="#NetworkDynamics.initialize_componentwise"><code>initialize_componentwise</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L10-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.initialize_componentwise"><a class="docstring-binding" href="#NetworkDynamics.initialize_componentwise"><code>NetworkDynamics.initialize_componentwise</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_componentwise[!](
    nw::Network;
    default_overrides=nothing,
    guess_overrides=nothing,
    bound_overrides=nothing,
    additional_initformula=nothing,
    additional_guessformula=nothing,
    additional_initconstraint=nothing,
    verbose=false,
    subverbose=false,
    tol=1e-10,
    nwtol=1e-10,
    t=NaN,
    subalg=nothing,
    subsolve_kwargs=nothing,
    parallel=false,
    vset=[VIndex(i) for i in 1:nv(nw)],
    eset=[EIndex(i) for i in 1:ne(nw)],
) :: NWState</code></pre><p>Initialize a network by solving initialization problems for each component individually, then verifying the combined solution works for the full network.</p><p>There are two versions of that function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses <code>initialize_component!</code> internally, the non-mutating one <code>initialize_component</code>. When the mutating version is used, <code>NWState(nw)</code> after initialization will return the same initialized state again, as it is stored in the metadata.</p><p><strong>Parameters</strong></p><ul><li><code>nw</code>: The network to initialize</li><li><code>default_overrides</code>: Dictionary mapping symbolic indices to values that should be used as defaults. Use <code>nothing</code> as a value for any key to remove that default.</li><li><code>guess_overrides</code>: Dictionary mapping symbolic indices to values to use as initial guesses. Use <code>nothing</code> as a value for any key to remove that guess.</li><li><code>bound_overrides</code>: Dictionary mapping symbolic indices to bounds for constrained variables. Use <code>nothing</code> as a value for any key to remove those bounds.</li><li><code>additional_initformula</code>: Dictionary mapping component indices (VIndex/EIndex) to additional initialization formulas. InitFormulas compute and set default values, reducing the number of free variables.</li><li><code>additional_guessformula</code>: Dictionary mapping component indices (VIndex/EIndex) to additional guess formulas. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.</li><li><code>additional_initconstraint</code>: Dictionary mapping component indices (VIndex/EIndex) to additional initialization constraints.</li><li><code>verbose</code>: Whether to print information about each component initialization</li><li><code>subverbose</code>: Whether to print detailed information within component initialization. Can be Vector [VIndex(1), EIndex(3), ...] for selective output</li><li><code>tol</code>: Tolerance for individual component residuals</li><li><code>nwtol</code>: Tolerance for the full network residual</li><li><code>t</code>: Time at which to evaluate the system</li><li><code>subalg</code>: Nonlinear solver algorithm to use for component initialization (defaults to NonlinearSolve.jl default). Can be passed as single value or dict mapping VIndex/EIndex to alg (non-existent keys use default).</li><li><code>subsolve_kwargs</code>: Additional keyword arguments passed to the SciML <code>solve</code> function for component initialization. Can be passed as single value or dict mapping VIndex/EIndex to kwargs (non-existent keys use empty kwargs <code>(;)</code>).</li><li><code>parallel=false</code>: (Experimental) Whether to initialize components in parallel using multithreading.</li><li><code>vset</code>: Vector of VIndex values specifying which vertices to initialize (defaults to all vertices).</li><li><code>eset</code>: Vector of EIndex values specifying which edges to initialize (defaults to all edges).</li></ul><p><strong>Returns</strong></p><ul><li><code>NWState</code>: A fully initialized network state that can be used for simulation</li></ul><p><strong>Example of two-step initialization</strong></p><pre><code class="language-julia hljs"># First solve a static model
static_model = create_static_network(...)
static_state = find_fixpoint(static_model)

# Extract interface values and use them to initialize dynamic model
interface_vals = interface_values(static_state)
dynamic_model = create_dynamic_network(...)
dyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)

# Simulate the dynamic model from this initialized state
prob = ODEProblem(dynamic_model, uflat(dyn_state), tspan, pflat(dyn_state))
sol = solve(prob)</code></pre><p>See also: <a href="#NetworkDynamics.initialize_component"><code>initialize_component</code></a>, <a href="#NetworkDynamics.interface_values"><code>interface_values</code></a>, <a href="#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L1008-L1082">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.initialize_componentwise!"><a class="docstring-binding" href="#NetworkDynamics.initialize_componentwise!"><code>NetworkDynamics.initialize_componentwise!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_componentwise[!](
    nw::Network;
    default_overrides=nothing,
    guess_overrides=nothing,
    bound_overrides=nothing,
    additional_initformula=nothing,
    additional_guessformula=nothing,
    additional_initconstraint=nothing,
    verbose=false,
    subverbose=false,
    tol=1e-10,
    nwtol=1e-10,
    t=NaN,
    subalg=nothing,
    subsolve_kwargs=nothing,
    parallel=false,
    vset=[VIndex(i) for i in 1:nv(nw)],
    eset=[EIndex(i) for i in 1:ne(nw)],
) :: NWState</code></pre><p>Initialize a network by solving initialization problems for each component individually, then verifying the combined solution works for the full network.</p><p>There are two versions of that function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses <code>initialize_component!</code> internally, the non-mutating one <code>initialize_component</code>. When the mutating version is used, <code>NWState(nw)</code> after initialization will return the same initialized state again, as it is stored in the metadata.</p><p><strong>Parameters</strong></p><ul><li><code>nw</code>: The network to initialize</li><li><code>default_overrides</code>: Dictionary mapping symbolic indices to values that should be used as defaults. Use <code>nothing</code> as a value for any key to remove that default.</li><li><code>guess_overrides</code>: Dictionary mapping symbolic indices to values to use as initial guesses. Use <code>nothing</code> as a value for any key to remove that guess.</li><li><code>bound_overrides</code>: Dictionary mapping symbolic indices to bounds for constrained variables. Use <code>nothing</code> as a value for any key to remove those bounds.</li><li><code>additional_initformula</code>: Dictionary mapping component indices (VIndex/EIndex) to additional initialization formulas. InitFormulas compute and set default values, reducing the number of free variables.</li><li><code>additional_guessformula</code>: Dictionary mapping component indices (VIndex/EIndex) to additional guess formulas. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.</li><li><code>additional_initconstraint</code>: Dictionary mapping component indices (VIndex/EIndex) to additional initialization constraints.</li><li><code>verbose</code>: Whether to print information about each component initialization</li><li><code>subverbose</code>: Whether to print detailed information within component initialization. Can be Vector [VIndex(1), EIndex(3), ...] for selective output</li><li><code>tol</code>: Tolerance for individual component residuals</li><li><code>nwtol</code>: Tolerance for the full network residual</li><li><code>t</code>: Time at which to evaluate the system</li><li><code>subalg</code>: Nonlinear solver algorithm to use for component initialization (defaults to NonlinearSolve.jl default). Can be passed as single value or dict mapping VIndex/EIndex to alg (non-existent keys use default).</li><li><code>subsolve_kwargs</code>: Additional keyword arguments passed to the SciML <code>solve</code> function for component initialization. Can be passed as single value or dict mapping VIndex/EIndex to kwargs (non-existent keys use empty kwargs <code>(;)</code>).</li><li><code>parallel=false</code>: (Experimental) Whether to initialize components in parallel using multithreading.</li><li><code>vset</code>: Vector of VIndex values specifying which vertices to initialize (defaults to all vertices).</li><li><code>eset</code>: Vector of EIndex values specifying which edges to initialize (defaults to all edges).</li></ul><p><strong>Returns</strong></p><ul><li><code>NWState</code>: A fully initialized network state that can be used for simulation</li></ul><p><strong>Example of two-step initialization</strong></p><pre><code class="language-julia hljs"># First solve a static model
static_model = create_static_network(...)
static_state = find_fixpoint(static_model)

# Extract interface values and use them to initialize dynamic model
interface_vals = interface_values(static_state)
dynamic_model = create_dynamic_network(...)
dyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)

# Simulate the dynamic model from this initialized state
prob = ODEProblem(dynamic_model, uflat(dyn_state), tspan, pflat(dyn_state))
sol = solve(prob)</code></pre><p>See also: <a href="#NetworkDynamics.initialize_component"><code>initialize_component</code></a>, <a href="#NetworkDynamics.interface_values"><code>interface_values</code></a>, <a href="#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L1006-L1080">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.initialize_component"><a class="docstring-binding" href="#NetworkDynamics.initialize_component"><code>NetworkDynamics.initialize_component</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_component(cf;
                     defaults=get_defaults_dict(cf),
                     guesses=get_guesses_dict(cf),
                     bounds=get_bounds_dict(cf),
                     default_overrides=nothing,
                     guess_overrides=nothing,
                     bound_overrides=nothing,
                     additional_initformula=nothing,
                     additional_guessformula=nothing,
                     additional_initconstraint=nothing,
                     verbose=true,
                     apply_bound_transformation=true,
                     t=NaN,
                     tol=1e-10,
                     residual=nothing,
                     alg=nothing, # defaults to FastShortcutNLLSPolyalg(linsolve=QRFactorization())
                     solve_kwargs=(;),
                     io=stdout,
                     kwargs...)</code></pre><p>The function solves a nonlinear problem to find values for all free variables/parameters (those without defaults) that satisfy the component equations in steady state (i.e. RHS equals 0). The initial guess for each variable depends on the provided <code>guesses</code> parameter (defaults to the metadata <code>guess</code> values).</p><p><strong>Parameters</strong></p><ul><li><code>cf</code>: ComponentModel to initialize</li><li><code>defaults</code>: Dictionary of default values (defaults to metadata defaults)</li><li><code>guesses</code>: Dictionary of initial guesses (defaults to metadata guesses)</li><li><code>bounds</code>: Dictionary of bounds (defaults to metadata bounds)</li><li><code>default/guess/bound_overrides</code>: Dictionary to merge with <code>defaults</code>/<code>guesses</code>/<code>bounds</code>. You can use <code>nothing</code> as a value for any key to remove that entry from the respective dictionary.</li><li><code>additional_initformula</code>: Additional initialization formulas to apply beyond those in component metadata. InitFormulas compute and set default values, reducing the number of free variables.</li><li><code>additional_guessformula</code>: Additional guess formulas to apply beyond those in component metadata. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.</li><li><code>additional_initconstraint</code>: Additional initialization constraints to apply beyond those in component metadata</li><li><code>verbose</code>: Whether to print information during initialization</li><li><code>apply_bound_transformation</code>: Whether to apply bound-conserving transformations</li><li><code>t</code>: Time at which to solve for steady state. Only relevant for components with explicit time dependency.</li><li><code>tol</code>: Tolerance for the residual of the initialized model (defaults to <code>1e-10</code>). Init throws error if resid ≥ tol.</li><li><code>residual</code>: Optional <code>Ref{Float64}</code> which gets the final residual of the initialized model.</li><li><code>alg=nothing</code>: Nonlinear solver algorithm (defaults to NonlinearSolve.jl default with QR factorization, since init problems tend to be ill-conditioned.)</li><li><code>solve_kwargs=(;)</code>: Additional keyword arguments passed to the SciML <code>solve</code> function</li><li><code>io=stdout</code>: IO stream for printing information</li></ul><p><strong>Returns</strong></p><ul><li>Dictionary mapping symbols to their values (complete state including defaults and initialized values)</li></ul><p><strong>Bounds of free variables</strong></p><p>When encountering any bounds in the free variables, NetworkDynamics will try to conserve them by applying a coordinate transformation. This behavior can be suppressed by setting <code>apply_bound_transformation=false</code>. The following transformations are used:</p><ul><li>(a, b) intervals where both a and b are positive are transformed to <code>u^2</code>/<code>sqrt(u)</code></li><li>(a, b) intervals where both a and b are negative are transformed to <code>-u^2</code>/<code>sqrt(-u)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L446-L502">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.initialize_component!"><a class="docstring-binding" href="#NetworkDynamics.initialize_component!"><code>NetworkDynamics.initialize_component!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_component!(cf::ComponentModel;
                      defaults=nothing,
                      guesses=nothing,
                      bounds=nothing,
                      default_overrides=nothing,
                      guess_overrides=nothing,
                      bound_overrides=nothing,
                      additional_initformula=nothing,
                      additional_guessformula=nothing,
                      additional_initconstraint=nothing,
                      verbose=true,
                      t=NaN,
                      kwargs...)</code></pre><p>Mutating version of <a href="#NetworkDynamics.initialize_component"><code>initialize_component</code></a>. See this docstring for all details. In contrast to the non mutating version, this function reads in defaults and guesses from the symbolic metadata and writes the initialized values back in to the metadata.</p><p><strong>Parameters</strong></p><ul><li><code>cf</code>: ComponentModel to initialize</li><li><code>defaults</code>: Optional dictionary to replace all metadata defaults</li><li><code>guesses</code>: Optional dictionary to replace all metadata guesses</li><li><code>bounds</code>: Optional dictionary to replace all metadata bounds</li><li><code>default/guess/bound_overrides</code>: Dict of values that override existing  default/guess/bound metadata. Use <code>nothing</code> as a value for any key to remove  that metadata entry from the component model.</li><li><code>additional_initformula</code>: Additional initialization formulas to apply beyond those in component metadata. InitFormulas compute and set default values, reducing the number of free variables.</li><li><code>additional_guessformula</code>: Additional guess formulas to apply beyond those in component metadata. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.</li><li><code>additional_initconstraint</code>: Additional initialization constraints to apply beyond those in component metadata</li><li><code>verbose</code>: Whether to print information during initialization</li><li><code>t</code>: Time at which to solve for steady state. Only relevant for components with explicit time dependency.</li><li>All other <code>kwargs</code> are passed to <a href="#NetworkDynamics.initialize_component"><code>initialize_component</code></a>, see its docstring for details!</li></ul><p>When <code>defaults</code>, <code>guesses</code>, or <code>bounds</code> are provided, they replace the corresponding metadata in the component model. Any keys in the original metadata that are not in the provided dictionaries will be removed, and new keys will be added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L655-L694">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.init_residual"><a class="docstring-binding" href="#NetworkDynamics.init_residual"><code>NetworkDynamics.init_residual</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init_residual(cf::ComponentModel, [state=get_defaults_or_inits_dict(cf)]; t=NaN, verbose=false)</code></pre><p>Calculates the residual |du| for the given component model using the values provided. If no state dictionary is provided, it uses the values from default/init <a href="../metadata/#Metadata">Metadata</a>.</p><p>If <code>verbose=true</code> prints the residual of every single state.</p><p>See also <a href="#NetworkDynamics.initialize_component"><code>initialize_component</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L814-L823">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.interface_values"><a class="docstring-binding" href="#NetworkDynamics.interface_values"><code>NetworkDynamics.interface_values</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interface_values(s::NWState) :: OrderedDict{SymbolicIndex, Float64}</code></pre><p>Extract all interface values (inputs and outputs) from a network state and return them as a dictionary mapping symbolic indices to their values.</p><p>This function is particularly useful in two-step initialization workflows where you want to:</p><ol><li>Solve a simplified static model first (using <a href="#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a>)</li><li>Use the resulting interface values to initialize a more complex dynamic model componentwise.</li></ol><p>In that scenario, use <code>interface_values</code> to for the <code>default_overrides</code> argument of <a href="#NetworkDynamics.initialize_componentwise"><code>initialize_componentwise</code></a>.</p><p>See also: <a href="#NetworkDynamics.initialize_componentwise"><code>initialize_componentwise</code></a>, <a href="#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a> and <a href="#NetworkDynamics.initialize_component"><code>initialize_component</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/initialization.jl#L1269-L1283">source</a></section></details></article><h3 id="Init-Constraints"><a class="docs-heading-anchor" href="#Init-Constraints">Init-Constraints</a><a id="Init-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Init-Constraints" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.InitConstraint"><a class="docstring-binding" href="#NetworkDynamics.InitConstraint"><code>NetworkDynamics.InitConstraint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct InitConstraint{F}
InitConstraint(f, sym, dim)</code></pre><p>A representation of an additional constraint that is applied during the initialization phase of a component. It contains a function <code>f</code> that defines the constraint, a vector of symbols <code>sym</code> that are involved in the constraint, and the dimension <code>dim</code> of the constraint.</p><pre><code class="language-julia hljs">InitConstraint([:x, :y], 2) do res, u
    res[1] = u[:x]^2 + u[:y]^2 - 1
end</code></pre><p>See also <a href="#NetworkDynamics.@initconstraint"><code>@initconstraint</code></a> for a macro to create such constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/init_constraints.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.@initconstraint"><a class="docstring-binding" href="#NetworkDynamics.@initconstraint"><code>NetworkDynamics.@initconstraint</code></a> — <span class="docstring-category">Macro</span></summary><section><div><p>@initconstraint</p><p>Generate an <a href="#NetworkDynamics.InitConstraint"><code>InitConstraint</code></a> from an expression using symbols.</p><pre><code class="language-julia hljs">@initconstraint begin
    :x + :y
    :z^2
end</code></pre><p>is equal to</p><pre><code class="language-julia hljs">InitConstraint([:x, :y, :z], 2) do out, u
    out[1] = u[:x] + u[:y]
    out[2] = u[:z]^2
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/init_constraints.jl#L111-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_initconstraint!"><a class="docstring-binding" href="#NetworkDynamics.set_initconstraint!"><code>NetworkDynamics.set_initconstraint!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_initconstraint!(c::ComponentModel, constraint; check=true)
set_initconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)</code></pre><p>Sets the initialization constraint(s) for the component. Overwrites any existing constraints. <code>constraint</code> can be a single <code>InitConstraint</code> or a tuple of <code>InitConstraint</code> objects.</p><p>See also: <a href="#NetworkDynamics.add_initconstraint!"><code>add_initconstraint!</code></a>, <a href="#NetworkDynamics.get_initconstraints"><code>get_initconstraints</code></a>, <a href="#NetworkDynamics.delete_initconstraints!"><code>delete_initconstraints!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L643-L651">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_initconstraints!"><a class="docstring-binding" href="#NetworkDynamics.delete_initconstraints!"><code>NetworkDynamics.delete_initconstraints!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_initconstraints!(c::ComponentModel)
delete_initconstraints!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes the initialization constraint from the component model, or from a component referenced by <code>idx</code> in a network. Returns <code>true</code> if the constraint existed and was removed, <code>false</code> otherwise.</p><p>See also: <a href="#NetworkDynamics.set_initconstraint!"><code>set_initconstraint!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L700-L709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_initconstraint"><a class="docstring-binding" href="#NetworkDynamics.has_initconstraint"><code>NetworkDynamics.has_initconstraint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_initconstraint(c::ComponentModel)
has_initconstraint(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Checks if the component has an initialization constraint in metadata.</p><p>See also: <a href="#NetworkDynamics.get_initconstraints"><code>get_initconstraints</code></a>, <a href="#NetworkDynamics.set_initconstraint!"><code>set_initconstraint!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L616-L623">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_initconstraints"><a class="docstring-binding" href="#NetworkDynamics.get_initconstraints"><code>NetworkDynamics.get_initconstraints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_initconstraints(c::ComponentModel)
get_initconstraints(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Gets all initialization constraints for the component. Returns a tuple, even if there is only a single constraint.</p><p>See also: <a href="#NetworkDynamics.has_initconstraint"><code>has_initconstraint</code></a>, <a href="#NetworkDynamics.set_initconstraint!"><code>set_initconstraint!</code></a>, <a href="#NetworkDynamics.add_initconstraint!"><code>add_initconstraint!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L628-L635">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.add_initconstraint!"><a class="docstring-binding" href="#NetworkDynamics.add_initconstraint!"><code>NetworkDynamics.add_initconstraint!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_initconstraint!(c::ComponentModel, constraint; check=true)
add_initconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)</code></pre><p>Adds an initialization constraint to the component. Does not overwrite existing constraints. <code>constraint</code> should be a single <code>InitConstraint</code> object.</p><p>See also: <a href="#NetworkDynamics.set_initconstraint!"><code>set_initconstraint!</code></a>, <a href="#NetworkDynamics.get_initconstraints"><code>get_initconstraints</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L670-L678">source</a></section></details></article><h3 id="Init-Formulas"><a class="docs-heading-anchor" href="#Init-Formulas">Init-Formulas</a><a id="Init-Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Init-Formulas" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.InitFormula"><a class="docstring-binding" href="#NetworkDynamics.InitFormula"><code>NetworkDynamics.InitFormula</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">InitFormula(f, outsym, sym)</code></pre><p>A representation of initialization formulas that are applied during the initialization phase of a component. InitFormulas act earlier in the initialization pipeline than InitConstraints - they essentially set additional defaults rather than adding equations to the nonlinear system.</p><p>It contains a function <code>f</code> that defines the formulas, a vector of output symbols <code>outsym</code> that will be set by the formulas, a vector of input symbols <code>sym</code> that are used in the formulas, and an optional pretty-print string.</p><pre><code class="language-julia hljs">InitFormula([:Vset], [:u_r, :u_i]) do out, u
    out[:Vset] = sqrt(u[:u_r]^2 + u[:u_i]^2)
end</code></pre><p>See also <a href="#NetworkDynamics.@initformula"><code>@initformula</code></a> for a macro to create such formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/init_constraints.jl#L279-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.@initformula"><a class="docstring-binding" href="#NetworkDynamics.@initformula"><code>NetworkDynamics.@initformula</code></a> — <span class="docstring-category">Macro</span></summary><section><div><p>@initformula</p><p>Generate an <a href="#NetworkDynamics.InitFormula"><code>InitFormula</code></a> from an expression using symbols.</p><pre><code class="language-julia hljs">@initformula begin
    :Vset = sqrt(:u_r^2 + :u_i^2)
    :Pset = :u_r * :i_r + :u_i * :i_i
end</code></pre><p>is equal to</p><pre><code class="language-julia hljs">InitFormula([:Vset, :Pset], [:u_r, :u_i, :i_r, :i_i]) do out, u
    out[:Vset] = sqrt(u[:u_r]^2 + u[:u_i]^2)
    out[:Pset] = u[:u_r] * u[:i_r] + u[:u_i] * u[:i_i]
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/init_constraints.jl#L386-L402">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_initformula"><a class="docstring-binding" href="#NetworkDynamics.has_initformula"><code>NetworkDynamics.has_initformula</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_initformula(c::ComponentModel)
has_initformula(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Checks if the component has initialization formulas in metadata.</p><p>See also: <a href="#NetworkDynamics.get_initformulas"><code>get_initformulas</code></a>, <a href="#NetworkDynamics.set_initformula!"><code>set_initformula!</code></a>, <a href="#NetworkDynamics.add_initformula!"><code>add_initformula!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L718-L725">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_initformulas"><a class="docstring-binding" href="#NetworkDynamics.get_initformulas"><code>NetworkDynamics.get_initformulas</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_initformulas(c::ComponentModel)
get_initformulas(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Gets all initialization formulas for the component. Returns a tuple, even if there is only a single formula.</p><p>See also: <a href="#NetworkDynamics.has_initformula"><code>has_initformula</code></a>, <a href="#NetworkDynamics.set_initformula!"><code>set_initformula!</code></a>, <a href="#NetworkDynamics.add_initformula!"><code>add_initformula!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L730-L737">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_initformula!"><a class="docstring-binding" href="#NetworkDynamics.set_initformula!"><code>NetworkDynamics.set_initformula!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_initformula!(c::ComponentModel, formula; check=true)
set_initformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)</code></pre><p>Sets the initialization formula(s) for the component. Overwrites any existing formulas. <code>formula</code> can be a single <code>InitFormula</code> or a tuple of <code>InitFormula</code> objects.</p><p>See also: <a href="#NetworkDynamics.add_initformula!"><code>add_initformula!</code></a>, <a href="#NetworkDynamics.get_initformulas"><code>get_initformulas</code></a>, <a href="#NetworkDynamics.delete_initformulas!"><code>delete_initformulas!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L745-L753">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.add_initformula!"><a class="docstring-binding" href="#NetworkDynamics.add_initformula!"><code>NetworkDynamics.add_initformula!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_initformula!(c::ComponentModel, formula; check=true)
add_initformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)</code></pre><p>Adds an initialization formula to the component. Does not overwrite existing formulas. <code>formula</code> should be a single <code>InitFormula</code> object.</p><p>See also: <a href="#NetworkDynamics.set_initformula!"><code>set_initformula!</code></a>, <a href="#NetworkDynamics.get_initformulas"><code>get_initformulas</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L772-L780">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_initformulas!"><a class="docstring-binding" href="#NetworkDynamics.delete_initformulas!"><code>NetworkDynamics.delete_initformulas!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_initformulas!(c::ComponentModel)
delete_initformulas!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes all initialization formulas from the component model, or from a component referenced by <code>idx</code> in a network. Returns <code>true</code> if formulas existed and were removed, <code>false</code> otherwise.</p><p>See also: <a href="#NetworkDynamics.set_initformula!"><code>set_initformula!</code></a>, <a href="#NetworkDynamics.add_initformula!"><code>add_initformula!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L802-L811">source</a></section></details></article><h3 id="Guess-Formulas"><a class="docs-heading-anchor" href="#Guess-Formulas">Guess-Formulas</a><a id="Guess-Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Guess-Formulas" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.GuessFormula"><a class="docstring-binding" href="#NetworkDynamics.GuessFormula"><code>NetworkDynamics.GuessFormula</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GuessFormula(f, outsym, sym)</code></pre><p>A representation of guess formulas that improve initial guesses during component initialization. GuessFormulas are applied after InitFormulas in the pipeline, reading from both defaults and guesses to compute improved guess values for free variables.</p><p>Unlike InitFormulas which set defaults (reducing free variables), GuessFormulas only update the <code>guesses</code> dictionary to improve solver convergence without changing the problem dimension.</p><p>It contains a function <code>f</code> that defines the formulas, a vector of output symbols <code>outsym</code> that will be set by the formulas, a vector of input symbols <code>sym</code> that are used in the formulas, and an optional pretty-print string.</p><p><strong>Input Lookup Behavior</strong></p><p>When evaluating a GuessFormula, input symbols are looked up with this priority:</p><ol><li>First check <code>defaults</code> dict (fixed/known values take precedence)</li><li>Then check <code>guesses</code> dict (free variable current guesses)</li><li>Error if symbol not found in either</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia hljs">GuessFormula([:V, :theta], [:u_r, :u_i]) do out, u
    out[:V] = sqrt(u[:u_r]^2 + u[:u_i]^2)
    out[:theta] = atan(u[:u_i], u[:u_r])
end</code></pre><p>See also <a href="#NetworkDynamics.@guessformula"><code>@guessformula</code></a> for a macro to create such formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/init_constraints.jl#L326-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.@guessformula"><a class="docstring-binding" href="#NetworkDynamics.@guessformula"><code>NetworkDynamics.@guessformula</code></a> — <span class="docstring-category">Macro</span></summary><section><div><p>@guessformula</p><p>Generate a <a href="#NetworkDynamics.GuessFormula"><code>GuessFormula</code></a> from an expression using symbols.</p><p>This macro provides convenient syntax for creating guess formulas using assignment expressions with quoted symbols. Each assignment computes a guess value for a free variable.</p><p><strong>Syntax</strong></p><pre><code class="language-julia hljs">@guessformula begin
    :output1 = expression_with(:input_symbols)
    :output2 = other_expression(:more_inputs)
end</code></pre><p><strong>Input Symbol Lookup</strong></p><p>Input symbols (on RHS) are looked up with this priority:</p><ol><li>First from <code>defaults</code> dict (fixed values)</li><li>Then from <code>guesses</code> dict (current guesses)</li><li>Error if not found in either</li></ol><p><strong>Output Symbol Target</strong></p><p>Output symbols (on LHS) must be:</p><ul><li>Valid component symbols (states, parameters, inputs, outputs)</li><li>NOT observables (observables are computed, not guessed)</li></ul><p>See also: <a href="#NetworkDynamics.GuessFormula"><code>GuessFormula</code></a>, <a href="#NetworkDynamics.@initformula"><code>@initformula</code></a>, <a href="#NetworkDynamics.initialize_component"><code>initialize_component</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/init_constraints.jl#L408-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_guessformula"><a class="docstring-binding" href="#NetworkDynamics.has_guessformula"><code>NetworkDynamics.has_guessformula</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_guessformula(c::ComponentModel)
has_guessformula(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Checks if the component has guess formulas in metadata.</p><p>See also: <a href="#NetworkDynamics.get_guessformulas"><code>get_guessformulas</code></a>, <a href="#NetworkDynamics.set_guessformula!"><code>set_guessformula!</code></a>, <a href="#NetworkDynamics.add_guessformula!"><code>add_guessformula!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L820-L827">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_guessformulas"><a class="docstring-binding" href="#NetworkDynamics.get_guessformulas"><code>NetworkDynamics.get_guessformulas</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_guessformulas(c::ComponentModel)
get_guessformulas(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Gets all guess formulas for the component. Returns a tuple, even if there is only a single formula.</p><p>See also: <a href="#NetworkDynamics.has_guessformula"><code>has_guessformula</code></a>, <a href="#NetworkDynamics.set_guessformula!"><code>set_guessformula!</code></a>, <a href="#NetworkDynamics.add_guessformula!"><code>add_guessformula!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L832-L839">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_guessformula!"><a class="docstring-binding" href="#NetworkDynamics.set_guessformula!"><code>NetworkDynamics.set_guessformula!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_guessformula!(c::ComponentModel, formula; check=true)
set_guessformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)</code></pre><p>Sets the guess formula(s) for the component. Overwrites any existing formulas. <code>formula</code> can be a single <code>GuessFormula</code> or a tuple of <code>GuessFormula</code> objects.</p><p>See also: <a href="#NetworkDynamics.add_guessformula!"><code>add_guessformula!</code></a>, <a href="#NetworkDynamics.get_guessformulas"><code>get_guessformulas</code></a>, <a href="#NetworkDynamics.delete_guessformulas!"><code>delete_guessformulas!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L847-L855">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.add_guessformula!"><a class="docstring-binding" href="#NetworkDynamics.add_guessformula!"><code>NetworkDynamics.add_guessformula!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_guessformula!(c::ComponentModel, formula; check=true)
add_guessformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)</code></pre><p>Adds a guess formula to the component. Does not overwrite existing formulas. <code>formula</code> should be a single <code>GuessFormula</code> object.</p><p>See also: <a href="#NetworkDynamics.set_guessformula!"><code>set_guessformula!</code></a>, <a href="#NetworkDynamics.get_guessformulas"><code>get_guessformulas</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L874-L882">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_guessformulas!"><a class="docstring-binding" href="#NetworkDynamics.delete_guessformulas!"><code>NetworkDynamics.delete_guessformulas!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_guessformulas!(c::ComponentModel)
delete_guessformulas!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes all guess formulas from the component model, or from a component referenced by <code>idx</code> in a network. Returns <code>true</code> if formulas existed and were removed, <code>false</code> otherwise.</p><p>See also: <a href="#NetworkDynamics.set_guessformula!"><code>set_guessformula!</code></a>, <a href="#NetworkDynamics.add_guessformula!"><code>add_guessformula!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L904-L913">source</a></section></details></article><h2 id="Linear-Stability-Analysis"><a class="docs-heading-anchor" href="#Linear-Stability-Analysis">Linear Stability Analysis</a><a id="Linear-Stability-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Stability-Analysis" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.isfixpoint"><a class="docstring-binding" href="#NetworkDynamics.isfixpoint"><code>NetworkDynamics.isfixpoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isfixpoint(nw::Network, s0::NWState; tol=1e-10)</code></pre><p>Check if the state <code>s0</code> is a fixpoint of the network <code>nw</code> by calculating the the RHS and check that every entry is within the given tolerance <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/linear_stability.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.jacobian_eigenvals"><a class="docstring-binding" href="#NetworkDynamics.jacobian_eigenvals"><code>NetworkDynamics.jacobian_eigenvals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobian_eigenvals(nw::Network, s0::NWState; eigvalf=LinearAlgebra.eigvals)</code></pre><p>Compute the eigenvalues of the Jacobian matrix for linear stability analysis of the network dynamics at state <code>s0</code>.</p><p>For systems without algebraic constraints (identity mass matrix), this returns the eigenvalues of the full Jacobian matrix. For constrained systems (non-identity mass matrix), it computes the eigenvalues of the reduced Jacobian following the approach for differential-algebraic equations outlined in [1]</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The network dynamics object</li><li><code>s0::NWState</code>: The state at which to compute the Jacobian eigenvalues</li><li><code>eigvalf</code>: Function to compute eigenvalues (default: <code>LinearAlgebra.eigvals</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Eigenvalues of the Jacobian (or reduced Jacobian for constrained systems)</li></ul><p><strong>Algorithm</strong></p><p>For unconstrained systems (M = I):</p><ul><li>Computes eigenvalues of the full Jacobian J</li></ul><p>For constrained systems (M ≠ I, differential-algebraic equations):</p><ul><li>The system has the form: M * dz/dt = f(z, t) where M is a diagonal mass matrix</li><li>Variables are partitioned into differential (M<em>ii = 1) and algebraic (M</em>ii = 0) components</li><li>Let z = [x; y] where x are differential and y are algebraic variables</li><li>The Jacobian J = ∂f/∂z is partitioned as:<pre><code class="nohighlight hljs">J = [f_x  f_y]  where f_x = ∂f_d/∂x, f_y = ∂f_d/∂y
    [g_x  g_y]        g_x = ∂g_a/∂x, g_y = ∂g_a/∂y</code></pre></li><li>For the algebraic constraints 0 = g<em>a(x, y), we have dy/dt = -g</em>y^(-1) * g_x * dx/dt</li><li>Substituting into the differential equations gives the reduced system: dx/dt = (f<em>x - f</em>y * g<em>y^(-1) * g</em>x) * x = A_s * x</li><li>The eigenvalues of the reduced Jacobian A_s determine stability</li><li>This approach follows the theory of differential-algebraic equations [1]</li></ul><p><strong>References</strong></p><p>[1] &quot;Power System Modelling and Scripting&quot;, F. Milano, Chapter 7.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/linear_stability.jl#L51-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.is_linear_stable"><a class="docstring-binding" href="#NetworkDynamics.is_linear_stable"><code>NetworkDynamics.is_linear_stable</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_linear_stable(nw::Network, s0::NWState; kwargs...)</code></pre><p>Check if the fixpoint <code>s0</code> of the network <code>nw</code> is linearly stable by computing the eigenvalues of the Jacobian matrix (or reduced Jacobian for constrained systems).</p><p>A fixpoint is linearly stable if all eigenvalues of the Jacobian have negative real parts. For systems with algebraic constraints (non-identity mass matrix), the reduced Jacobian is used following the approach in [1]. See <a href="#NetworkDynamics.jacobian_eigenvals"><code>jacobian_eigenvals</code></a> for more details.</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The network dynamics object</li><li><code>s0::NWState</code>: The state to check for linear stability (must be a fixpoint)</li><li><code>kwargs...</code>: Additional keyword arguments passed to <code>jacobian_eigenvals</code></li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the fixpoint is linearly stable, <code>false</code> otherwise</li></ul><p><strong>References</strong></p><p>[1] &quot;Power System Modelling and Scripting&quot;, F. Milano, Chapter 7.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/linear_stability.jl#L19-L40">source</a></section></details></article><h2 id="Callbacks-API"><a class="docs-heading-anchor" href="#Callbacks-API">Callbacks API</a><a id="Callbacks-API-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks-API" title="Permalink"></a></h2><h3 id="Define-Callbacks"><a class="docs-heading-anchor" href="#Define-Callbacks">Define Callbacks</a><a id="Define-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Callbacks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.ComponentCallback"><a class="docstring-binding" href="#NetworkDynamics.ComponentCallback"><code>NetworkDynamics.ComponentCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type ComponentCallback end</code></pre><p>Abstract type for a component based callback. A component callback bundles a <a href="#NetworkDynamics.ComponentCondition"><code>ComponentCondition</code></a> as well as a <a href="#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a> which can be then tied to a component model using <a href="#NetworkDynamics.add_callback!"><code>add_callback!</code></a> or <a href="#NetworkDynamics.set_callback!"><code>set_callback!</code></a>.</p><p>On a Network level, you can automatically create network wide <code>CallbackSet</code>s using <a href="#NetworkDynamics.get_callbacks-Tuple{Network}"><code>get_callbacks</code></a>.</p><p>See <a href="#NetworkDynamics.ContinuousComponentCallback"><code>ContinuousComponentCallback</code></a> and <a href="#NetworkDynamics.VectorContinuousComponentCallback"><code>VectorContinuousComponentCallback</code></a> for concrete implementations of this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ContinuousComponentCallback"><a class="docstring-binding" href="#NetworkDynamics.ContinuousComponentCallback"><code>NetworkDynamics.ContinuousComponentCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ContinuousComponentCallback(condition, affect; affect_neg! = affect, kwargs...)</code></pre><p>Connect a <a href="#NetworkDynamics.ComponentCondition"><code>ComponentCondition</code></a> and a <a href="#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a> to a continuous callback which can be attached to a component model using <a href="#NetworkDynamics.add_callback!"><code>add_callback!</code></a> or <a href="#NetworkDynamics.set_callback!"><code>set_callback!</code></a>.</p><p>The <code>affect_neg!</code> is also a <code>ComponentAffect</code> but will be triggered on downcrossing. It defaults to the same <code>affect</code> as on upcrossing.</p><p>The <code>kwargs</code> will be forwarded to the <code>VectorContinuousCallback</code> when the component based callbacks are collected for the whole network using <code>get_callbacks</code>. <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"><code>DiffEq.jl docs</code></a> for available options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L111-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.VectorContinuousComponentCallback"><a class="docstring-binding" href="#NetworkDynamics.VectorContinuousComponentCallback"><code>NetworkDynamics.VectorContinuousComponentCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VectorContinuousComponentCallback(condition, affect, len; affect_neg! = affect, kwargs...)</code></pre><p>Connect a <a href="#NetworkDynamics.ComponentCondition"><code>ComponentCondition</code></a> and a <a href="#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a> to a continuous callback which can be attached to a component model using <a href="#NetworkDynamics.add_callback!"><code>add_callback!</code></a> or <a href="#NetworkDynamics.set_callback!"><code>set_callback!</code></a>. This vector version allows for <code>conditions</code> which have <code>len</code> output dimensions. The <code>affect</code> will be triggered with the additional <code>event_idx</code> argument to know in which dimension the zerocrossing was detected.</p><p>The <code>affect_neg!</code> is also a <code>ComponentAffect</code> but will be triggered on downcrossing. It defaults to the same <code>affect</code> as on upcrossing.</p><p>The <code>kwargs</code> will be forwarded to the <code>VectorContinuousCallback</code> when the component based callbacks are collected for the whole network using <a href="#NetworkDynamics.get_callbacks-Tuple{Network}"><code>get_callbacks(::Network)</code></a>. <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"><code>DiffEq.jl docs</code></a> for available options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L140-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.DiscreteComponentCallback"><a class="docstring-binding" href="#NetworkDynamics.DiscreteComponentCallback"><code>NetworkDynamics.DiscreteComponentCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiscreteComponentCallback(condition, affect; kwargs...)</code></pre><p>Connect a <a href="#NetworkDynamics.ComponentCondition"><code>ComponentCondition</code></a> and a <a href="#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a> to a discrete callback which can be attached to a component model using <a href="#NetworkDynamics.add_callback!"><code>add_callback!</code></a> or <a href="#NetworkDynamics.set_callback!"><code>set_callback!</code></a>.</p><p>Note that the <code>condition</code> function returns a boolean value, as the discrete callback perform no rootfinding.</p><p>The <code>kwargs</code> will be forwarded to the <code>DiscreteCallback</code> when the component based callbacks are collected for the whole network using <a href="#NetworkDynamics.get_callbacks-Tuple{Network}"><code>get_callbacks(::Network)</code></a>. <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/"><code>DiffEq.jl docs</code></a> for available options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L173-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.PresetTimeComponentCallback"><a class="docstring-binding" href="#NetworkDynamics.PresetTimeComponentCallback"><code>NetworkDynamics.PresetTimeComponentCallback</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PresetTimeComponentCallback(ts, affect; kwargs...)</code></pre><p>Trigger a <a href="#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a> at given timesteps <code>ts</code> in discrete callback, which can be attached to a component model using <a href="#NetworkDynamics.add_callback!"><code>add_callback!</code></a> or <a href="#NetworkDynamics.set_callback!"><code>set_callback!</code></a>.</p><p>The <code>kwargs</code> will be forwarded to the <a href="https://docs.sciml.ai/DiffEqCallbacks/stable/timed_callbacks/#DiffEqCallbacks.PresetTimeCallback"><code>PresetTimeCallback</code></a> when the component based callbacks are collected for the whole network using <a href="#NetworkDynamics.get_callbacks-Tuple{Network}"><code>get_callbacks(::Network)</code></a>.</p><p>The <code>PresetTimeCallback</code> will take care of adding the timesteps to the solver, ensuring to exactly trigger at the correct times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L197-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ComponentCondition"><a class="docstring-binding" href="#NetworkDynamics.ComponentCondition"><code>NetworkDynamics.ComponentCondition</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ComponentCondition(f::Function, sym, psym)</code></pre><p>Creates a callback condition for a [<code>ComponentCallback</code>].</p><ul><li><code>f</code>: The condition function. Must be a function of the form <code>out=f(u, p, t)</code> when used for <a href="#NetworkDynamics.ContinuousComponentCallback"><code>ContinuousComponentCallback</code></a> or <a href="#NetworkDynamics.DiscreteComponentCallback"><code>DiscreteComponentCallback</code></a> and <code>f!(out, u, p, t)</code> when used for <a href="#NetworkDynamics.VectorContinuousComponentCallback"><code>VectorContinuousComponentCallback</code></a>.<ul><li>Arguments of <code>f</code><ul><li><code>u</code>: The current value of the selected <code>sym</code> states, provided as a <a href="#NetworkDynamics.SymbolicView"><code>SymbolicView</code></a> object.</li><li><code>p</code>: The current value of the selected <code>psym</code> parameters.</li><li><code>t</code>: The current simulation time.</li></ul></li></ul></li><li><code>sym</code>: A vector or tuple of symbols, which represent <strong>states</strong> (including inputs, outputs, observed) of the component model. Determines, which states will be available through parameter <code>u</code> in the callback condition function <code>f</code>.</li><li><code>psym</code>: A vector or tuple of symbols, which represent <strong>parameters</strong> of the component mode. Determines, which parameters will be available in the condition function <code>f</code></li></ul><p><strong>Example</strong></p><p>Consider a component model with states <code>[:u1, :u2]</code>, inputs <code>[:i]</code>, outputs <code>[:o]</code> and parameters <code>[:p1, :p2]</code>.</p><pre><code class="language-julia hljs">ComponentCondition([:u1, :o], [:p1]) do u, p, t
    # access states symbolically or via int index
    u[:u1] == u[1]
    u[:o] == u[2]
    p[:p1] == p[1]
    # the states/prameters `:u2`, `:i` and `:p2` are not available as
    # they are not listed in the `sym` and `psym` arguments.
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L18-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ComponentAffect"><a class="docstring-binding" href="#NetworkDynamics.ComponentAffect"><code>NetworkDynamics.ComponentAffect</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ComponentAffect(f::Function, sym, psym)</code></pre><p>Creates a callback condition for a [<code>ComponentCallback</code>].</p><ul><li><code>f</code>: The affect function. Must be a function of the form <code>f(u, p, [event_idx], ctx)</code> where <code>event_idx</code> is only available in <a href="#NetworkDynamics.VectorContinuousComponentCallback"><code>VectorContinuousComponentCallback</code></a>.<ul><li>Arguments of <code>f</code><ul><li><code>u</code>: The current (mutable) value of the selected <code>sym</code> states, provided as a <a href="#NetworkDynamics.SymbolicView"><code>SymbolicView</code></a> object.</li><li><code>p</code>: The current (mutable) value of the selected <code>psym</code> parameters.</li><li><code>event_idx</code>: The current event index, i.e. which <code>out</code> element triggered in case of <a href="#NetworkDynamics.VectorContinuousComponentCallback"><code>VectorContinuousComponentCallback</code></a>.</li><li><code>ctx::NamedTuple</code> a named tuple with context variables.<ul><li><code>ctx.model</code>: a reference to the component model</li><li><code>ctx.vidx</code>/<code>ctx.eidx</code>: The index of the vertex/edge model.</li><li><code>ctx.src</code>/<code>ctx.dst</code>: src and dst indices (only for edge models).</li><li><code>ctx.integrator</code>: The integrator object. Use <a href="#NetworkDynamics.extract_nw"><code>extract_nw</code></a> to obtain the network.</li><li><code>ctx.t=ctx.integrator.t</code>: The current simulation time.</li></ul></li></ul></li></ul></li><li><code>sym</code>: A vector or tuple of symbols, which represent <strong>states</strong> (<strong>excluding</strong> inputs, outputs, observed) of the component model. Determines, which states will be available through parameter <code>u</code> in the callback condition function <code>f</code>.</li><li><code>psym</code>: A vector or tuple of symbols, which represent <strong>parameters</strong> of the component mode. Determines, which parameters will be available in the condition function <code>f</code></li></ul><p><strong>Example</strong></p><p>Consider a component model with states <code>[:u1, :u2]</code>, inputs <code>[:i]</code>, outputs <code>[:o]</code> and parameters <code>[:p1, :p2]</code>.</p><pre><code class="language-julia hljs">ComponentAffect([:u1, :o], [:p1]) do u, p, ctx
    u[:u1] = 0 # change the state
    p[:p1] = 1 # change the parameter
    @info &quot;Changed :u1 and :p1 on vertex $(ctx.vidx)&quot; # access context
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L64-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.SymbolicView"><a class="docstring-binding" href="#NetworkDynamics.SymbolicView"><code>NetworkDynamics.SymbolicView</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SymbolicView{N,VT} &lt;: AbstractVetor{VT}</code></pre><p>Is a (smallish) fixed size vector type with named dimensions. Its main purpose is to allow named acces to variables in <a href="#NetworkDynamics.ComponentCondition"><code>ComponentCondition</code></a> and <a href="#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a> functions.</p><p>I.e. when the <code>ComponentAffect</code> declared <code>sym=[:x, :y]</code>, you can acces <code>u[:x]</code> and <code>u[:y]</code> inside the condition function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/utils.jl#L182-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_callbacks-Tuple{Network}"><a class="docstring-binding" href="#NetworkDynamics.get_callbacks-Tuple{Network}"><code>NetworkDynamics.get_callbacks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_callbacks(nw::Network, additional_callbacks=Dict())::CallbackSet</code></pre><p>Returns a <code>CallbackSet</code> composed of all the &quot;component-based&quot; callbacks in the metadata of the Network components.</p><p>You can inject additional callbacks at that stage by passing</p><pre><code class="language-julia hljs">get_callbacks(nw, VIndex(7) =&gt; cb)
get_callbacks(nw, Dict(VIndex(1)=&gt;cb1, EIndex(2)=&gt;cb2))</code></pre><p>which won&#39;t be stored in the metadata of the component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/callbacks.jl#L228-L240">source</a></section></details></article><h3 id="Attach-Callbacks-to-Edge/VertexModels"><a class="docs-heading-anchor" href="#Attach-Callbacks-to-Edge/VertexModels">Attach Callbacks to Edge/VertexModels</a><a id="Attach-Callbacks-to-Edge/VertexModels-1"></a><a class="docs-heading-anchor-permalink" href="#Attach-Callbacks-to-Edge/VertexModels" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="NetworkDynamics.has_callback"><a class="docstring-binding" href="#NetworkDynamics.has_callback"><code>NetworkDynamics.has_callback</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_callback(c::ComponentModel)
has_callback(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Checks if the component has a callback function in metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L542-L547">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_callbacks-Tuple{NetworkDynamics.ComponentModel}"><a class="docstring-binding" href="#NetworkDynamics.get_callbacks-Tuple{NetworkDynamics.ComponentModel}"><code>NetworkDynamics.get_callbacks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_callbacks(c::ComponentModel)
get_callbacks(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Gets all callback functions for the component. Wraps in tuple, even if there is only a single one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L552-L557">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_callback!"><a class="docstring-binding" href="#NetworkDynamics.set_callback!"><code>NetworkDynamics.set_callback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_callback!(c::ComponentModel, cb; check=true)
set_callback!(nw::Network, idx::Union{VIndex,EIndex}, cb; check=true)</code></pre><p>Sets the callback function for the component. Overwrites any existing callback. See also <a href="#NetworkDynamics.add_callback!"><code>add_callback!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L565-L571">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.add_callback!"><a class="docstring-binding" href="#NetworkDynamics.add_callback!"><code>NetworkDynamics.add_callback!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_callback!(c::ComponentModel, cb; check=true)
add_callback!(nw::Network, idx::Union{VIndex,EIndex}, cb; check=true)</code></pre><p>Adds a callback function to the component. Does not overwrite existing callbacks. See also <a href="#NetworkDynamics.set_callback!"><code>set_callback!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L582-L588">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.delete_callbacks!"><a class="docstring-binding" href="#NetworkDynamics.delete_callbacks!"><code>NetworkDynamics.delete_callbacks!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_callbacks!(c::ComponentModel)
delete_callbacks!(nw::Network, idx::Union{VIndex,EIndex})</code></pre><p>Removes all callback functions from the component model, or from a component referenced by <code>idx</code> in a network. Returns <code>true</code> if callbacks existed and were removed, <code>false</code> otherwise.</p><p>See also: <a href="#NetworkDynamics.set_callback!"><code>set_callback!</code></a>, <a href="#NetworkDynamics.add_callback!"><code>add_callback!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/metadata.jl#L598-L607">source</a></section></details></article><h2 id="Sparsity-Detection"><a class="docs-heading-anchor" href="#Sparsity-Detection">Sparsity Detection</a><a id="Sparsity-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-Detection" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.get_jac_prototype"><a class="docstring-binding" href="#NetworkDynamics.get_jac_prototype"><code>NetworkDynamics.get_jac_prototype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_jac_prototype(nw::Network; dense=false, remove_conditions=false)</code></pre><p>Compute the sparsity pattern of the Jacobian matrix for a NetworkDynamics network.</p><p>This function uses <code>SparseConnectivityTracer.jl</code> to detect the sparsity pattern of the Jacobian  matrix of the network&#39;s dynamics function. The resulting sparsity pattern can be used to  improve the performance of ODE solvers by providing structural information about the system. The <code>dense</code> option is useful when certain components have complex sparsity patterns that are difficult to detect automatically. The <code>remove_conditions</code> option helps when conditional statements in component functions interfere with sparsity detection.</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The NetworkDynamics network for which to compute the Jacobian prototype</li><li><code>dense=false</code>: Controls which components should be treated as dense during sparsity detection:<ul><li><code>false</code>: Use actual component functions (default)</li><li><code>true</code>: Replace all components with dense equivalents</li><li><code>Vector{Union{VIndex, EIndex}}</code>: Replace only the specified vertex/edge components with dense equivalents</li></ul></li><li><code>remove_conditions=false</code>: Controls removal of conditional statements from component functions: this is only applicable to components defined via MTK. It essentially scans the function expression for if/else statements, deleting the condition and replacing the block by <code>truepath + falsepath</code>, which can help with sparsity detection.<ul><li><code>false</code>: Keep conditional statements as-is (default)</li><li><code>true</code>: Remove conditionals from all components by converting <code>if-else</code> to additive form</li><li><code>Vector{Union{VIndex, EIndex}}</code>: Remove conditionals only from specified vertex/edge components</li></ul></li><li><code>check=true</code>: If <code>true</code>, the function checks the sparsity pattern against a forward-differentiated Jacobian as a sanity check.</li></ul><p><strong>Returns</strong></p><ul><li>A sparse matrix representing the sparsity pattern of the Jacobian matrix</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">nw = Network(...)
jac_prototype = get_jac_prototype(nw) # get the sparsity pattern

# manually set define ODEFunction
f_ode = ODEFunction(nw; jac_prototype=jac_prototype)
prob = ODEProblem(f_ode, x0, (0.0, 1.0), p0)
sol = solve(prob, Rodas5P())

# ALTERNATIVE: use set_jac_prototype!
set_jac_prototype!(nw; jac_prototype) # attach pattern to network
prob = ODEProblem(nw, x0, (0.0, 1.0), p0) # uses jac prototype from network
sol = solve(prob, Rodas5P())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/ext/NetworkDynamicsSparsityExt.jl#L16-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.set_jac_prototype!"><a class="docstring-binding" href="#NetworkDynamics.set_jac_prototype!"><code>NetworkDynamics.set_jac_prototype!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_jac_prototype!(nw::Network, jac::SparseMatrixCSC{Bool,Int})</code></pre><p>Set the Jacobian prototype for a NetworkDynamics network.</p><p>This function stores a pre-computed Jacobian sparsity pattern in the network object, which can be used by ODE solvers to improve performance during integration.</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The NetworkDynamics network to modify</li><li><code>jac::SparseMatrixCSC{Bool,Int}</code>: A sparse matrix representing the Jacobian sparsity pattern</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/network_structure.jl#L308-L319">source</a></section><section><div><pre><code class="language-julia hljs">set_jac_prototype!(nw::Network; kwargs...)</code></pre><p>Compute and set the Jacobian prototype for a NetworkDynamics network.</p><p>This is a convenience function that automatically computes the Jacobian sparsity pattern using <code>get_jac_prototype</code> and stores it in the network object. Needs <code>SparseConnectivityTracer</code> to be loaded!</p><p><strong>Arguments</strong></p><ul><li><code>nw::Network</code>: The NetworkDynamics network to modify</li><li><code>kwargs...</code>: Keyword arguments passed to <code>get_jac_prototype</code> (e.g., <code>dense</code>, <code>remove_conditions</code>)</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">nw = Network(...)
set_jac_prototype!(nw) # computs sparsity pattern and stores in network
prob = ODEProblem(nw, x0, (0.0, 1.0), p0)
sol = solve(prob, Rodas5P())</code></pre><p>See also: <a href="#NetworkDynamics.get_jac_prototype"><code>get_jac_prototype</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/network_structure.jl#L325-L347">source</a></section></details></article><h2 id="Execution-Types"><a class="docs-heading-anchor" href="#Execution-Types">Execution Types</a><a id="Execution-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Execution-Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.ExecutionStyle"><a class="docstring-binding" href="#NetworkDynamics.ExecutionStyle"><code>NetworkDynamics.ExecutionStyle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type ExecutionStyle{buffered::Bool} end</code></pre><p>Abstract type for execution style. The coreloop dispatches based on the Execution style stored in the network object.</p><ul><li><code>buffered=true</code> means that the edge input es explicitly gathered, i.e. the vertex outputs in the output buffer will be copied into a dedicated input buffer for the edges.</li><li><code>buffered=false</code> means, that the edge inputs are not explicitly gathered, but the corloop will perform a redirected lookup into the output buffer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/executionstyles.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.SequentialExecution"><a class="docstring-binding" href="#NetworkDynamics.SequentialExecution"><code>NetworkDynamics.SequentialExecution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SequentialExecution{buffered::Bool}</code></pre><p>Sequential execution, no parallelism. For <code>buffered</code> see <a href="#NetworkDynamics.ExecutionStyle"><code>ExecutionStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/executionstyles.jl#L15-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.PolyesterExecution"><a class="docstring-binding" href="#NetworkDynamics.PolyesterExecution"><code>NetworkDynamics.PolyesterExecution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PolyesterExecution{buffered}</code></pre><p>Parallel execution using <a href="https://github.com/JuliaSIMD/Polyester.jl"><code>Polyester.jl</code></a>. For <code>buffered</code> see <a href="#NetworkDynamics.ExecutionStyle"><code>ExecutionStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/executionstyles.jl#L30-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ThreadedExecution"><a class="docstring-binding" href="#NetworkDynamics.ThreadedExecution"><code>NetworkDynamics.ThreadedExecution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ThreadedExecution{buffered}</code></pre><p>Parallel execution using Julia threads. For <code>buffered</code> see <a href="#NetworkDynamics.ExecutionStyle"><code>ExecutionStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/executionstyles.jl#L38-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.KAExecution"><a class="docstring-binding" href="#NetworkDynamics.KAExecution"><code>NetworkDynamics.KAExecution</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct KAExecution{buffered}</code></pre><p>Parallel execution using <a href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions.jl</code></a>. Works with GPU and CPU arrays. For <code>buffered</code> see <a href="#NetworkDynamics.ExecutionStyle"><code>ExecutionStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/executionstyles.jl#L22-L27">source</a></section></details></article><h2 id="Aggregators"><a class="docs-heading-anchor" href="#Aggregators">Aggregators</a><a id="Aggregators-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregators" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamics.Aggregator"><a class="docstring-binding" href="#NetworkDynamics.Aggregator"><code>NetworkDynamics.Aggregator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Aggregator end</code></pre><p>Abstract sypertype for aggregators. Aggregators operate on the output buffer of all components and fill the aggregation buffer with the aggregatated edge values per vertex.</p><p>All aggregators have the constructor</p><pre><code class="language-julia hljs">Aggegator(aggfun)</code></pre><p>for example</p><pre><code class="language-julia hljs">SequentialAggreator(+)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/aggregators.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.SequentialAggregator"><a class="docstring-binding" href="#NetworkDynamics.SequentialAggregator"><code>NetworkDynamics.SequentialAggregator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SequentialAggregator(aggfun)</code></pre><p>Sequential aggregation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/aggregators.jl#L130-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.SparseAggregator"><a class="docstring-binding" href="#NetworkDynamics.SparseAggregator"><code>NetworkDynamics.SparseAggregator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SparseAggregator(+)</code></pre><p>Only works with additive aggregation <code>+</code>. Aggregates via sparse inplace matrix multiplication. Works with GPU Arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/aggregators.jl#L243-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ThreadedAggregator"><a class="docstring-binding" href="#NetworkDynamics.ThreadedAggregator"><code>NetworkDynamics.ThreadedAggregator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ThreadedAggregator(aggfun)</code></pre><p>Parallel aggregation using Julia threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/aggregators.jl#L185-L189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.PolyesterAggregator"><a class="docstring-binding" href="#NetworkDynamics.PolyesterAggregator"><code>NetworkDynamics.PolyesterAggregator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolyesterAggregator(aggfun)</code></pre><p>Parallel aggregation using <a href="https://github.com/JuliaSIMD/Polyester.jl"><code>Polyester.jl</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/aggregators.jl#L158-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.KAAggregator"><a class="docstring-binding" href="#NetworkDynamics.KAAggregator"><code>NetworkDynamics.KAAggregator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KAAggregator(aggfun)</code></pre><p>Parallel aggregation using <a href="https://github.com/JuliaGPU/KernelAbstractions.jl"><code>KernelAbstractions.jl</code></a>. Works with both GPU and CPU arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/aggregators.jl#L89-L94">source</a></section></details></article><h2 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SciMLBase.ODEProblem-Tuple{Network, NWState, Any}"><a class="docstring-binding" href="#SciMLBase.ODEProblem-Tuple{Network, NWState, Any}"><code>SciMLBase.ODEProblem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SciMLBase.ODEProblem(nw::Network, args...;
    add_comp_cb=Dict(),
    add_nw_cb=nothing,
    override_cb=nothing,
    kwargs...
)</code></pre><p>Custom cosntructor for creating ODEProblem base of a <code>Network</code>-Object. Its main purpose is to automaticially handle callback construction from the component level callbacks.</p><p><strong>Callback Keywords</strong></p><p>The callback system supports three keyword arguments that control how callbacks are managed:</p><ul><li><p><strong><code>add_comp_cb</code></strong>: Additional component callbacks: A <code>Dict</code> mapping component indices (e.g., <code>VIndex(1)</code> or <code>EIndex(2)</code>) to component callbacks. These are forwarded to <a href="#NetworkDynamics.get_callbacks-Tuple{Network}"><code>get_callbacks</code></a> and combined with callbacks stored in the network&#39;s component metadata. Use this to inject temporary component callbacks without modifying the network structure.</p></li><li><p><strong><code>add_nw_cb</code></strong>: Additional network/system callbacks: A network-level callback or <code>CallbackSet</code> (e.g., <code>PeriodicCallback</code>, <code>PresetTimeCallback</code>) that is combined with the network&#39;s component callbacks. Use this for callbacks that don&#39;t fit the component-based pattern, such as periodic saving or global termination conditions.</p></li><li><p><strong><code>override_cb</code></strong>: A callback or <code>CallbackSet</code> that completely replaces all network callbacks. When set, both <code>add_comp_cb</code> and <code>add_nw_cb</code> must be empty/nothing (enforced by ArgumentError). Use this for complete control over the callback system.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/post_utils.jl#L23-L35">source</a></section><section><div><pre><code class="language-julia hljs">SciMLBase.ODEProblem(nw::Network, s0::NWState, tspan; kwargs...)
SciMLBase.ODEProblem(nw::Network, s0::NWState, tspan, p0::NWParameter; kwargs...)</code></pre><p>This is a simple wrapper which:</p><ul><li>extracts the flat state and parameter vectors from <code>s0</code> (and <code>p0</code> if provided)</li><li>makes a copy of the parameter vector to avoid side effects due to callbacks</li><li>constructs the callbacks from the network and combines them with any additional callbacks</li></ul><p><strong>Callback Keywords</strong></p><p>The callback system supports three keyword arguments that control how callbacks are managed:</p><ul><li><p><strong><code>add_comp_cb</code></strong>: Additional component callbacks: A <code>Dict</code> mapping component indices (e.g., <code>VIndex(1)</code> or <code>EIndex(2)</code>) to component callbacks. These are forwarded to <a href="#NetworkDynamics.get_callbacks-Tuple{Network}"><code>get_callbacks</code></a> and combined with callbacks stored in the network&#39;s component metadata. Use this to inject temporary component callbacks without modifying the network structure.</p></li><li><p><strong><code>add_nw_cb</code></strong>: Additional network/system callbacks: A network-level callback or <code>CallbackSet</code> (e.g., <code>PeriodicCallback</code>, <code>PresetTimeCallback</code>) that is combined with the network&#39;s component callbacks. Use this for callbacks that don&#39;t fit the component-based pattern, such as periodic saving or global termination conditions.</p></li><li><p><strong><code>override_cb</code></strong>: A callback or <code>CallbackSet</code> that completely replaces all network callbacks. When set, both <code>add_comp_cb</code> and <code>add_nw_cb</code> must be empty/nothing (enforced by ArgumentError). Use this for complete control over the callback system.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/post_utils.jl#L76-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.save_parameters!"><a class="docstring-binding" href="#NetworkDynamics.save_parameters!"><code>NetworkDynamics.save_parameters!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">save_parameters!(integrator::SciMLBase.DEIntegrator)</code></pre><p>Save the current parameter values in the integrator. Call this function inside callbacks if the parameter values have changed. This will store a timeseries of said parameters in the solution object, thus alowing us to recosntruct observables which depend on time-dependet variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing_base.jl#L539-L545">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.ff_to_constraint"><a class="docstring-binding" href="#NetworkDynamics.ff_to_constraint"><code>NetworkDynamics.ff_to_constraint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ff_to_constraint(v::VertexModel)</code></pre><p>Takes <code>VertexModel</code> <code>v</code> with feed forward and turns all algebraic output states into internal states by defining algebraic constraints contraints <code>0 = out - g(...)</code>. The new output function is just a <a href="#NetworkDynamics.StateMask"><code>StateMask</code></a> into the extended internal state vector.</p><p>Returns the transformed <code>VertexModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L1139-L1148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Tuple{NetworkDynamics.ComponentModel}"><a class="docstring-binding" href="#Base.copy-Tuple{NetworkDynamics.ComponentModel}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">copy(c::NetworkDynamics.ComponentModel)</code></pre><p>Shallow copy of the component model. Creates a deepcopy of <code>metadata</code> and <code>symmetadata</code> but references the same objects everywhere else.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/component_functions.jl#L1096-L1101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.extract_nw"><a class="docstring-binding" href="#NetworkDynamics.extract_nw"><code>NetworkDynamics.extract_nw</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract_nw(thing)</code></pre><p>Try to extract the <code>Network</code> object from thing.</p><p>Thing can by many things, e.g. <code>ODEProblem</code>, <code>ODESolution</code>, <code>Integrator</code>, <code>NWState</code>, <code>NWParameter</code>, ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/symbolicindexing.jl#L944-L950">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.implicit_output"><a class="docstring-binding" href="#NetworkDynamics.implicit_output"><code>NetworkDynamics.implicit_output</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">implicit_output(x) = 0
ModelingToolkit.@register_symbolic implicit_output(x)</code></pre><p>This is a helper function to define MTK models with <strong>fully implicit outputs</strong>. It is sort of a barrier for <code>Symbolics</code> to not descent in to the equation. When added to an equation, it does nothing (defined as 0), but it tricks MTK/Symbolics into believing the equation depends on <code>x</code>. This can be necessary to define a model with fully implicit outputs.</p><pre><code class="language-julia hljs">@mtkmodel ImplicitForcing begin
    @variables begin
        u(t), [description = &quot;Input Variable&quot;, input=true]
        y(t), [description = &quot;fully implicit output&quot;, output=true]
    end
    @equations begin
        # 0 ~ u  # WRONG!
        0 ~ u + implicit_output(y) # CORRECT!
    end
end
VertexModel(ImplicitForcing(name=:implicit), [:u], [:y])</code></pre><p>For more information see the NetworkDynamics docs on <a href="../mtk_integration/#Fully-Implicit-Outputs">fully implicit outputs</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/utils.jl#L247-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamics.pretty_f"><a class="docstring-binding" href="#NetworkDynamics.pretty_f"><code>NetworkDynamics.pretty_f</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">NetworkDynamics.pretty_f(v::VertexModel)</code></pre><p>For debugging vertex models based off MTK, this function pretty prints the underlying generated function <code>f(du, u, in, p, t)</code> in a more readable way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/src/utils.jl#L258-L263">source</a></section></details></article><h2 id="NetworkDynamicsInspector-API"><a class="docs-heading-anchor" href="#NetworkDynamicsInspector-API">NetworkDynamicsInspector API</a><a id="NetworkDynamicsInspector-API-1"></a><a class="docs-heading-anchor-permalink" href="#NetworkDynamicsInspector-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NetworkDynamicsInspector.inspect"><a class="docstring-binding" href="#NetworkDynamicsInspector.inspect"><code>NetworkDynamicsInspector.inspect</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inspect(sol; restart=false, reset=false, display=nothing)</code></pre><p>Main entry point for gui. Starts the server and serves the app for solution <code>sol</code>.</p><ul><li><code>restart</code>: If <code>true</code>, the display will be restartet (i.e. new Electron window, new server or new Browser tab)</li><li><code>reset</code>: If <code>true</code>, reset the appstate with the new solution <code>sol</code>.</li><li><code>display=CURRENT_DISPLAY[]</code>: Can be <code>BrowserDisp()</code>, <code>ServerDisp()</code> or <code>ElectronDisp()</code>.  Per default, the current display will be used (defaults to<code>BrowserDisp()</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/NetworkDynamicsInspector/src/NetworkDynamicsInspector.jl#L122-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamicsInspector.dump_app_state"><a class="docstring-binding" href="#NetworkDynamicsInspector.dump_app_state"><code>NetworkDynamicsInspector.dump_app_state</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dump_app_state()</code></pre><p>Generate a list of <a href="#NetworkDynamicsInspector.set_sol!"><code>set_sol!</code></a>, <a href="#NetworkDynamicsInspector.set_state!"><code>set_state!</code></a>, <a href="#NetworkDynamicsInspector.set_graphplot!"><code>set_graphplot!</code></a> and <a href="#NetworkDynamicsInspector.define_timeseries!"><code>define_timeseries!</code></a> commands to recreate the current appstate. The intended usecase is to quickly recreate &quot;starting points&quot; for interactive exploration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/NetworkDynamicsInspector/src/appstate.jl#L202-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamicsInspector.set_sol!"><a class="docstring-binding" href="#NetworkDynamicsInspector.set_sol!"><code>NetworkDynamicsInspector.set_sol!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_sol!(sol)</code></pre><p>Set the solution of the current appstate to <code>sol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/NetworkDynamicsInspector/src/appstate.jl#L93-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamicsInspector.set_state!"><a class="docstring-binding" href="#NetworkDynamicsInspector.set_state!"><code>NetworkDynamicsInspector.set_state!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_state!(; sol, t, tmin, tmax)</code></pre><p>Set the solution, current time and time limits of the current appstate.</p><p>To automaticially create commands see <a href="#NetworkDynamicsInspector.dump_app_state"><code>dump_app_state()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/NetworkDynamicsInspector/src/appstate.jl#L109-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamicsInspector.set_graphplot!"><a class="docstring-binding" href="#NetworkDynamicsInspector.set_graphplot!"><code>NetworkDynamicsInspector.set_graphplot!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_graphplot!(; nstate, estate, nstate_rel, estate_rel, ncolorrange, ecolorrange)</code></pre><p>Set the properties of the graphplot of the current appstate.</p><p>To automaticially create commands see <a href="#NetworkDynamicsInspector.dump_app_state"><code>dump_app_state()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/NetworkDynamicsInspector/src/appstate.jl#L129-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamicsInspector.set_timeseries!"><a class="docstring-binding" href="#NetworkDynamicsInspector.set_timeseries!"><code>NetworkDynamicsInspector.set_timeseries!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_timeseries!(key; selcomp, states, rel)</code></pre><p>Set properties of the timeseries plot with key <code>key</code>. See also <a href="#NetworkDynamicsInspector.define_timeseries!"><code>define_timeseries!</code></a>.</p><p>To automaticially create commands see <a href="#NetworkDynamicsInspector.dump_app_state"><code>dump_app_state()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/NetworkDynamicsInspector/src/appstate.jl#L156-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NetworkDynamicsInspector.define_timeseries!"><a class="docstring-binding" href="#NetworkDynamicsInspector.define_timeseries!"><code>NetworkDynamicsInspector.define_timeseries!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">define_timeseries!(tsarray)</code></pre><p>Defines timeseries, where <code>tsarray</code> is an array of timeseries keyword arguments (see <a href="#NetworkDynamicsInspector.set_timeseries!"><code>set_timeseries!</code></a>).</p><p>To automaticially create commands see <a href="#NetworkDynamicsInspector.dump_app_state"><code>dump_app_state()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/446c2921b85d4fda22c0d936d02e80006f1a7cf8/NetworkDynamicsInspector/src/appstate.jl#L178-L185">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../inspector/">« Interactive Solution Inspection</a><a class="docs-footer-nextpage" href="../generated/getting_started_with_network_dynamics/">Getting Started »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 27 November 2025 15:32">Thursday 27 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
