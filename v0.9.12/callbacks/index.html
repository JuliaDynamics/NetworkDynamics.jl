<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Callbacks and Events · NetworkDynamics</title><meta name="title" content="Callbacks and Events · NetworkDynamics"/><meta property="og:title" content="Callbacks and Events · NetworkDynamics"/><meta property="twitter:title" content="Callbacks and Events · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><a class="tocitem" href="../mathematical_model/">Mathematical Model</a></li><li><a class="tocitem" href="../network_construction/">Network Construction</a></li><li><span class="tocitem">Features</span><ul><li><a class="tocitem" href="../symbolic_indexing/">Symbolic Indexing</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li class="is-active"><a class="tocitem" href>Callbacks and Events</a><ul class="internal"><li><a class="tocitem" href="#Component-based-Callback-functions"><span>Component-based Callback functions</span></a></li><li><a class="tocitem" href="#Normal-DiffEq-Callbacks"><span>Normal DiffEq Callbacks</span></a></li></ul></li><li><a class="tocitem" href="../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../external_inputs/">External Inputs</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../generated/directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li><li><a class="tocitem" href="../generated/heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../generated/cascading_failure/">Cascading Failure</a></li><li><a class="tocitem" href="../generated/stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../generated/gas_network/">Gas Network</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Features</a></li><li class="is-active"><a href>Callbacks and Events</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Callbacks and Events</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/src/callbacks.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Callbacks"><a class="docs-heading-anchor" href="#Callbacks">Callbacks and Events</a><a id="Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Callbacks" title="Permalink"></a></h1><p>Callback-functions are a way of handling discontinuities in differential equations. In a nutshell, the solver checks for some &quot;condition&quot; (i.e. a zero crossing of some variable) and calls some &quot;affect&quot; if the condition is fulfilled. Within the affect function, it is safe to modify the integrator, e.g. changing some state or some parameter.</p><p>Since <code>NetworkDynamics.jl</code> provides nothing more than a RHS for DifferentialEquations.jl, please check <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/">their docs on event handling</a> as a general reference. This page at introducing the general concepts, for a hands on example of a simulation with callbacks refer to the <a href="../generated/cascading_failure/#Cascading-Failure">Cascading Failure</a> example.</p><h2 id="Component-based-Callback-functions"><a class="docs-heading-anchor" href="#Component-based-Callback-functions">Component-based Callback functions</a><a id="Component-based-Callback-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Component-based-Callback-functions" title="Permalink"></a></h2><p>In practice, events often act locally, meaning they only depend and act on a specific component or type of component. <code>NetworkDynamics.jl</code> provides a way of defining those callbacks on a component level and automaticially combine them into performant <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/#SciMLBase.VectorContinuousCallback"><code>VectorContinuousCallback</code></a> and <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/#SciMLBase.DiscreteCallback"><code>DiscreteCallback</code></a> for the whole network.</p><p>The main entry points are the types <a href="../API/#NetworkDynamics.ContinousComponentCallback"><code>ContinousComponentCallback</code></a>, <a href="../API/#NetworkDynamics.VectorContinousComponentCallback"><code>VectorContinousComponentCallback</code></a> and <a href="../API/#NetworkDynamics.DiscreteComponentCallback"><code>DiscreteComponentCallback</code></a>. All of those objects combine a <a href="../API/#NetworkDynamics.ComponentCondition"><code>ComponentCondition</code></a> with an <a href="../API/#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a>.</p><p>The &quot;normal&quot; <a href="../API/#NetworkDynamics.ContinousComponentCallback"><code>ContinousComponentCallback</code></a> and <a href="../API/#NetworkDynamics.DiscreteComponentCallback"><code>DiscreteComponentCallback</code></a> have a condition which returns a single value. The corresponding affect is triggered when the return value hits zero. In contrast, the &quot;vector&quot; version has an in-place condition which writes <code>len</code> outputs. When any of those outputs hits zero, the affect is triggered with an additional argument <code>event_idx</code> which tells the effect which dimension encountered the zerocrossing.</p><p>There is a special type <a href="../API/#NetworkDynamics.PresetTimeComponentCallback"><code>PresetTimeComponentCallback</code></a> which has no explicit condition and triggers the affect at given times. This internally generates a <a href="https://docs.sciml.ai/DiffEqCallbacks/stable/timed_callbacks/#DiffEqCallbacks.PresetTimeCallback"><code>PresetTimeCallback</code></a> object from <code>DiffEqCallbacks.jl</code>.</p><h3 id="Defining-the-Callback"><a class="docs-heading-anchor" href="#Defining-the-Callback">Defining the Callback</a><a id="Defining-the-Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Callback" title="Permalink"></a></h3><p>To construct a condition function, you need to tell network dynamics which states and parameters you&#39;d like to &quot;observe&quot; within the condition. Within the actual condition, those states will be made available:</p><pre><code class="language-julia hljs">condition = ComponentCond([:x, :y], [:p1, :p2]) do u, p, t
    u[:x]  == u[1] # access a state or observable :x at current time
    p[:p2] == p[2] # access a parameter at current time
    return some_condition(u[:x], u[:y], ...)
end</code></pre><p>In case of a <code>VectorContinousComponentCallback</code>, the function signature looks slightly different:</p><pre><code class="language-julia hljs">vectorcondition = ComponentCond([:x, :y], [:p1, :p2]) do out, u, p, t
    out[1] = some_condition(u[...], p[...])
    out[2] = some_condition(u[...], p[...])
    return nothing
end</code></pre><p>Note that the <code>syms</code> argument (here <code>[:x, :y]</code>) can be used to reference <strong>any</strong> named state of the component model, this includes &quot;ordinary&quot; states, observed, inputs and outputs. The arguments <code>u</code> and <code>p</code> will be passed as <a href="../API/#NetworkDynamics.SymbolicView"><code>SymbolicView</code></a> objects, which mean it is possible to use the getindex syntax to acces the desired states by name.</p><p>The affect takes a similar form:</p><pre><code class="language-julia hljs">affect = ComponentAffect([:u], [:p]) do u, p, ctx
   t = ctx.t # extract data from context
   obs = NWState(ctx.integrator)[VIndex(ctx.vidx, :obs)] # extract some observed state from context
   println(&quot;Trigger affect at t=$t&quot;)
end
vectoraffect = ComponentAffect([:u], [:p]) do u, p, event_idx, ctx
    if event_idx == 1
        u[:u] = 0 # change state
    else
        u[:p] = 0 # change parameter
    end
end</code></pre><p>Notably, the <code>syms</code> (here <code>:u</code>) can <em>exclusivly</em> refer to &quot;ordinary&quot; states, since they are now writable. However the affect gets passed a <code>ctx</code> &quot;context&quot; object, which is a named tuple which holds additional context like the integrator object, the component model, the index of the component model, the current time and so on. Please refere to the <a href="../API/#NetworkDynamics.ComponentAffect"><code>ComponentAffect</code></a> docstring for a detailed list.</p><p>Lastly we need to define the actuall callback object using <a href="../API/#NetworkDynamics.ContinousComponentCallback"><code>ContinousComponentCallback</code></a>/<a href="../API/#NetworkDynamics.VectorContinousComponentCallback"><code>VectorContinousComponentCallback</code></a>:</p><pre><code class="language-julia hljs">ccb  = ContinousComponentCallback(condition, affect; kwargs...)
vccb = VectorContinousComponentCallback(condition, affect; kwargs...)</code></pre><p>where the <code>kwargs</code> are passed to the underlying <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/#SciMLBase.VectorContinuousCallback"><code>SciMLBase.VectorContinuousCallback</code></a> to finetune the zerocrossing-detection.</p><h3 id="Registering-the-Callback"><a class="docs-heading-anchor" href="#Registering-the-Callback">Registering the Callback</a><a id="Registering-the-Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Registering-the-Callback" title="Permalink"></a></h3><p>Once the callback is defined, we need to &quot;attach&quot; it to the component, for that you can use the methods <a href="../API/#NetworkDynamics.add_callback!"><code>add_callback!</code></a> and <a href="../API/#NetworkDynamics.set_callback!"><code>set_callback!</code></a>:</p><pre><code class="language-julia hljs">vert = VertexModel(...)
add_callback!(vert, ccb)
add_callback!(vert, vccb)</code></pre><h3 id="Extracting-the-Callback"><a class="docs-heading-anchor" href="#Extracting-the-Callback">Extracting the Callback</a><a id="Extracting-the-Callback-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-the-Callback" title="Permalink"></a></h3><p>In order to use the callback during simulation, we need to generate a <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/#SciMLBase.CallbackSet"><code>SciMLBase.CallbackSet</code></a> which contains the conditions and affects of all the component based callbacks in the network. For that we use <a href="../API/#NetworkDynamics.get_callbacks-Tuple{Network}"><code>get_callbacks(::Network)</code></a>:</p><pre><code class="language-julia hljs">u0 = NWState(u0)
cbs = get_callbacks(nw)
prob = ODEProblem(nw, uflat(u0), (0,10), pflat(u0); callback=cbs)
sol = solve(prob, ...)</code></pre><p>When combining the component based callbacks to a single callback, NetworkDynamics will check whether states and or parameters changed during the affect and automaticially call <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/#SciMLBase.auto_dt_reset%21"><code>SciMLBase.auto_dt_reset!</code></a> and <a href="../API/#NetworkDynamics.save_parameters!"><code>save_parameters!</code></a> if necessary.</p><h2 id="Normal-DiffEq-Callbacks"><a class="docs-heading-anchor" href="#Normal-DiffEq-Callbacks">Normal DiffEq Callbacks</a><a id="Normal-DiffEq-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-DiffEq-Callbacks" title="Permalink"></a></h2><p>Besides component based callbacks, it is also possible to use &quot;normal&quot; DiffEq callbacks together with <code>NetworkDynamics.jl</code>. It is far more powerful but also more cumbersome compared to the component based callback functions. To access states and parameters of specific components, we havily rely on the <a href="../symbolic_indexing/#Symbolic-Indexing">Symbolic Indexing</a> features.</p><pre><code class="language-julia hljs">using SymbolicIndexingInterface as SII
nw = Network(#= some network =#)

condition = let getvalue = SII.getsym(nw, VIndex(1:5, :some_state))
    function(out, u, t, integrator)
        s = NWState(integrator, u, integrator.p, t)
        some_state = getvalue(s)
        out .= some_condition(some_state)
    end
end</code></pre><p>Please not a few important things here:</p><ul><li>Symbolic indexing can be costly, and the condition function gets called very often. By using <a href="https://docs.sciml.ai/SymbolicIndexingInterface/stable/api/#SymbolicIndexingInterface.getsym"><code>SII.getsym</code></a> we did some of the work <em>before</em> the callback by creating the accessor function. When handling with &quot;normal states&quot; and parameters consider using <a href="https://docs.sciml.ai/SymbolicIndexingInterface/stable/api/#SymbolicIndexingInterface.variable_index"><code>SII.variable_index</code></a> and <a href="https://docs.sciml.ai/SymbolicIndexingInterface/stable/api/#SymbolicIndexingInterface.parameter_index"><code>SII.parameter_index</code></a> for even better access patterns.</li><li><code>t</code> refers to the current time of the zerocrossing-detection-algorithm. This is different from <code>integrator.t</code> which refers to the current timestep in which the zerocross-detectio takes place..</li></ul><pre><code class="language-julia hljs">function affect!(integrator, vidx)
    p = NWParameter(integrator) # get symbolicially indexable parameter object
    p.v[vidx, :some_vertex_parameter] = 0 # change some parameter
    auto_dt_reset!(integrator)
    save_parameters!(integrator)
end</code></pre><p>The affect function is much more straight forward, as it (typically) is called far less frequent and thus less perfomance critical.</p><p>Once the <code>condition</code> and <code>affect!</code> is defined, you can use the <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/#SciMLBase.ContinuousCallback"><code>SciMLBase.ContinuousCallback</code></a> and <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/#SciMLBase.VectorContinuousCallback"><code>SciMLBase.VectorContinuousCallback</code></a> constructors to create the callback.</p><div class="admonition is-info"><header class="admonition-header">Introducing discontinuities with adaptive timestepping</header><div class="admonition-body"><p>Since changes to <code>u</code> and <code>p</code> mostly introduce discontinuities in the solution, it is recommend to call <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/#SciMLBase.auto_dt_reset%21"><code>auto_dt_reset!</code></a> within the affect to restart integration with small steps afterwards.</p></div></div><div class="admonition is-info"><header class="admonition-header">Changing Parameters and Observables</header><div class="admonition-body"><p>An &quot;observable&quot; is kind of a &quot;virtual&quot; state, which can be reconstructed for a given time <code>t</code>, a given state <code>u</code> and a given set of parameters <code>p</code></p><p class="math-container">\[o = f(u(t), p(t), t)\]</p><p>To extract or plot timeseries of observed states under <em>time variant parameters</em> (i.e. parameters that are changed in a callback), those changes need to be recorded using the <a href="../API/#NetworkDynamics.save_parameters!"><code>save_parameters!</code></a> function whenever <code>p</code> is changed. When using <a href="../API/#NetworkDynamics.ComponentCallback">ComponentCallback</a>, NetworkDynamics will automaticially check for changes in <code>p</code> and save them if necessary.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../initialization/">« Initialization</a><a class="docs-footer-nextpage" href="../mtk_integration/">ModelingToolkit Integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 26 February 2025 17:40">Wednesday 26 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
