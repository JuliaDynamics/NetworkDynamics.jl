<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Initialization · NetworkDynamics</title><meta name="title" content="Initialization · NetworkDynamics"/><meta property="og:title" content="Initialization · NetworkDynamics"/><meta property="twitter:title" content="Initialization · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><a class="tocitem" href="../mathematical_model/">Mathematical Model</a></li><li><a class="tocitem" href="../network_construction/">Network Construction</a></li><li><a class="tocitem" href="../data_structure/">Data Structure</a></li><li><span class="tocitem">Features</span><ul><li><a class="tocitem" href="../symbolic_indexing/">Symbolic Indexing</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li class="is-active"><a class="tocitem" href>Initialization</a><ul class="internal"><li><a class="tocitem" href="#Initialization-Hierarchy"><span>Initialization Hierarchy</span></a></li><li><a class="tocitem" href="#Full-System-Initialization"><span>Full-System Initialization</span></a></li><li><a class="tocitem" href="#Component-wise-Network-Initialization"><span>Component-wise Network Initialization</span></a></li><li><a class="tocitem" href="#Single-Component-Initialization"><span>Single Component Initialization</span></a></li><li><a class="tocitem" href="#Analysing-Fixpoints"><span>Analysing Fixpoints</span></a></li></ul></li><li><a class="tocitem" href="../callbacks/">Callbacks and Events</a></li><li><a class="tocitem" href="../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../sparsity_detection/">Sparsity Detection</a></li><li><a class="tocitem" href="../external_inputs/">External Inputs</a></li><li><a class="tocitem" href="../inspector/">Interactive Solution Inspection</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../generated/heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../generated/init_tutorial/">Initialization</a></li><li><a class="tocitem" href="../generated/cascading_failure/">Cascading Failure</a></li><li><a class="tocitem" href="../generated/gas_network/">Gas Network</a></li><li><a class="tocitem" href="../generated/stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../generated/directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Features</a></li><li class="is-active"><a href>Initialization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Initialization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/src/initialization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="initialization-guide"><a class="docs-heading-anchor" href="#initialization-guide">Initialization</a><a id="initialization-guide-1"></a><a class="docs-heading-anchor-permalink" href="#initialization-guide" title="Permalink"></a></h1><p>Initialization is a critical step in simulation dynamical systems on networks, involving finding valid initial conditions that satisfy the system&#39;s constraints. NetworkDynamics provides several layers of initialization tools, from individual component initialization to full network initialization.</p><h2 id="Initialization-Hierarchy"><a class="docs-heading-anchor" href="#Initialization-Hierarchy">Initialization Hierarchy</a><a id="Initialization-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-Hierarchy" title="Permalink"></a></h2><p>NetworkDynamics offers a tiered approach to initialization:</p><ol><li><strong>Full-System Initialization</strong>: Finding a steady state for the entire network at once</li><li><strong>Component-wise Network Initialization</strong>: Initializing each component individually while respecting network coupling</li><li><strong>Single Component Initialization</strong>: Finding valid internal states for a single component</li></ol><h2 id="Full-System-Initialization"><a class="docs-heading-anchor" href="#Full-System-Initialization">Full-System Initialization</a><a id="Full-System-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Full-System-Initialization" title="Permalink"></a></h2><p>Full system initialization aims to find a fixed point/steady state of the entire system simultaneously.</p><p>To do so, you can use <a href="../API/#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a>, which creates a <code>SteadyStateProblem</code> of the whole network and attempts to solve it:</p><pre><code class="language-julia hljs"># Create a network
nw = Network(vertices, edges)

# Find a fixed point for the entire system
state = find_fixpoint(nw)</code></pre><p>This approach works well for simpler systems but may face convergence challenges for complex networks with many interacting components.</p><h2 id="Component-wise-Network-Initialization"><a class="docs-heading-anchor" href="#Component-wise-Network-Initialization">Component-wise Network Initialization</a><a id="Component-wise-Network-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Component-wise-Network-Initialization" title="Permalink"></a></h2><p>For more complex networks, a component-by-component approach is often more robust. NetworkDynamics provides <a href="../API/#NetworkDynamics.initialize_componentwise"><code>initialize_componentwise</code></a> and <a href="../API/#NetworkDynamics.initialize_componentwise!"><code>initialize_componentwise!</code></a> functions that:</p><ol><li>Initialize each component individually</li><li>Verify the combined solution works for the entire network</li></ol><pre><code class="language-julia hljs"># Initialize each component in the network individually
state = initialize_componentwise(nw)

# Or using the mutating version that updates component metadata
state = initialize_componentwise!(nw)</code></pre><h3 id="Two-Step-Initialization-Pattern"><a class="docs-heading-anchor" href="#Two-Step-Initialization-Pattern">Two-Step Initialization Pattern</a><a id="Two-Step-Initialization-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Step-Initialization-Pattern" title="Permalink"></a></h3><p>A common initialization pattern for complex networks involves:</p><ol><li>Solving a simplified static model first</li><li>Using those results to initialize a more complex dynamic model</li></ol><pre><code class="language-julia hljs"># 1. Solve a static/simplified model
static_model = create_static_network(...)
static_state = find_fixpoint(static_model)

# 2. Extract interface values
interface_vals = interface_values(static_state)

# 3. Use them to initialize a dynamic model
dynamic_model = create_dynamic_network(...)
dyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)</code></pre><p>See the <a href="../generated/init_tutorial/#init-tutorial">Tutorial on Initialization</a> for a complete example of this approach.</p><h2 id="Single-Component-Initialization"><a class="docs-heading-anchor" href="#Single-Component-Initialization">Single Component Initialization</a><a id="Single-Component-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Component-Initialization" title="Permalink"></a></h2><p>At the lowest level, NetworkDynamics provides tools for initializing individual components based on their internal dynamics and interface constraints.</p><h3 id="Mathematical-Meaning"><a class="docs-heading-anchor" href="#Mathematical-Meaning">Mathematical Meaning</a><a id="Mathematical-Meaning-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Meaning" title="Permalink"></a></h3><p>According to the <a href="../mathematical_model/#Mathematical-Model">Mathematical Model</a> of NetworkDynamics.jl, a component forms an &quot;input-output-system&quot; of the form</p><p class="math-container">\[\begin{aligned}
M\,\frac{\mathrm{d}}{\mathrm{d}t}x &amp;= f(x, i, p, t)\\
y &amp;= g(x, i, p, t)
\end{aligned}\]</p><p>where <span>$x$</span> are the internal states, <span>$i$</span> are the inputs, <span>$y$</span> are the outputs, and <span>$p$</span> are the parameters. To initialize at a fixed point, we require the RHS to be zero,</p><p class="math-container">\[\begin{aligned}
0 &amp;= f(x, i, p, t)\\
0 &amp;= g(x, i, p, t) - y
\end{aligned}\]</p><p>forming a nonlinear least squares problem for the residual. Each variable in <span>$x$</span>, <span>$i$</span>, <span>$y$</span> and <span>$p$</span> is either considered <strong>free</strong> or <strong>fixed</strong> with respect to the nonlinear problem stated above. Symbols that have a <strong>default</strong> value (see <a href="../metadata/#Metadata">Metadata</a>) are considered <em>fixed</em>. All other symbols are considered <em>free</em> and must provide a <strong>guess</strong> value as an initial starting point for the nonlinear solver.</p><p>The <strong>defaults</strong> and <strong>guesses</strong> can be either obtained from the <a href="../metadata/#Metadata">Metadata</a> directly or provided as arguments.</p><h3 id="Non-mutating-vs-Mutating-Initialization"><a class="docs-heading-anchor" href="#Non-mutating-vs-Mutating-Initialization">Non-mutating vs Mutating Initialization</a><a id="Non-mutating-vs-Mutating-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Non-mutating-vs-Mutating-Initialization" title="Permalink"></a></h3><p>NetworkDynamics provides two approaches for component-wise initialization:</p><ol><li><strong>Non-mutating approach</strong> using <a href="../API/#NetworkDynamics.initialize_component"><code>initialize_component</code></a>: Returns a dictionary of values without modifying the component</li><li><strong>Mutating approach</strong> using <a href="../API/#NetworkDynamics.initialize_component!"><code>initialize_component!</code></a>: Directly updates the component metadata with initialization results</li></ol><p>Both options take guesses and defaults from metadata by default; however, it is possible to specify otherwise (see method documentation).</p><p>The non-mutating version <a href="../API/#NetworkDynamics.initialize_component"><code>initialize_component</code></a> is useful when you don&#39;t want to modify the metadata, for a more &quot;stateless&quot; approach:</p><pre><code class="language-julia hljs"># Get initialization results as a dictionary
init_state = initialize_component(vf; default_overrides=Dict(:x =&gt; 4))</code></pre><p>It will return a <code>Dict{Symbol,Float64}</code> which contains values for <strong>all</strong> symbols in the model.</p><p>The mutating version <a href="../API/#NetworkDynamics.initialize_component!"><code>initialize_component!</code></a> directly updates the component&#39;s metadata with initialization results:</p><pre><code class="language-julia hljs">initialize_component!(vf; verbose=true) # set `init` metadata for free symbols</code></pre><p>The same pattern applies at the network level with <a href="../API/#NetworkDynamics.initialize_componentwise"><code>initialize_componentwise</code></a> and <a href="../API/#NetworkDynamics.initialize_componentwise!"><code>initialize_componentwise!</code></a>.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Let&#39;s consider the following example of a Swing-equation generator model.</p><pre><code class="language-julia hljs">using NetworkDynamics, ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as Dt

@mtkmodel Swing begin
    @variables begin
        u_r(t)=1, [description=&quot;bus d-voltage&quot;, output=true]
        u_i(t)=0.1, [description=&quot;bus q-voltage&quot;, output=true]
        i_r(t)=1, [description=&quot;bus d-current (flowing into bus)&quot;, input=true]
        i_i(t)=0.1, [description=&quot;bus d-current (flowing into bus)&quot;, input=true]
        ω(t), [guess=0.0, description=&quot;Rotor frequency&quot;]
        θ(t), [guess=0.0, description=&quot;Rotor angle&quot;]
        Pel(t), [guess=1, description=&quot;Electrical Power injected into the grid&quot;]
    end
    @parameters begin
        M=0.005, [description=&quot;Inertia&quot;]
        D=0.1, [description=&quot;Damping&quot;]
        V, [guess=1.0, description=&quot;Voltage magnitude&quot;]
        ω_ref=0, [description=&quot;Reference frequency&quot;]
        Pm, [guess=0.1,description=&quot;Mechanical Power&quot;]
    end
    @equations begin
        Dt(θ) ~ ω - ω_ref
        Dt(ω) ~ 1/M * (Pm - D*ω - Pel)
        Pel ~ u_r*i_r + u_i*i_i
        u_r ~ V*cos(θ)
        u_i ~ V*sin(θ)
    end
end
sys = Swing(name=:swing)
vf = VertexModel(sys, [:i_r, :i_i], [:u_r, :u_i])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:swing</span> <span class="sgr94">NoFeedForward()</span>
 ├─ 2 inputs:  [i_r=1, i_i=0.1]
 ├─ 2 states:  [ω<span class="sgr90">≈0</span>, θ<span class="sgr90">≈0</span>]
 ├─ 2 outputs: [u_r=1, u_i=0.1]
 └─ 5 params:  [M=0.005, D=0.1, V<span class="sgr90">≈1</span>, ω_ref=0, Pm<span class="sgr90">≈0.1</span>]</code></pre><p>You can see in the provided <a href="../API/#NetworkDynamics.metadata">metadata</a> that we&#39;ve set <code>default</code> values for the node outputs <code>u_r</code>, <code>u_i</code>, the node inputs <code>i_r</code>, <code>i_i</code>, and most parameters. For some states and parameters, we&#39;ve only provided a <code>guess</code> rather than a default. Variables that only have <code>guess</code>es are considered &quot;tunable&quot; for the initialization algorithm.</p><h3 id="Using-the-non-mutating-initialization"><a class="docs-heading-anchor" href="#Using-the-non-mutating-initialization">Using the non-mutating initialization</a><a id="Using-the-non-mutating-initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-non-mutating-initialization" title="Permalink"></a></h3><p>We can use <a href="../API/#NetworkDynamics.initialize_component"><code>initialize_component</code></a> to get the initialized values without modifying the component:</p><pre><code class="language-julia hljs">init_values = initialize_component(vf; default_overrides=Dict(:u_i=&gt;0), verbose=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Float64} with 11 entries:
  :D     =&gt; 0.1
  :V     =&gt; 1.0
  :i_i   =&gt; 0.1
  :Pm    =&gt; 1.0
  :M     =&gt; 0.005
  :ω_ref =&gt; 0.0
  :θ     =&gt; 6.35404e-16
  :i_r   =&gt; 1.0
  :u_r   =&gt; 1.0
  :u_i   =&gt; 0.0
  :ω     =&gt; -4.55864e-16</code></pre><p>The code returns a dictionary which pins <em>all</em> the variables of the component to some values which satisfy the initialization condition.</p><h3 id="Using-the-mutating-initialization"><a class="docs-heading-anchor" href="#Using-the-mutating-initialization">Using the mutating initialization</a><a id="Using-the-mutating-initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-mutating-initialization" title="Permalink"></a></h3><p>Alternatively, we can make use of the mutating version to store the results of the initialization in the metadata:</p><pre><code class="language-julia hljs">initialize_component!(vf; verbose=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:swing</span> <span class="sgr94">NoFeedForward()</span>
 ├─ 2 inputs:  [i_r=1, i_i=0.1]
 ├─ 2 states:  [ω=4.8748e-27, θ=0.099669]
 ├─ 2 outputs: [u_r=1, u_i=0.1]
 └─ 5 params:  [M=0.005, D=0.1, V=1.005, ω_ref=0, Pm=1.01]</code></pre><p>Which stored the initialisation results as <code>:init</code> metadata of the component model <code>vf</code>:</p><pre><code class="language-julia hljs">get_init(vf, :V) # get the value of :V at initialized state</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.004987562112089</code></pre><p>It is possible to inspect initial states (works also for observed symbols) using <a href="../API/#NetworkDynamics.get_initial_state"><code>get_initial_state</code></a>. As a quick test we can ensure that the angle indeed matches the voltage angle:</p><pre><code class="language-julia hljs">get_initial_state(vf, :θ) ≈ atan(get_initial_state(vf, :u_i), get_initial_state(vf, :u_r))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>You can print out the whole state using <a href="../API/#NetworkDynamics.dump_initial_state"><code>dump_initial_state</code></a>.</p><pre><code class="language-julia hljs">dump_initial_state(vf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">Inputs:</span>
  i_i   = <span class="sgr34"> 0.1</span>
  i_r   = <span class="sgr34"> 1</span>
<span class="sgr1">States:</span>
  θ     = <span class="sgr33"> 0.099669</span>   (guess  0)
  ω     = <span class="sgr33"> 4.8748e-27</span> (guess  0)
<span class="sgr1">Outputs:</span>
  u_i   = <span class="sgr34"> 0.1</span>
  u_r   = <span class="sgr34"> 1</span>
<span class="sgr1">Parameters:</span>
  D     = <span class="sgr34"> 0.1</span>
  M     = <span class="sgr34"> 0.005</span>
  Pm    = <span class="sgr33"> 1.01</span>       (guess  0.1)
  V     = <span class="sgr33"> 1.005</span>      (guess  1)
  ω_ref = <span class="sgr34"> 0</span>
<span class="sgr1">Observed:</span>
  Pel   =  1.01</code></pre><h3 id="Advanced-Component-Initialization:-Formulas-and-Constraints"><a class="docs-heading-anchor" href="#Advanced-Component-Initialization:-Formulas-and-Constraints">Advanced Component Initialization: Formulas and Constraints</a><a id="Advanced-Component-Initialization:-Formulas-and-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Component-Initialization:-Formulas-and-Constraints" title="Permalink"></a></h3><p>NetworkDynamics provides three complementary mechanisms for customizing component initialization beyond the basic defaults and guesses: <strong>initialization formulas</strong> ,<strong>initialization constraints</strong> and <strong>guess formulas</strong>. These operate at different stages of the initialization pipeline and serve distinct purposes:</p><ul><li>init formulas <strong>reduce the number of free variables</strong> (by setting additional defaults),</li><li>init constraints <strong>increase the number of equations</strong> for the init problem and</li><li>guess formulas <strong>refine starting values</strong> for the initialization rootfinding problem.</li></ul><p>The execution order is:</p><ol><li>Collect defaults, guesses, and bounds from metadata</li><li>Apply init formulas → update defaults (fix more variables)</li><li>Apply guess formulas → update guesses (improve starting point)</li><li>Create and solve the nonlinear least squares problem with additonal constraints</li></ol><h4 id="Initialization-Formulas-(InitFormula)"><a class="docs-heading-anchor" href="#Initialization-Formulas-(InitFormula)">Initialization Formulas (<code>InitFormula</code>)</a><a id="Initialization-Formulas-(InitFormula)-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-Formulas-(InitFormula)" title="Permalink"></a></h4><p>Initialization formulas act early in the initialization pipeline to compute and set default values based on other known values. They are particularly useful for deriving dependent quantities or ensuring consistency between related variables.</p><p>Each formula can only reference symbols that are already available - it cannot use intermediate values computed within the same formula.</p><p><strong>Basic Usage</strong>: Use the <a href="../API/#NetworkDynamics.@initformula"><code>@initformula</code></a> macro to define formulas with assignment syntax:</p><pre><code class="language-julia hljs"># Example: Set voltage magnitude and electrical power based on voltage components
voltage_formula = @initformula begin
    :V = sqrt(:u_r^2 + :u_i^2)     # Voltage magnitude from components
    :Pel = :u_r * :i_r + :u_i * :i_i # Electrical power calculation
end</code></pre><p><strong>Applying Formulas</strong>: Formulas can be either added to the metadata of components (<a href="../API/#NetworkDynamics.set_initformula!"><code>set_initformula!</code></a>, <a href="../API/#NetworkDynamics.add_initformula!"><code>add_initformula!</code></a>) or passed as <code>additional_initformula</code> to the <a href="../API/#NetworkDynamics.initialize_component"><code>initialize_component[!]</code></a> functions.</p><p><strong>Dependency Resolution</strong>: When applying multiple separate formulas, NetworkDynamics automatically sorts them topologically to ensure correct evaluation order.</p><h4 id="Initialization-Constraints-(InitConstraint)"><a class="docs-heading-anchor" href="#Initialization-Constraints-(InitConstraint)">Initialization Constraints (<code>InitConstraint</code>)</a><a id="Initialization-Constraints-(InitConstraint)-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-Constraints-(InitConstraint)" title="Permalink"></a></h4><p>Initialization constraints add equations to the nonlinear system that must be satisfied during the initialization solve. Unlike formulas, they don&#39;t directly set values but impose mathematical relationships.</p><p><strong>Basic Usage</strong>: Use the <a href="../API/#NetworkDynamics.@initconstraint"><code>@initconstraint</code></a> macro to define constraint equations:</p><pre><code class="language-julia hljs"># Example: Constrain electrical power and voltage magnitude
power_constraint = @initconstraint begin
    :Pel - 1.0                        # Electrical power must equal 1.0
    sqrt(:u_r^2 + :u_i^2) - 1.0      # Voltage magnitude must equal 1.0
end</code></pre><p><strong>Applying Constraints</strong>: Constraints can be either added to the metadata of components (<a href="../API/#NetworkDynamics.set_initconstraint!"><code>set_initconstraint!</code></a>, <a href="../API/#NetworkDynamics.add_initconstraint!"><code>add_initconstraint!</code></a>) or passed as <code>additional_initconstraint</code> to the <a href="../API/#NetworkDynamics.initialize_component"><code>initialize_component[!]</code></a> functions.</p><h4 id="Guess-Formulas-(GuessFormula)"><a class="docs-heading-anchor" href="#Guess-Formulas-(GuessFormula)">Guess Formulas (<code>GuessFormula</code>)</a><a id="Guess-Formulas-(GuessFormula)-1"></a><a class="docs-heading-anchor-permalink" href="#Guess-Formulas-(GuessFormula)" title="Permalink"></a></h4><p>Guess formulas operate later in the initialization pipeline than init formulas. While init formulas set default values (thereby reducing the number of free variables), guess formulas refine the initial guesses for free variables to improve solver convergence without changing the problem dimension.</p><p>While InitFormulas use defaults to update other defaults, GuessFormulas update guesses based on other defaults and guesses (if some variable has a default and guess defined, the default takes precedence). They act <strong>after</strong> the InitFormulas, thus having access to the updated defaults.</p><p>Similar to InitFormulas, NetworkDyanmics makes sure that there are no circular dependencies between guess formulas and you can&#39;t have multiple guess formulas updating the same variables. It performs some topological sorting on multiple guesses to update in order.</p><p><strong>Basic Usage</strong>: Use the <a href="../API/#NetworkDynamics.@guessformula"><code>@guessformula</code></a> macro with the same assignment syntax as init formulas:</p><pre><code class="language-julia hljs"># Example: Improve angle and voltage guesses from interface values
setpoint_guesses = @guessformula begin
    :V_set = sqrt(:u_r^2 + :u_i^2)     # guess voltage mag setpoint close to actual voltage
    :P_set = :u_r * :i_r + :u_i * :i_i # guess power setpoint close to actual power
end</code></pre><p><strong>Applying GuessFormulas</strong>: Like init formulas and constraints, guess formulas can be stored in metadata (<a href="../API/#NetworkDynamics.set_guessformula!"><code>set_guessformula!</code></a>) or passed directly using the <code>additional_guessformula</code> keyword in <a href="../API/#NetworkDynamics.initialize_componentwise"><code>initialize_componentwise</code></a>, <a href="../API/#NetworkDynamics.initialize_component"><code>initialize_component</code></a> and friends.</p><h2 id="Analysing-Fixpoints"><a class="docs-heading-anchor" href="#Analysing-Fixpoints">Analysing Fixpoints</a><a id="Analysing-Fixpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Analysing-Fixpoints" title="Permalink"></a></h2><p>In order to analyse fixpoints NetworkDynamis provides the functions <a href="../API/#NetworkDynamics.isfixpoint"><code>isfixpoint</code></a>, <a href="../API/#NetworkDynamics.is_linear_stable"><code>is_linear_stable</code></a> and <a href="../API/#NetworkDynamics.jacobian_eigenvals"><code>jacobian_eigenvals</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metadata/">« Metadata</a><a class="docs-footer-nextpage" href="../callbacks/">Callbacks and Events »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 12 December 2025 02:35">Friday 12 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
