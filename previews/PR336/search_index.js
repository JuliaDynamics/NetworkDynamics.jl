var documenterSearchIndex = {"docs":
[{"location":"mtk_integration/#ModelingToolkit-Integration","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"NetworkDynamics.jl is compatible with ModelingToolkit.jl (MTK). The general idea is to use MTK to define component models (i.e. edge and vertex dynamics) which are then connected on network scale using NetworkDynamics.\n\nThe main entry point for this interop are the constructors\n\nVertexModel(::System, inputs, outputs)\nEdgeModel(::System, srcin, dstin, [srscout], dstout)\n\nwhose docstrings can be found in the Component Models with MTK section in the API.\n\nThese constructors will:\n\ntransform the states marked as input to parameters and mtkcompileing the system,\ngenerate the f and g functions,\ngenerate code for observables,\nport all supported Metadata from MTK symbols to component symbols and\noutput a Vertex-/EdgeModel function compatible with NetworkDynamics.jl.\n\nThe main usecase for this feature is when you want to build relatively complex component models but interconnect them in a very homogeneous way (i.e. having the same output/input pairings in the whole system).\n\nIn theory, you can achieve everything you want to do with plain MTK. The idea of combining the two is, that NetworkDynamics offers far less flexibility when in comes to interconnection of subsystems on the network level. This might allow ND to exploit more knowledge of the structure without very expensive operations such as tearing of thousands of equations.\n\nwarning: Warning\nModelingToolkit is a fast paced library with lots of functionality and ever growing complexity. As such the provided interface is kinda experimental. Some features of MTK are straight up unsupported, for example events within models or delay differential equations.","category":"section"},{"location":"mtk_integration/#RC-Circuit-Example","page":"ModelingToolkit Integration","title":"RC-Circuit Example","text":"In good MTK tradition, this feature will be explained along a simple RC circuit example. The Gas Network Example or Initialization Tutorial also showcase the MTK constructors.\n\nThe system to model is 2 node, 1 edge network. The node output states are the voltage (to ground), the edge output sates are the currents at both ends.\n\n\nideal v source      Resistor     Capacitor\n            v1 o─←────MMM────→─o v2\n               │               ┴\n              (↗)              ┬\n               │               │\n               ⏚               ⏚\n\nObviously there is no need in modeling such a small system using NetworkDynamics, however the method extends quite easily to construct large electrical networks reusing the same fundamental building blocks.\n\nusing NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\n\nAll our components have \"terminals\", which have a voltage and current. We don't use the @connector from MTK here because our pins mark the interface towards the network and do not follow the MTK connector semantics.\n\n@mtkmodel NWTerminal begin\n    @variables begin\n        v(t), [description=\"Voltage at node\"]\n        i(t), [description=\"Current flowing into node\"]\n    end\nend\nnothing #hide\n\nAn ideal voltage source is just a model which pins its output voltage to a fixed parameter. The source ejects whatever current is necessary. We introduce another variable i(t) to \"capture\" this current. This variable will be removed during structural simplify, but will be available for plotting through the Observables mechanism. The VertexModel can be generated from an System by providing names of the input and output states:\n\n@mtkmodel VoltageSource begin\n    @components begin\n       p = NWTerminal()\n    end\n    @parameters begin\n        V = 1.0\n    end\n    @variables begin\n        i(t), [description=\"produced current by ideal voltage source (observable)\"]\n    end\n    @equations begin\n        i ~ -p.i\n        p.v ~ V\n    end\nend\n@named vs = VoltageSource()\nvs_vertex = VertexModel(vs, [:p₊i], [:p₊v]; vidx=1)\n\nA capacitor is a slightly more complicated model. Its voltage is defined as an differential equation based on the inflowing current.\n\n@mtkmodel Capacitor begin\n    @components begin\n        p = NWTerminal(;v=0)\n    end\n    @parameters begin\n        C = 1.0\n    end\n    @equations begin\n        D(p.v) ~ p.i / C\n    end\nend\n@named cap = Capacitor()\ncap_vertex = VertexModel(cap, [:p₊i], [:p₊v], vidx=2)\n\nFor the resistor we need two pins, one for the src and one for the dst side. The equations are straight forward.\n\n@mtkmodel Resistor begin\n    @components begin\n        src = NWTerminal()\n        dst = NWTerminal()\n    end\n    @parameters begin\n        R = 1.0\n    end\n    @equations begin\n        dst.i ~ (src.v - dst.v)/R\n        src.i ~ -dst.i\n    end\nend\n@named resistor = Resistor()\nresistor_edge = EdgeModel(resistor, [:src₊v], [:dst₊v], [:src₊i], [:dst₊i]; src=:vs, dst=:cap)\n\nHaving all those components defined, we can build the network. We don't need to provide a graph object here because we specified the placement in the graph on a per component basis.\n\nnw = Network([vs_vertex, cap_vertex], [resistor_edge])\n\nWe can see, that NetworkDynamics internally is able to reduce all of the \"output\" states. We end up with a plain ODE of a single state.\n\nNow we can simulate the system. For that we generate the u0 object. Since the metadata (such as default values) was automatically transferred, we can straight away construct the ODEProblem and solve the system.\n\nu0 = NWState(nw) # generate state based on default values\nprob = ODEProblem(nw, uflat(u0), (0, 10.0), pflat(u0))\nsol = solve(prob, Tsit5())\n\n# plot the solution\nfig, ax1, p = plot(sol; idxs=VIndex(:cap, :p₊v), label=\"Capacitor Voltage\");\naxislegend(ax1)\nax2 = Axis(fig[2,1])\nplot!(ax2, sol; idxs=VIndex(:vs, :i), label=\"Current produced by ideal v source\")\naxislegend(ax2)\nfig # hide","category":"section"},{"location":"mtk_integration/#Fully-Implicit-Outputs","page":"ModelingToolkit Integration","title":"Fully Implicit Outputs","text":"When working with MTK systems in NetworkDynamics, you may encounter situations where your desired output variables don't explicitly appear in the equations. This creates fully implicit outputs - variables that are determined by the system's constraints but aren't directly computed.\n\ntip: tl;dr\nIntroduce \"fake\" dependencies to your input-forcing equations 0 ~ in + implicit_output(y). Which is mathematically equivalent to 0 ~ in but helps MTK to reason about dependencies.\n\nConsider a system with a fully implicit output:\n\n   u┌───────┐y\n  ─→┤ 0 ~ u ├→─\n    └───────┘\n\nHere, y does not appear in the equations at all. In general, that doesn't make too much sense. During simplification, MTK will potentially get rid of the equation as it does not contribute to the system's state.\n\nHowever, in NetworkDynamics, we're always dealing with open loop models on the equation level, which is not exactly what MTK was made for. If you build a closed loop between a subsystem A which has input forcing (input appears in constraint) and a subsystem B which has input feed forward, the resulting system can be solved:\n\n    (system with input forcing)\n          ua┌─────────┐ya\n        ┌──→┤  0 ~ ua ├→──┐\n        │   └─────────┘   │\n        │ yb┌─────────┐ub │\n        └──←┤ yb ~ ub ├←──┘\n            └─────────┘\n(system with input feed forward)\n\nSince MTK does not know about the closed loop (which is only introduced on the NetworkDynamics level once we leave the equation based domain) we need to help MTK to figure out those dependencies. We can do so by introducing \"fake\" dependencies using implicit_output. This function is defined as\n\nimplicit_output(x) = 0\nModelingToolkit.@register_symbolic implicit_output(x)\n\nwhich makes it numerically equivalent to zero (no effect on the simulation) but is opaque to the Symbolic Simplification.\n\nAlternatively, instead of manually adding implicit_output to equations, you can use the assume_io_coupling=true flag in the VertexModel and EdgeModel constructors to automatically insert these dependencies for all inputs.","category":"section"},{"location":"mtk_integration/#Example","page":"ModelingToolkit Integration","title":"Example","text":"Consider a \"Kirchhoff Node\" between multiple resistors:\n\nthe currents through the resistors directly depend on the voltage output of the node (input feed forward) and\nthe Kirchhoff node requires the sum of all inflowing currents to be zero (input forcing).\n\nWe can model this type of node like this:\n\n@mtkmodel KirchhoffNode begin\n    @variables begin\n        v(t), [description=\"Node voltage\", output=true]\n        i_sum(t), [description=\"Sum of incoming currents\", input=true]\n    end\n    @equations begin\n        0 ~ i_sum + implicit_output(v)  # Kirchhoff's current law\n    end\nend\n@named kirchhoff = KirchhoffNode()\nVertexModel(kirchhoff, [:i_sum], [:v])\n\nwhere we \"trick\" MTK into believing that the input forcing equation depends on the output too.\n\nAlternatively, you could achieve the same result without manually adding implicit_output by using:\n\nVertexModel(kirchhoff, [:i_sum], [:v], assume_io_coupling=true)\nnothing # hide","category":"section"},{"location":"mtk_integration/#Troubleshooting:-Derivatives-in-RHS","page":"ModelingToolkit Integration","title":"Troubleshooting: Derivatives in RHS","text":"Closely related to the fully implicit outputs are situations where derivatives of input states appear on the right hand side of equations.\n\nLet's consider the case where we want to model an inductance to ground in the electrical network example we started above:\n\n@mtkmodel InductanceToGround begin\n    @components begin\n        p = NWTerminal()\n    end\n    @variables begin\n        i(t), [description=\"Current through inductor\", output=true]\n    end\n    @parameters begin\n        L = 1.0\n    end\n    @equations begin\n        p.i ~ i\n        L*D(i) ~ p.v\n    end\nend\n@named ind = InductanceToGround()\nnothing #hide\n\nWhen we try to build this model, we get an error:\n\ntry #hide\nVertexModel(ind, [:p₊i], [:p₊v])\ncatch e #hide\n    @assert e isa NetworkDynamics.RHSDifferentialsError #hide\n    printstyled(\"ERROR: \", color=:light_red, bold=true) #hide\n    Base.showerror(IOContext(stdout, :color => true), e) #hide\nend #hide\nnothing #hide\n\nWhich can be solved by adding the assume_io_coupling=true flag:\n\nVertexModel(ind, [:p₊i], [:p₊v], assume_io_coupling=true)\n\nWhat happens is, that MTK solves p.i ~ i for i and plugs that into the second equation, which requires the derivative of our input p.i! Passing assume_io_coupling=true essentially inserts a fake dependency of that equation on the output p.v:\n\np.i + implicit_output(p.v) ~ i\n\nTherefore, MTK cannot resolve for i anymore and leaves the equation as a constraint.\n\nnote: Be careful with non-feed-forward edges\nUsing implicit_output and assume_io_coupling assumes that there is some direct feedback mechanism input = f(output). That is not always the case! For example, consider a small electrical network where the edge itself is modeled as an inductance. In that case, both sides of p.i ~ i are defined as a differential equation and thus smooth. You cannot fulfill this constraint by changing the voltage. In those scenarios, you'd need to introduce a capacitor to ground at the node model, relaxing the constraint 0 = i_edge + i_node to something like Cfracddtv_node = i_edge + i_node.","category":"section"},{"location":"mtk_integration/#Register-Postprocessing-Functions","page":"ModelingToolkit Integration","title":"Register Postprocessing Functions","text":"MTK models are \"composite\" by design, i.e. your toplevel model might consist of multiple internal components. Sometimes, you want to specify behavior of the encapsulating model on a subcomponent level. For that, NetworkDynamics provides the ComponentPostprocessing metadata mechanism.\n\nLet's say you want to implement an integrator with anti windup\n\n              __ outMax\n             /\n        ╭─────╮\n     in │  K  │ out\n    ╶───┤╶───╴├────╴\n        │ s T │\n        ╰─────╯\noutMin __/\n\nWe could try to implement this using ifelse  functions, but the proper way is to do it with callbacks. Since NetworkDynamics cannot understand events defined within MTK models, we need to attach the callbacks on the component level. That's annoying, because the building block might appear in lots of different models. To work around this shortcoming, ND.jl allows you to define postprocessing functions, which will be called on every model which makes use of the subsystem.\n\nIn our model, we add two \"internal\" parameters, to indicate if the system is in lower or upper saturation. Depending on the saturation state, the integrator is \"disabled\". The model definition looks like this. The important part is the @metadata block at the end.\n\nfunction attach_limint_callback! end # function needs to exist before model\n@mtkmodel LimitedIntegrator begin\n    @structural_parameters begin\n        K # Gain\n        T # Time constant\n        outMin # Lower limit\n        outMax # Upper limit\n        guess=0\n    end\n    @parameters begin\n        _callback_sat_max = 0\n        _callback_sat_min = 0\n    end\n    @variables begin\n        in(t), [description=\"Input signal\", input=true]\n        out(t), [guess=guess, description=\"limited integrator output state\", output=true]\n        min(t), [description=\"Lower limit\"]\n        max(t), [description=\"Upper limit\"]\n        forcing(t)\n    end\n    @equations begin\n        min ~ outMin\n        max ~ outMax\n        forcing ~ K*in\n        T*D(out) ~ (1 - _callback_sat_max - _callback_sat_min) * forcing\n    end\n    @metadata begin\n        ComponentPostprocessing = attach_limint_callback!\n    end\nend\nnothing #hide\n\nThe callback to generate is split in three separate conditions:\n\nif out - max registers an upcrossing, enter upper saturation\nif -out + min registers an upcrossing, enter lower saturation\nif currently in saturation, check for zero crossings in forcing, if in upper saturation and\n\nforcing turns negative, unsaturate. If in lower saturation and forcing turns positive unsaturate.\n\nThe function below generates such a callback for the component at a given namespace:\n\nfunction attach_limint_callback!(cf, namespace)\n    # generate the required symbols based on the namespace\n    min = Symbol(namespace, \"₊min\")\n    max = Symbol(namespace, \"₊max\")\n    out = Symbol(namespace, \"₊out\")\n    forcing = Symbol(namespace, \"₊forcing\")\n    satmax = Symbol(namespace, \"₊_callback_sat_max\")\n    satmin = Symbol(namespace, \"₊_callback_sat_min\")\n\n    condition = ComponentCondition([min, max, out, forcing], [satmax, satmin]) do _out, u, p, _\n        insatmax = !iszero(p[satmax])\n        insatmin = !iszero(p[satmin])\n\n        upcrossing_max =  u[out] - u[max]\n        upcrossing_min = -u[out] + u[min]\n\n        # enable upper saturation\n        _out[1] = insatmax ? Inf : upcrossing_max\n        # enable lower saturation\n        _out[2] = insatmin ? Inf : upcrossing_min\n        if insatmax || insatmin\n            # when in saturation, check for zero crossing of forcing\n            _out[3] = u[forcing]\n        else\n            _out[3] = Inf\n        end\n    end\n\n    upcrossing_affect = ComponentAffect([], [satmax, satmin]) do u, p, eventidx, ctx\n        if eventidx == 1\n            println(\"$namespace: /⎺ reached upper saturation at $(round(ctx.t, digits=4))s\")\n            p[satmax] = 1.0\n            p[satmin] = 0.0\n        elseif eventidx == 2\n            println(\"$namespace: \\\\_ reached lower saturation at $(round(ctx.t, digits=4))s\")\n            p[satmax] = 0.0\n            p[satmin] = 1.0\n        elseif eventidx == 3\n            # upcrossing means, forcing went from negative to positive, i.e. we leave lower saturation\n            insatmin = !iszero(p[satmin])\n            if insatmin\n                println(\"$namespace: _/ left lower saturation at $(round(ctx.t, digits=4))s\")\n                p[satmin] = 0.0\n            end\n        else\n            error(\"Unknown event index $eventidx\")\n        end\n    end\n\n    downcrossing_affect = ComponentAffect([],[satmax]) do u, p, eventidx, ctx\n        if eventidx == 3 # downcrossing means nothing for saturation affects\n            # downcrossing means, forcing went from positive to negative, i.e. we leave upper saturation\n            insatmax = !iszero(p[satmax])\n            if insatmax\n                println(\"$namespace: ⎺\\\\ left upper saturation at $(round(ctx.t, digits=4))s\")\n                p[satmax] = 0.0\n            end\n        else\n            error(\"Unknown event index $eventidx\")\n        end\n    end\n\n    cb = VectorContinuousComponentCallback(condition, upcrossing_affect, 3; affect_neg! = downcrossing_affect)\n\n    # finally add callback to component\n    NetworkDynamics.add_callback!(cf, cb)\nend\nnothing #hide\n\nwarning: Warning\nEven though fairly complex, the above function is a simplified example which may have performance problems and does not add \"safety\" discrete callbacks. Under discrete jumps, the zero crossing might be skipped so it is good practice to add additional discrete callbacks to detect those cases (i.e. check if out >= max + 1e-10). You'll find a \"proper\" version of the saturated integrator in the PowerDynamics.jl Library, feel free to copy the code from there.\n\nWith the definition above, we can create a model which uses the limited integrator:\n\n@mtkmodel ComponentWithLimInt begin\n    @components begin\n        int = LimitedIntegrator(K=1, T=1, outMin=-1, outMax=1)\n    end\n    @variables begin\n        out(t)\n        in(t)\n    end\n    @equations begin\n        int.in ~ in\n        out ~ int.out\n    end\nend\n\n@named testcomp = ComponentWithLimInt()\nnothing #hide\n\nWhen we build this (useless) vertex model\n\nvm = VertexModel(testcomp, [:in], [:out])\n\nwe see the callback was generated and attached automatically.","category":"section"},{"location":"mtk_integration/#Model-Caching-(Experimental)","page":"ModelingToolkit Integration","title":"Model Caching (Experimental)","text":"When building large networks with many identical component types, the compilation of ModelingToolkit systems can become a performance bottleneck. NetworkDynamics provides an experimental caching mechanism to avoid redundant compilation of identical MTK models.","category":"section"},{"location":"mtk_integration/#NetworkDynamics.with_mtk_model_cache-mtk_integration","page":"ModelingToolkit Integration","title":"NetworkDynamics.with_mtk_model_cache","text":"NetworkDynamics.with_mtk_model_cache(f, usecache=true)\n\nExperimental: Enable caching of compiled MTK component functions during model construction.\n\nWhen building multiple VertexModel or EdgeModel components from ModelingToolkit systems, the expensive symbolic processing and code generation steps can be cached and reused. This function provides a convenient block syntax to enable caching temporarily.\n\nArguments\n\nf: A callable (typically a do block) that performs component model construction\nusecache=true: Optional boolean to enable/disable caching for this block\n\nUsage\n\nNetworkDynamics.with_mtk_model_cache() do\n    # code which generates and compiles mtk models\nend\n\nThe cache is automatically disabled when the block exits, ensuring clean state.\n\nWhen to Use\n\nThis optimization is beneficial when:\n\nBuilding multiple components from identical MTK systems (e.g., repeated vertex types)\nPerforming batch or exploratory model construction workflows\nConstructing components in parallel across multiple threads\n\nThe cache is thread safe, so you can safely build components concurrently.\n\nwarning: Experimental Feature\nThis caching mechanism is experimental and may change in future versions. The cache assumes that MTK equation processing is deterministic and does not change between calls.\n\nSee also: NetworkDynamics.mtk_cache_stats\n\n\n\n\n\n","category":"function"},{"location":"generated/getting_started_with_network_dynamics/#Getting-Started","page":"Getting Started","title":"Network Diffusion","text":"This example explains the use of the basic functions and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network.\n\nThis page will:\n\nwalk you through the theoretical background of a simple diffusion propagating in an undirected network\nexplain the network dynamics of the system\nexplain how to program them\n\nnote: Note\nAn Undirected Network is a network where all the connections between the nodes are bidirectional.\n\nThis example can be downloaded as a normal Julia script here.","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Theoretical-background","page":"Getting Started","title":"Theoretical background","text":"Diffusion processes appear in phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed entropy (the entropy being in the form of e.g. heat, charge or concentration). If we assume a thermal system, the temperature of a specific spot changes depending on the temperature gradient between the temperature of the spot itself and that of its neighborhood.\n\nWe will build a graph g with N nodes and an adjacency matrix A, where v = (v_1 dots v_n) is the vector of the (abstract) temperatures at each node i = 1 dots N. The rate of change of state v_i will be described by the difference between the temperature of the node and that of its neighbours. From the above we obtain the following ordinary differential equation:\n\ndot v_i = sum_j=1^N A_ji (v_j - v_i)\n\nThe sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.\n\nIf a node were to be disconnected from the rest of the network its state would never change, because its adjacency matrix would be A_ji = 0  forall j and hence dot v_i = 0. So because its state would remain unchanged the model will be comprised of nodes that have no internal dynamics. This means that the evolution of a node will depend only on its interaction with its neighbors. In NetworkDynamics.jl, interactions between a node and its neighbors are described using edge equations.\n\nIn order to bring this equation into the form required by NetworkDynamics.jl we need to split the dynamics into edge dynamics and vertex dynamics and bring them into the correct input-output formulation.","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Vertex-Dynamics:","page":"Getting Started","title":"Vertex Dynamics:","text":"All vertices have one internal state v, which is also the vertex output. It is the sum over all incoming edge flows connected to the vertex. This directly corresponds to the component model definition outlined in Mathematical Model:\n\nbeginaligned\ndot x^mathrmv = f^mathrm v(u^mathrm v sum_k^textincident y^mathrm e_k p^mathrm v t) = sum_k^mathrmincident y^mathrme_k \ny^mathrmv = g^mathrm v(u^mathrm v sum_k^textincident y^mathrm e_k p^mathrm v t) = x^mathrmv\nendaligned","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Edge-Dynamics:","page":"Getting Started","title":"Edge Dynamics:","text":"The edge dynamics on the other hand do not have any internal states. Thus we can define the edge output as the difference between the source and destination vertices:\n\nbeginaligned\ny^mathrm e_mathrmdst = g_mathrmdst^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t) = y^mathrm v_mathrmsrc - y^mathrm v_mathrmdst\ny^mathrm e_mathrmsrc = g_mathrmsrc^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t) = y^mathrm v_mathrmdst - y^mathrm v_mathrmsrc\nendaligned","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Modelling-dynamics-in-NetworkDynamics.jl","page":"Getting Started","title":"Modelling dynamics in NetworkDynamics.jl","text":"To model the vertex and edge dynamics we need to create a VertexModel and an EdgeModel, respectively.\n\nAs a first step we need to install Julia and the necessary packages (Graphs, NetworkDynamics, OrdinaryDiffEqTsit5, StableRNGs and Plots). Then we need to load them:\n\nusing Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing StableRNGs\nusing Plots\nnothing #hide","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Defining-the-EdgeModel","page":"Getting Started","title":"Defining the EdgeModel","text":"Then we must define the EdgeModel. To define it we use the function diffusionedge_g! which takes as inputs the current state of the edge e, its source vertex v_src, its destination vertex v_dst, a vector of parameters p and the time t. In order to comply with the syntax of NetworkDynamics.jl we must always define functions for edges with exactly these arguments. (In the case of this example, the values for p and t are not used since there are no parameters and there is no explicit time dependency in the system).\n\nAfter the function call the edge's output value e equals the difference between its source and its destination vertex     (i.e. the discrete gradient along that edge).\n\nnote: Note\ndiffusionedge_g! is called a mutating function, because it mutates (modifies) the edge state e (which is the first of its inputs). (In Julia, names of mutating functions end with an !.) We use mutating functions because they reduce the computational resource allocations and therefore, speed up the computations.\n\nfunction diffusionedge_g!(e_dst, v_src, v_dst, p, t)\n    # e_dst, v_src, v_dst are arrays, so we use the broadcasting operator .\n    e_dst .= v_src .- v_dst\n    nothing\nend\nnothing #hide\n\nNotably, this function only models g_mathrmdst. However we can wrap this single-sided output function in an AntiSymmetric output wrapper to construct the EdgeModel:\n\nnd_diffusion_edge = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow])","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Defining-the-VertexModel","page":"Getting Started","title":"Defining the VertexModel","text":"Next we need to define the VertexModel. For undirected graphs, the edgefunction! specifies the coupling from a source to a destination vertex. The contributions of the connected edges to a single vertex are \"aggregated\". By default, the aggregation is the summation of all incident edge states. The aggregated edge state is made available via the esum argument of the vertex function.\n\nfunction diffusionvertex_f!(dv, v, esum, p, t)\n    # dv, v and esum are arrays, so we use the broadcasting operator .\n    dv .= esum\n    nothing\nend\nnothing #hide\n\nJust like above, the input arguments v, esum, p, t are mandatory for the syntax of vertex functions. The additional     input dv corresponding to the derivative of the vertex' state is mandatory for vertices described by ordinary     differential equations. The outputs of the vertex function are just a subset of the internal states. Therefore, we     can use the StateMask helper function g = StateMask(1:1) to access them.\n\nnd_diffusion_vertex = VertexModel(; f=diffusionvertex_f!, g=StateMask(1:1), dim=1)","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Constructing-the-network","page":"Getting Started","title":"Constructing the network","text":"With the components defined, we can now define the topology and assemble the network dynamics.\n\nThe first step is to define the number of nodes the network is comprised of:\n\nN = 20 # number of nodes\nk = 4  # average degree distribution\nnothing #hide\n\nThen we define the network model. We will use the Barabási–Albert model which generates a scale-free random graph.\n\ng = barabasi_albert(N, k)\nnothing #hide\n\nWe then create the network of nodes and edges by using the constructor Network. It combines the component model with the topological information contained in the graph g and returns an Network compatible with the solvers of DifferentialEquations.jl.\n\nnd = Network(g, nd_diffusion_vertex, nd_diffusion_edge)\nrng = StableRNG(1)\n\nWe then generate random initial conditions\n\nx0 = randn(rng, N)\n\nWe then solve the diffusion problem on the time interval 0 2 with the Tsit5() algorithm, which is recommended by the authors of DifferentialEquations.jl for most non-stiff problems. We first create an ODEProblem:\n\node_prob = ODEProblem(nd, x0, (0.0, 2.0))\n\nAnd then solve the network using solve:\n\nsol = solve(ode_prob, Tsit5());\nnothing #hide\n\nWe plot the results using the plot command, which takes two parameters as input sol and idxs. The first parameter is the solved network sol. The second parameter is idxs, which provides a set of indices. We can use \"symbolic\" indices, which specify specific components and their symbols directly (see Symbolic Indexing for more details). In order to collect multiple indices we can use the helper function vidxs and eidxs, which help us collect all symbolic indices matching specific criteria. Here, we want to plot all vertex states from the network.\n\nplot(sol; idxs=vidxs(nd, :, :))\n\nIn the plot we see, how the individual vertex states evolve over time. We start at a random configuration, and then develop towards an equilibrium where all nodes have the same state, which is to be expected for a simple diffusion process.","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Two-Dimensional-Extension","page":"Getting Started","title":"Two Dimensional Extension","text":"To illustrate a very simple multi-dimensional case, we simulate two independent diffusions on an identical graph. The first diffusion uses the symbol x and is initiated with initial conditions drawn from the standard normal distribution N(01), while the second diffusion uses the symbol ϕ with squared standard normal initial conditions.\n\nThe symbols have to be passed with the keyword sym to VertexModel.\n\nOnce again we define the number of nodes and the type of network we want to generate:\n\nN = 10 # number of nodes\nk = 4  # average degrees distribution\ng = barabasi_albert(N, k)\n\nWe have two independent diffusions on the network, hence dim = 2. We now define the VertexModel and the EdgeModel\n\nnd_diffusion_vertex_2 = VertexModel(; f=diffusionvertex_f!, g=1:2, dim=2, sym=[:x, :ϕ])\nnd_diffusion_edge_2 = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow_x, :flow_ϕ])\nnd_2 = Network(g, nd_diffusion_vertex_2, nd_diffusion_edge_2)\n\nWe define the first diffusion as x ~ N(01)^mathrm2 and the second diffusion as ϕ ~ N(01). So the propagation of the diffusion from node 0 to node 2 is given by creating a vector:\n\nx0_2 = vec(transpose([randn(rng, N) .^ 2 randn(rng, N)]))\n\nWe then define the ODEProblem:\n\node_prob_2 = ODEProblem(nd_2, x0_2, (0.0, 3.0))\n\nThen solve the network using:\n\nsol_2 = solve(ode_prob_2, Tsit5());\nnothing #hide\n\nTo plot the evolution of variables ϕ_i over time we use the command:\n\nplot(sol_2; idxs=vidxs(nd_2, :, :x))\n\n[To write ϕ in the terminal type \\phi and press TAB]\n\nUsing the eidxs helper function we can also plot the evolution of the flow variables over time:\n\nplot(sol_2; idxs=eidxs(nd_2, :, :flow_x))\n\nAs expected, the flows are nonzero first and go towards zero as we reach the equilibrium point.","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Putting-it-all-together","page":"Getting Started","title":"Putting it all together","text":"using Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing StableRNGs\nusing Plots\nnothing #hide\n\nfunction diffusionedge_g!(e_dst, v_src, v_dst, p, t)\n    # e_dst, v_src, v_dst are arrays, so we use the broadcasting operator .\n    e_dst .= v_src .- v_dst\n    nothing\nend\nnothing #hide\n\nnd_diffusion_edge = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow])\n\nfunction diffusionvertex_f!(dv, v, esum, p, t)\n    # dv, v and esum are arrays, so we use the broadcasting operator .\n    dv .= esum\n    nothing\nend\nnothing #hide\n\nnd_diffusion_vertex = VertexModel(; f=diffusionvertex_f!, g=StateMask(1:1), dim=1)\n\nN = 20\nk = 4\ng = barabasi_albert(N, k)\nnothing #hide\n\nnd = Network(g, nd_diffusion_vertex, nd_diffusion_edge)\nrng = StableRNG(1)\nx0 = randn(rng, N)\node_prob = ODEProblem(nd, x0, (0.0, 2.0))\nsol = solve(ode_prob, Tsit5());\nnothing #hide\nplot(sol; idxs=vidxs(nd, :, :), fmt=:png)\nN = 10 #\nk = 4  #\ng = barabasi_albert(N, k)\nnd_diffusion_vertex_2 = VertexModel(; f=diffusionvertex_f!, g=1:2, dim=2, sym=[:x, :ϕ])\nnd_diffusion_edge_2 = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow_x, :flow_ϕ])\nnd_2 = Network(g, nd_diffusion_vertex_2, nd_diffusion_edge_2)\nx0_2 = vec(transpose([randn(rng, N) .^ 2 randn(rng, N)]))\node_prob_2 = ODEProblem(nd_2, x0_2, (0.0, 3.0))\nsol_2 = solve(ode_prob_2, Tsit5());\nplot(sol_2; idxs=vidxs(nd_2, :, :x), xlabel = \"x\", ylabel = \"nd_2\",)\nplot(sol_2; idxs=eidxs(nd_2, :, :flow_x))","category":"section"},{"location":"generated/getting_started_with_network_dynamics/#Appendix:-The-network-Laplacian-L","page":"Getting Started","title":"Appendix: The network Laplacian L","text":"The diffusion equation on a network can be rewritten as:\n\ndot v_i  = sum_j=1^N A_ji v_j - d_i v_i =  e_i^T A v - d_i v_i\n\nwhere d_i is the degree distribution of node i and e_i^T is the i-th standard basis vector.\n\nBy introducing the diagonal matrix D, that has the degree of node i in its i-th row and the Laplacian matrix L = D - A we arrive at:\n\ndot v = e_i^T(A - D) v\n\nand finally\n\ndot v = - L v\n\nThis is a linear system of ordinary differential equations (ODEs) and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of L.  For this reason L is an important construction in network science.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"external_inputs/#External-Inputs","page":"External Inputs","title":"External Inputs","text":"External inputs for components are way to pass signals between components outside of the network structure. The most common usecase for that are control systems: make your vertex i depend on some state of vertex j.\n\nIf used, this will essentially wides the number of received inputs of a component function. I.e. the baseline mathematical models for vertex models\n\nbeginaligned\nM^mathrm vfracmathrmdmathrmdtx^mathrm v = f^mathrm v(u^mathrm v i^mathrm v i^mathrmext p^mathrm v t)\ny^mathrm v = g^mathrm v(u^mathrm v i^mathrm v i^mathrmext p^mathrm v t)\nendaligned\n\nfᵥ(dxᵥ, xᵥ, e_aggr, ext, pᵥ, t)\ngᵥ(yᵥ, xᵥ, [e_aggr, ext,] pᵥ, t)\n\nand edge models\n\nbeginaligned\nM^mathrm efracmathrmdmathrmdtx^mathrm e = f^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst i^mathrmext p^mathrm e t)\ny^mathrm e_mathrmdst = g_mathrmdst^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst i^mathrmext p^mathrm e t)\ny^mathrm e_mathrmsrc = g_mathrmsrc^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst i^mathrmext p^mathrm e t)\nendaligned\n\nfₑ(dxₑ, xₑ, v_src, v_dst, ext, pₑ, t)\ngₑ(y_src, y_dst, xᵥ, [v_src, v_dst, ext,] pₑ, t)\n\nchange. You may still oomit the input section from g according to the different Feed Forward Behaviors. However you either have to use all inputs (including ext) or none.","category":"section"},{"location":"external_inputs/#Usage","page":"External Inputs","title":"Usage","text":"Vertex and Edge models with external inputs can be created using the extin keyword of the EdgeModel and VertexModel constructors.\n\nYou need to pass a vector of SymbolicIndices (VIndex and EIndex), e.g. \n\nVertexModel(... , extin=[VIndex(12,:x), VIndex(9, :x)], ...)\n\nmeans your vertex receives a 2 dimensional external input vector with the states x of vertices 12 and 9. See below for hands on example.","category":"section"},{"location":"external_inputs/#Limitations","page":"External Inputs","title":"Limitations","text":"There are some limitations in place. You can only reference states (i.e. things that appear in xᵥ or xₑ of some component model) or outputs of non-feed-forward components, i.e. states yᵥ or yₑ of some component model which does not have feed forward behavior in their g function.","category":"section"},{"location":"external_inputs/#Example","page":"External Inputs","title":"Example","text":"As an example system, we'll consider two capacitors with a resistor between them. Vertex 1 v1 has a controllable current source.  Using a PI controller for the current source, it tries to keep the voltage at the  second vertex stable under the disturbance of some time periodic current sind at v2.\n\n\n                  v1    Resistor   v2\nPI controlled   ─→─o─←────MMM────→─o─→─ time dependent \ncurrent source     ┴               ┴    current sink\n                   ┬               ┬\n                   ⏚               ⏚\n\nThe example will be implemented 2 times: in plain NetworkDynamcics and using MTK.","category":"section"},{"location":"external_inputs/#Plain-NetworkDynamics","page":"External Inputs","title":"Plain NetworkDynamics","text":"First we define the resistor:\n\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\n\nfunction resistor_g(idst, vsrc, vdst, (R,), t)\n    idst[1] = (vsrc[1] - vdst[1])/R\nend\nresistor = EdgeModel(g=AntiSymmetric(resistor_g), \n                     outsym=:i, insym=:v, psym=:R=>0.1, \n                     src=:source, dst=:load, name=:resistor)\n\nThen we define the \"load\" vertex with sinusoidial load profile:\n\nfunction f_load(dv, v, iin, (C,), t)\n    dv[1] = 1/C*(iin[1] - (1 + 0.1*sin(t)))\nend\nload = VertexModel(f=f_load, g=1, \n                   sym=:V=>0.5, insym=:i, psym=:C=>1,\n                   vidx=2, name=:load)\n\nLastly, we define the \"source\" vertex\n\nfunction f_source(dv, v, iin, extin, (C,Vref,Ki,Kp), t)\n    Δ = Vref - extin[1]      # tracking error\n    dv[2] = Δ                # integrator state of PI\n    i_inj = Kp*Δ + Ki*v[2]   # controller output\n    dv[1] = 1/C*(iin[1] + i_inj)\nend\nsource = VertexModel(f=f_source, g=1, \n                     sym=[:V=>0.5,:ξ=>0], insym=:i, \n                     psym=[:C=>1, :Vref=>1, :Ki=>0.5, :Kp=>10],\n                     extin=[VIndex(:load, :V)], \n                     vidx=1, name=:source)\n\nThen we can create the network and simulate:\n\nnw = Network([source, load], [resistor])\nu0 = NWState(nw) # everything has default values\nprob = ODEProblem(nw, uflat(u0), (0,100), pflat(u0))\nsol = solve(prob, Tsit5())\n\nfig, ax, p = lines(sol, idxs=VIndex(:load, :V), label=\"Voltage @ load\");\nlines!(ax, sol, idxs=VPIndex(:source, :Vref), label=\"Reference\", color=Cycled(2));\naxislegend(ax; position=:rb);\nfig # hide","category":"section"},{"location":"external_inputs/#MTK-Models","page":"External Inputs","title":"MTK Models","text":"First we define the resistor:\n\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\nusing CairoMakie\n\n@mtkmodel Resistor begin\n    @variables begin\n        i(t), [description=\"Current at dst end\"]\n        V_src(t), [description=\"Voltage at src end\"]\n        V_dst(t), [description=\"Voltage at dst end\"]\n    end\n    @parameters begin\n        R=0.1, [description=\"Resistance\"]\n    end\n    @equations begin\n        i ~ (V_src - V_dst)/R\n    end\nend\n@named resistor = Resistor()\nresistor_edge = EdgeModel(resistor, [:V_src], [:V_dst], AntiSymmetric([:i]); src=:load, dst=:source)\n\nThen we define the \"load\" vertex with sinusoidial load profile:\n\n@mtkmodel Load begin\n    @variables begin\n        V(t)=0.5, [description=\"Voltage\"]\n        i_load(t), [description=\"Load current\"]\n        i_grid(t), [description=\"Current from grid\"]\n    end\n    @parameters begin\n        C=1, [description=\"Capacitance\"]\n    end\n    @equations begin\n        i_load ~ 1 + 0.1*sin(t)\n        Dt(V) ~ 1/C*(i_grid - i_load)\n    end\nend\n@named load = Load()\nload_vertex = VertexModel(load, [:i_grid], [:V]; vidx=2)\n\nLastly, we define the \"source\" vertex\n\n@mtkmodel Source begin\n    @variables begin\n        V(t)=0.5, [description=\"Voltage\"]\n        ξ(t)=0, [description=\"Integrator state\"]\n        i_grid(t), [description=\"Current from grid\"]\n        i_source(t), [description=\"Current from source\"]\n        Δ(t), [description=\"Tracking Error\"]\n        V_load(t), [description=\"Voltage at load\"]\n    end\n    @parameters begin\n        C=1, [description=\"Capacitance\"]\n        Vref=1, [description=\"Reference voltage\"]\n        Ki=0.5, [description=\"Integral gain\"]\n        Kp=10, [description=\"Proportional gain\"]\n    end\n    @equations begin\n        Δ ~ Vref - V_load\n        Dt(ξ) ~ Δ\n        i_source ~ Kp*Δ + Ki*ξ\n        Dt(V) ~ 1/C*(i_grid + i_source)\n    end\nend\n@named source = Source()\nsource_vertex = VertexModel(source, [:i_grid], [:V]; \n                            extin=[:V_load => VIndex(:load, :V)], vidx=1)\n\nThen we can create the network and simulate:\n\nnw = Network([source_vertex, load_vertex], [resistor_edge])\nu0 = NWState(nw) # everything has default values\nprob = ODEProblem(nw, uflat(u0), (0,100), pflat(u0))\nsol = solve(prob, Tsit5())\n\nlet\n    fig = Figure();\n    ax1 = Axis(fig[1,1]);\n    lines!(ax1, sol, idxs=VIndex(:load, :V), label=\"Voltage @ load\");\n    lines!(ax1, sol, idxs=VPIndex(:source, :Vref), label=\"Reference\", color=Cycled(2));\n    axislegend(ax1; position=:rb);\n    ax2 = Axis(fig[2,1]);\n    lines!(ax2, sol, idxs=VIndex(:load, :i_load), label=\"load current\");\n    lines!(ax2, sol, idxs=VIndex(:source, :i_source), label=\"source current\", color=Cycled(2));\n    axislegend(ax2);\n    fig\nend\n\nUsing MTK for modeling, we can also inspect the currents i_load and i_source the MTK interface preserves the Observables.","category":"section"},{"location":"generated/stress_on_truss/#Stress-on-Truss","page":"Stress on Truss","title":"Stress on Truss","text":"In this exampe we'll simulate the time evolution of a truss structure consisting of joints and stiff springs. This example can be dowloaded as a normal Julia script here.\n\n(Image: truss animation)\n\nThe mathematical model is quite simple: the vertices are point masses with positions x and y and velocities v_x and v_y. For simplicity, we add some damping to the nodal motion based on the velocity.\n\nbeginaligned\ndotx = v_x\ndoty = v_y\ndotv_x = frac1Mleft(sum F_x - γv_xright)\ndotv_y = frac1Mleft(sum F_y - γv_yright) - g\nendaligned\n\nThe vertices cannot absorb any torque, so the beams only exert forces in the direction of the beam.\n\nF = Kcdot(L - Δd)\n\nwhere L is the nominal lenth and Δd is the actual length of the beam.\n\nWe start by loading the necessary packages.\n\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing Graphs\nusing GraphMakie\nusing LinearAlgebra: norm\nusing Printf\nusing CairoMakie\nCairoMakie.activate!()","category":"section"},{"location":"generated/stress_on_truss/#Definition-of-the-dynamical-system","page":"Stress on Truss","title":"Definition of the dynamical system","text":"We need 3 models:\n\na fixed vertex which cannot change its position,\na free vertex which can move, and\na beam which connects two vertices.\n\nfunction fixed_g(pos, x, p, t)\n    pos .= p\nend\nvertex_fix = VertexModel(g=fixed_g, psym=[:xfix, :yfix], outsym=[:x, :y], ff=NoFeedForward())\n\nHere we need to specify the ff keyword manually, because NetworkDynamics cannot distinguish between g(out, x, p, t)  (NoFeedForwarwd) and g(out, in, p, t) (PureFeedForward()) and guesses the latter when mathrmdim(x)=0.\n\nfunction free_f(dx, x, Fsum, (M, γ, g), t)\n    v = view(x, 1:2)\n    dx[1:2] .= (Fsum .- γ .* v) ./ M\n    dx[2] -= g\n    dx[3:4] .= v\n    nothing\nend\nvertex_free = VertexModel(f=free_f, g=3:4, sym=[:vx=>0, :vy=>0, :x, :y],\n                             psym=[:M=>10, :γ=>200, :g=>9.81], insym=[:Fx, :Fy])\n\nFor the edge, we want to do something special. Later on, we want to color the edges according to the force they exert. Therefore, are interested in the absolut force rather than just the force vector. NetworkDynamics allows you to  define so called Observed functions, which can recover additional states, so called observed, after the simulations. We can use this mechanis, to define a \"recipe\" for calculating the beam force based on the inputs (nodal positions) and  the beam parameters.\n\nfunction edge_g!(F, pos_src, pos_dst, (K, L), t)\n    dx = pos_dst[1] - pos_src[1]\n    dy = pos_dst[2] - pos_src[2]\n    d = sqrt(dx^2 + dy^2)\n    Fabs = K * (L - d)\n    F[1] = Fabs * dx / d\n    F[2] = Fabs * dy / d\n    nothing\nend\nfunction observedf(obsout, u, pos_src, pos_dst, (K, L), t)\n    dx = pos_dst[1] .- pos_src[1]\n    dy = pos_dst[2] .- pos_src[2]\n    d = sqrt(dx^2 + dy^2)\n    obsout[1] = K * (L - d)\n    nothing\nend\nbeam = EdgeModel(g=AntiSymmetric(edge_g!), psym=[:K=>0.5e6, :L], outsym=[:Fx, :Fy], obsf=observedf, obssym=[:Fabs])\n\nWith the models define we can set up graph topology and initial positions.\n\nN = 5\ndx = 1.0\nshift = 0.2\ng = SimpleGraph(2*N + 1)\nfor i in 1:N\n    add_edge!(g, i, i+N); add_edge!(g, i, i+N)\n    if i < N\n        add_edge!(g, i+1, i+N); add_edge!(g, i, i+1); add_edge!(g, i+N, i+N+1)\n    end\nend\nadd_edge!(g, 2N, 2N+1)\npos0 = zeros(Point2f, 2N + 1)\npos0[1:N] = [Point((i-1)dx,0) for i in 1:N]\npos0[N+1:2*N] = [Point(i*dx + shift, 1) for i in 1:N]\npos0[2N+1] = Point(N*dx + 1, -1)\nfixed = [1,4] # set fixed vertices\nnothing #hide\n\nNow can collect the vertex models and construct the Network object.\n\nverts = VertexModel[vertex_free for i in 1:nv(g)]\nfor i in fixed\n    verts[i] = vertex_fix # use the fixed vertex for the fixed points\nend\nnw = Network(g, verts, beam)\n\nIn order to simulate the system we need to initialize the state and parameter vectors. Some states and parameters are shared between all vertices/edges. Those have been allready set in their constructors. The free symbols are\n\nx and y for the position of the free vertices,\nxfix and yfix for the position of the fixed vertices,\nL for the nominal length of the beams.\n\ns = NWState(nw)\n# set x/y and xfix/yfix\nfor i in eachindex(pos0, verts)\n    if i in fixed\n        s.p.v[i, :xfix] = pos0[i][1]\n        s.p.v[i, :yfix] = pos0[i][2]\n    else\n        s.v[i, :x] = pos0[i][1]\n        s.v[i, :y] = pos0[i][2]\n    end\nend\n# set L for edges\nfor (i,e) in enumerate(edges(g))\n    s.p.e[i, :L] = norm(pos0[src(e)] - pos0[dst(e)])\nend\nnothing #hide\n\nLastly there is a special vertex at the end of the truss which has a higher mass and reduced damping.\n\ns.p.v[11, :M] = 200\ns.p.v[11, :γ] = 100\nnothing #hide\n\nNow we have everything ready to build the ODEProblem and simulate the system.\n\ntspan = (0.0, 12.0)\nprob = ODEProblem(nw, s, tspan)\nsol  = solve(prob, Tsit5())\nnothing #hide","category":"section"},{"location":"generated/stress_on_truss/#Plot-the-solution","page":"Stress on Truss","title":"Plot the solution","text":"Plotting trajectories of points is kinda boring. So instead we're going to use GraphMakie.jl to create a animation of the timeseries.\n\nfig = Figure(size=(1000,550));\nfig[1,1] = title = Label(fig, \"Stress on truss\", fontsize=30)\ntitle.tellwidth = false\n\nfig[2,1] = ax = Axis(fig)\nax.aspect = DataAspect();\nhidespines!(ax); # no borders\nhidedecorations!(ax); # no grid, axis, ...\nlimits!(ax, -0.1, pos0[end][1]+0.3, pos0[end][2]-0.5, 1.15) # axis limits to show full plot\n\n# get the maximum force during the simulation to get the color scale\n# It is only possible to access `:Fabs` directly becaus we've define the observable function for it!\n(fmin, fmax) = 0.3 .* extrema(Iterators.flatten(sol(sol.t, idxs=eidxs(nw, :, :Fabs))))\np = graphplot!(ax, g;\n               edge_width = 4.0,\n               node_size = 3*sqrt.(try s.p.v[i, :M] catch; 10.0 end for i in 1:nv(g)),\n               nlabels = [i in fixed ? \"Δ\" : \"\" for i in 1:nv(g)],\n               nlabels_align = (:center,:top),\n               nlabels_fontsize = 30,\n               elabels = [\"edge $i\" for i in 1:ne(g)],\n               elabels_side = Dict(ne(g)  => :right),\n               edge_color = [0.0 for i in 1:ne(g)],\n               edge_attr = (colorrange=(fmin,fmax),\n                          colormap=:diverging_bkr_55_10_c35_n256))\n\n# draw colorbar\nfig[3,1] = cb = Colorbar(fig, get_edge_plot(p), label = \"Axial force\", vertical=false)\n\nT = tspan[2]\nfps = 30\ntrange = range(0.0, sol.t[end], length=Int(T * fps))\nrecord(fig, \"truss.mp4\", trange; framerate=fps) do t\n    title.text = @sprintf \"Stress on truss (t = %.2f )\" t\n    s_at_t = NWState(sol, t)\n    for i in eachindex(pos0)\n        p[:node_pos][][i] = (s_at_t.v[i, :x], s_at_t.v[i, :y])\n    end\n    p[:node_pos][] = p[:node_pos][]\n    load = s_at_t.e[:, :Fabs]\n    p.edge_color[] = load\n    p.elabels = [@sprintf(\"%.0f\", l) for l in load]\n    fig\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"sparsity_detection/#Sparsity-Detection","page":"Sparsity Detection","title":"Sparsity Detection","text":"NetworkDynamics.jl can automatically detect and exploit the sparsity structure of the Jacobian matrix to significantly improve the performance of ODE solvers. This feature uses SparseConnectivityTracer.jl to analyze the network's dynamics and create a sparse Jacobian prototype that modern solvers can use for more efficient linear algebra operations.\n\nThe sparsity detection is particularly beneficial for:\n\nLarge networks where the Jacobian matrix is sparse\nStiff systems that require implicit solvers\nNetworks with complex component interactions\nComponents with conditional statements that complicate automatic differentiation","category":"section"},{"location":"sparsity_detection/#Core-Function","page":"Sparsity Detection","title":"Core Function","text":"The main interface is the get_jac_prototype function, which takes a Network object as an argument and returns a sparse boolean matrix containing the sparsity pattern.\n\nYou can store the sparsity pattern directly in the network, which will then be picked up by the ODEProblem and ODEFunction constructors.\n\nset_jac_prototype!(nw; kwargs_for_get_jac_prototype...)\nprob = ODEProblem(nw, x0, (0.0, 1.0), p0)  # automatically uses stored prototype\n\nThe get_jac_prototype function will operate on batches of identical components. If the user provided component functions are not SCT compatible, it'll first try to resolve if..else..end statements in MTK-generated code and fall back to dense component functions. Even the dense component fallback can lead to a substantial speedup because most of the sparsity stems from the Network sparsity rather than the component sparsity.","category":"section"},{"location":"sparsity_detection/#Example:-Handling-Conditional-Statements","page":"Sparsity Detection","title":"Example: Handling Conditional Statements","text":"A key feature of NetworkDynamics.jl's sparsity detection is the ability to automatically handle conditional statements in MTK component functions.\n\nThe conditional if...else...end statements generated in the codegen phase will be replaced by equivalent ifelse(..,..,..) statements which can be handled by SCT.\n\ndetails: Setup code\nusing NetworkDynamics, ModelingToolkit, Graphs\nusing SparseArrays, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve, NonlinearSolve\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nnothing #hide\n\n# Define a component with conditional logic\n@mtkmodel ValveModel begin\n    @variables begin\n        p_src(t), [description=\"source pressure\"]\n        p_dst(t), [description=\"destination pressure\"]\n        q(t), [description=\"flow through valve\"]\n    end\n    @parameters begin\n        K=1, [description=\"conductance\"]\n        active=1, [description=\"valve state\"]\n    end\n    @equations begin\n        q ~ ifelse(active > 0, K * (p_src - p_dst), 0)\n    end\nend\n\n@mtkmodel NodeModel begin\n    @variables begin\n        p(t)=1, [description=\"pressure\"]\n        q_nw(t), [description=\"network flow\"]\n    end\n    @parameters begin\n        C=1, [description=\"capacitance\"]\n        q_ext, [description=\"external flow\"]\n    end\n    @equations begin\n        C*Dt(p) ~ q_ext + q_nw\n    end\nend\nnothing # hide\n\n# Create network\n@named valve = ValveModel()\n@named node = NodeModel()\n\ng = wheel_graph(10)\nv = VertexModel(node, [:q_nw], [:p])\ne = EdgeModel(valve, [:p_src], [:p_dst], AntiSymmetric([:q]))\n\nnw = Network(g, v, e)\n\n# This works by removing conditionals\njac_prototype = get_jac_prototype(nw)\n\n# Store the prototype directly in the network\nset_jac_prototype!(nw, jac_prototype)","category":"section"},{"location":"sparsity_detection/#Performance-Benefits","page":"Sparsity Detection","title":"Performance Benefits","text":"Using sparsity detection can significantly improve solver performance, especially for large networks and stiff systems:\n\nusing OrdinaryDiffEqRosenbrock, Chairmarks\n\n# Create a large sparse network for benchmarking\ng_large = grid([20, 20])  # 400 nodes in a 2D grid (very sparse)\nnw_large = Network(g_large, v, e)\n\n# Setup initial conditions and parameters\nusing Random # hide\nRandom.seed!(42) # hide\ns0 = NWState(nw_large)\ns0.v[:, :p] .= randn(400)  # random initial pressures\n\np0 = NWParameter(nw_large)\np0.v[:, :q_ext] .= randn(400)  # small external flow\n\nnothing #hide\n\nThe network is now ready for benchmarking. Let's first time the solution without sparsity detection:\n\n# Without sparsity detection (dense Jacobian)\nprob_dense = ODEProblem(nw_large, uflat(s0), (0.0, 1.0), pflat(p0))\n@b solve($prob_dense, Rodas5P()) evals=1\n\nNow let's enable sparsity detection:\n\njac = get_jac_prototype(nw_large)\n\nThe pattern already shows that the Jacobian is really sparse due to the sparse network connections.\n\nset_jac_prototype!(nw_large, jac)\n\nNow we can benchmark the sparse version:\n\n# Solve with sparsity detection\nprob_sparse = ODEProblem(nw_large, uflat(s0), (0.0, 1.0), pflat(p0))\n@b solve($prob_sparse, Rodas5P(linsolve=KLUFactorization())) evals=1\n\nFor this network, we see a substantial speedup due to the sparse solver!","category":"section"},{"location":"generated/directed_and_weighted_graphs/#Neurodynamic-model-of-synchronization-in-the-human-brain","page":"Directed and Weighted Graphs","title":"Neurodynamic model of synchronization in the human brain","text":"This example can be dowloaded as a normal Julia script here.","category":"section"},{"location":"generated/directed_and_weighted_graphs/#Topics-covered-in-this-tutorial-include:","page":"Directed and Weighted Graphs","title":"Topics covered in this tutorial include:","text":"constructing a directed, weighted graph from data\nsome useful macros\nparameter handling\nstiff equations","category":"section"},{"location":"generated/directed_and_weighted_graphs/#The-FitzHugh-Nagumo-model","page":"Directed and Weighted Graphs","title":"The FitzHugh-Nagumo model","text":"Dynamics of spiking neurons have been described in a simplified manner by the FitzHugh-Nagumo model.\n\nbeginaligned\nvarepsilon dot u   =  u - fracu^33 - v \ndot v  =  u + a\nendaligned\n\nHere u is a fast, excitatory variable corresponding to the membrane potential and v is a slower, inhibitory varibale. varepsilon is a parameter separating these time-scales, and a is a control parameter.\n\nIn simplified models of the brain, such relaxation oscillators may be used to model individual neurons, clusters of neurons or even larger areas in the brain. The FitzHugh-Nagumo model has been widely used for studying synchronization in neuronal activity, which in turn has been connected to physiological phenomena such as epileptic seizures.","category":"section"},{"location":"generated/directed_and_weighted_graphs/#Coupling-relaxation-oscillators","page":"Directed and Weighted Graphs","title":"Coupling relaxation oscillators","text":"While different coupling schemes for FitzHugh-Nagumo oscillators have been proposed, in this tutorial we focus on coupling of the excitatory variables via electrical gap junctions, as described by the following system of equations.\n\nbeginaligned\nvarepsilon dot u_i  =  u_i - fracu_i^33 - v_i - sigma sum_j=1^N G_ij(u_i - u_j) \ndot v_i  =   u_i + a\nendaligned\n\nThis is a simple diffusive coupling mediated by the difference between activation potentials in pairs of neurons. A similar coupling term was introduced in the \"getting started\" tutorial.","category":"section"},{"location":"generated/directed_and_weighted_graphs/#The-network-topology-a-brain-atlas","page":"Directed and Weighted Graphs","title":"The network topology - a brain atlas","text":"In the following we will use a directed and weighted network encoding the strength and directionality of coupling between 90 different areas of the brain [Nathalie Tzourio-Mazoyer et al., 2002, Neuroimage].\n\nThe network weight matrix is given as a text file containing 90 lines with 90 numbers representing the coupling strength and separated by commas ,. The data can be conveniently read into a matrix with the DelimitedFiles module.\n\nusing DelimitedFiles\nusing SimpleWeightedGraphs, Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing OrdinaryDiffEqSDIRK\nusing StableRNGs\nusing Plots\n\n# adjust the load path for your filesystem!\nfile = joinpath(pkgdir(NetworkDynamics), \"docs\", \"examples\", \"Norm_G_DTI.txt\")\nG = readdlm(file, ',', Float64, '\\n')\nnothing #hide\n\nThe data structure for directed, weighted graphs is provided by the package SimpleWeightedGraphs.jl which is based on Graphs.jl.\n\n# First we construct a weighted, directed graph\ng_weighted = SimpleWeightedDiGraph(G)\n\n# For later use we extract the edge.weight attributes\n# . is the broadcasting operator and gets the attribute :weight for every edge\nedge_weights = getfield.(collect(edges(g_weighted)), :weight)\n\n# we promote the g_weighted graph as a directed graph (weights of the edges are included in parameters)\ng_directed = SimpleDiGraph(g_weighted)\n\nnothing #hide","category":"section"},{"location":"generated/directed_and_weighted_graphs/#Setting-up-the-ODEProblem","page":"Directed and Weighted Graphs","title":"Setting up the ODEProblem","text":"Defining the VertexModel and EdgeModel is similar to the example before. The macro Base.@propagate_inbounds tells the compiler to inline the function and propagate the inbounds context. For more details see the julia documentation.\n\nBase.@propagate_inbounds function fhn_electrical_vertex!(dv, v, esum, p, t)\n    (a, ϵ) = p\n    dv[1] = v[1] - v[1]^3 / 3 - v[2] + esum[1]\n    dv[2] = (v[1] - a) * ϵ\n    nothing\nend\nvertex = VertexModel(f=fhn_electrical_vertex!, g=1, sym=[:u, :v], psym=[:a=>0.5, :ϵ=>0.05])\n\nBase.@propagate_inbounds function electrical_edge!(e, v_s, v_d, (w, σ), t)\n    e[1] = w * (v_s[1] - v_d[1]) * σ\n    nothing\nend\nelectricaledge = EdgeModel(g=Directed(electrical_edge!), outdim=1, psym=[:weight, :σ=>0.5])\n\nfhn_network! = Network(g_directed, vertex, electricaledge)\n\nSince this system is a directed one with thus directed edges, the keyword argument coupling is used to set the coupling of the edges to Directed().","category":"section"},{"location":"generated/directed_and_weighted_graphs/#Parameter-handling","page":"Directed and Weighted Graphs","title":"Parameter handling","text":"Some of the parameters have been declared with default values. Those default values will be used when creating the NWParameter object. We can use getindex on the parameter objects to set the missing weight values.\n\np = NWParameter(fhn_network!)\np.e[1:ne(g_directed), :weight] = edge_weights\nnothing #hide\n\nThe initial conditions could be created similarly to the parameters as an indexable NWState obejct. Since we chose a random initial condition we initialize the flat array directly:\n\nx0 = randn(StableRNG(42), dim(fhn_network!)) * 5\n\nnothing #hide","category":"section"},{"location":"generated/directed_and_weighted_graphs/#Solving-the-system","page":"Directed and Weighted Graphs","title":"Solving the system","text":"Now we are ready to create an ODEProblem. Since for some choices of parameters the FitzHugh-Nagumo model is stiff (i.e. numerically unstable), we use a solver with automated stiffness detection. Such a solver switches to a more stable solver only when the solution enters a region of phase space where the problem is numerically unstable. In this case we use Tsit5 and switch to TRBDF2 when necessary. AutoTsit5 is the switching version of the Tsit5 algorithm.\n\nNot that we call pflat on the NWParameter object to get the flat array of parameters.\n\ntspan = (0.0, 200.0)\nprob  = ODEProblem(fhn_network!, x0, tspan, pflat(p))\nsol = solve(prob, AutoTsit5(TRBDF2()));\nnothing #hide","category":"section"},{"location":"generated/directed_and_weighted_graphs/#Plotting","page":"Directed and Weighted Graphs","title":"Plotting","text":"The plot of the excitatory variables shows that they synchronize for this choice of parameters.\n\nplot(sol; idxs=vidxs(fhn_network!, :, :u), legend=false, ylim=(-5, 5), fmt=:png)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/init_tutorial/#init-tutorial","page":"Initialization","title":"Tutorial on Stepwise Initialization of a Complex Model","text":"This example demonstrates how to initialize a complex network model with both static and dynamic components. The models are closely related to the ones used in the gas network example, but greatly simplified for the sake of this tutorial. We'll create a gas network model with three nodes and pipes connecting them, and show how to:\n\nCreate static models for initialization\nFind a steady-state solution\nCreate corresponding dynamic models\nInitialize the dynamic models with the steady-state solution\nSimulate the system with dynamic behavior\n\nThis script can be downloaded as a normal Julia script here.\n\nFirst, let's import the necessary packages:\n\nusing NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\nnothing #hide","category":"section"},{"location":"generated/init_tutorial/#Node-Models","page":"Initialization","title":"Node Models","text":"We'll start by defining our node models using ModelingToolkit. First, let's create a template for common states and equations in all gas nodes:\n\n@mtkmodel GasNode begin\n    @variables begin\n        p(t), [description=\"Pressure\"] # node output\n        q̃_nw(t), [description=\"aggregated flow from pipes into node\"] # node input\n        q̃_inj(t), [description=\"flow injected into the network\"]\n    end\n    @equations begin\n        q̃_inj ~ -q̃_nw\n    end\nend\nnothing #hide\n\nNow we'll define three specific node types:\n\nA) A constant pressure node that forces pressure to maintain a specific value\n\n@mtkmodel ConstantPressureNode begin\n    @extend GasNode()\n    @parameters begin\n        p_set, [description=\"Constant pressure setpoint\"]\n    end\n    @equations begin\n        p ~ p_set\n    end\nend\nnothing #hide\n\nB) A static prosumer node which forces a certain flow\n\nnote: Fully Implicit Output\nWe need to use implicit_output(p) to handle the fully implicit pressure output. See fully implicit outputs for details.\n\n@mtkmodel StaticProsumerNode begin\n    @extend GasNode()\n    @parameters begin\n        q̃_prosumer, [description=\"flow injected by prosumer\"]\n    end\n    @equations begin\n        -q̃_nw ~ q̃_prosumer + implicit_output(p)\n    end\nend\nnothing #hide\n\nC) A dynamic prosumer node with compliance, which introduces dynamic behavior to the pressure state\n\n@mtkmodel DynamicProsumerNode begin\n    @extend GasNode()\n    @parameters begin\n        q̃_prosumer, [description=\"flow injected by prosumer\"]\n        C=0.1, [description=\"Compliance\"]\n    end\n    @equations begin\n        C*D(p) ~ q̃_prosumer + q̃_nw\n    end\nend\nnothing #hide\n\nD) A pressure control node that tries to maintain a set pressure by adjusting its injection\n\n@mtkmodel PressureControlNode begin\n    @extend GasNode()\n    @parameters begin\n        p_set, [description=\"Pressure setpoint\", guess=1]\n        K_p=1, [description=\"Proportional gain\"]\n        K_i=1, [description=\"Integral gain\"]\n        C=0.1, [description=\"Compliance\"]\n    end\n    @variables begin\n        Δp(t), [description=\"Pressure error\"]\n        ξ(t), [description=\"Integral state\", guess=0]\n        q̃_prosumer(t), [description=\"flow injected by producer\"]\n    end\n    @equations begin\n        Δp ~ p_set - p\n        D(ξ) ~ Δp\n        q̃_prosumer ~ K_p*Δp + K_i*ξ\n        C*D(p) ~ q̃_prosumer + q̃_nw\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/init_tutorial/#Edge-Models","page":"Initialization","title":"Edge Models","text":"Now we'll define our edge models, starting with a template for the pipe:\n\n@mtkmodel GasPipe begin\n    @variables begin\n        q̃(t), [description=\"flow through pipe\"] #output\n        p_src(t), [description=\"pressure at start of pipe\"] #input\n        p_dst(t), [description=\"pressure at end of pipe\"] #input\n    end\nend\nnothing #hide\n\nNext, we define a dynamic pipe with inertia (a simple delayed model):\n\n@mtkmodel DynamicPipe begin\n    @extend GasPipe()\n    @parameters begin\n        R=0.1, [description=\"Resistance\"]\n        M=0.1, [description=\"Inertia\"]\n    end\n    @equations begin\n        M*D(q̃) ~ (p_src - p_dst)/R - q̃ # some simple delayed model\n    end\nend\nnothing #hide\n\nAnd finally, a quasistatic pipe model for initialization purposes. This model equals the dynamic model at steady state, making it ideal for finding initial conditions:\n\n@mtkmodel QuasistaticPipe begin\n    @extend GasPipe()\n    @parameters begin\n        R=0.1, [description=\"Resistance\"]\n    end\n    @equations begin\n        q̃ ~ (p_src - p_dst)/R\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/init_tutorial/#Defining-a-Static-Model-for-Initialization","page":"Initialization","title":"Defining a Static Model for Initialization","text":"Our first step is to define a static model that we'll use to find the steady-state solution. This is a crucial step for initializing complex dynamic models.\n\nStep 1: Define all the components of our static model First, node 1 is our producer which will later be a controlled producer. For initialization, we use a static model:\n\n@named v1_mod_static = ConstantPressureNode(p_set=1)\nv1_static = VertexModel(v1_mod_static, [:q̃_nw], [:p], vidx=1)\n\n# Nodes 2 and 3 are consumers. For them, we'll use static prosumer models:\n@named v2_mod_static = StaticProsumerNode(q̃_prosumer=-0.6) # consumer\nv2_static = VertexModel(v2_mod_static, [:q̃_nw], [:p], vidx=2)\n\n@named v3_mod_static = StaticProsumerNode(q̃_prosumer=-0.4) # consumer\nv3_static = VertexModel(v3_mod_static, [:q̃_nw], [:p], vidx=3)\nnothing #hide\n\nNow we define the static pipe models connecting our nodes:\n\n@named p_mod_static = QuasistaticPipe()\np12_static = EdgeModel(p_mod_static, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=2)\np13_static = EdgeModel(p_mod_static, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=3)\np23_static = EdgeModel(p_mod_static, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=2, dst=3)\nnothing #hide\n\nAssemble all components into a static network:\n\nnw_static = Network([v1_static, v2_static, v3_static], [p12_static, p13_static, p23_static])\n\nCreate an initial guess for the steady state and modify it with reasonable values:\n\nu_static_guess = NWState(nw_static)\nu_static_guess.v[2, :p] = 1.0\nu_static_guess.v[3, :p] = 1.0\nnothing #hide\n\nFind the steady-state solution using our initial guess:\n\nu_static = find_fixpoint(nw_static, u_static_guess)","category":"section"},{"location":"generated/init_tutorial/#Defining-a-Dynamic-Model","page":"Initialization","title":"Defining a Dynamic Model","text":"Now we'll define our dynamic model using more complex components:\n\n@named v1_mod_dyn = PressureControlNode()\nv1_dyn = VertexModel(v1_mod_dyn, [:q̃_nw], [:p], vidx=1)\n\n@named v2_mod_dyn = DynamicProsumerNode(q̃_prosumer=-0.6)\nv2_dyn = VertexModel(v2_mod_dyn, [:q̃_nw], [:p], vidx=2)\n\n@named v3_mod_dyn = DynamicProsumerNode(q̃_prosumer=-0.4)\nv3_dyn = VertexModel(v3_mod_dyn, [:q̃_nw], [:p], vidx=3)\nnothing #hide\n\nCreate dynamic pipe models with inertia:\n\n@named p_mod_dyn = DynamicPipe()\np12_dyn = EdgeModel(p_mod_dyn, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=2)\np13_dyn = EdgeModel(p_mod_dyn, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=3)\np23_dyn = EdgeModel(p_mod_dyn, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=2, dst=3)\nnothing #hide\n\nAssemble the dynamic network:\n\nnw_dyn = Network([v1_dyn, v2_dyn, v3_dyn], [p12_dyn, p13_dyn, p23_dyn])","category":"section"},{"location":"generated/init_tutorial/#Initializing-the-Dynamic-Model-with-the-Static-Solution","page":"Initialization","title":"Initializing the Dynamic Model with the Static Solution","text":"Now comes the important part: we need to initialize the dynamic model with the results from the static model. To do so, we need to make use of two functions:\n\ninterface_values: Extracts all interface values (inputs and outputs) from a network state\ninitialize_componentwise!: Initializes all components in a network one by one\n\nFirst, we extract all interface values from our static solution:\n\ninterface_vals = interface_values(u_static)\n\nNext, we initialize the dynamic model using these interface values as defaults:\n\nu0_dyn = initialize_componentwise!(nw_dyn, default_overrides=interface_vals, verbose=true)\n\nInternally, this function uses initialize_component! on every single component. For each component, it overwrites the defaults to be consistent with the interface values of the static model. Therefore, we ensure that the dynamic model is initialized near the steady state of the static model.\n\nWe can inspect individual components if needed:\n\ndump_initial_state(nw_dyn[VIndex(1)])\nnothing #hide\n\nLet's verify that our initialization is correct by checking that the derivatives are close to zero:\n\ndu = ones(dim(nw_dyn))\nnw_dyn(du, uflat(u0_dyn), pflat(u0_dyn), 0.0)\nextrema(du .- zeros(dim(nw_dyn))) # very close to zero, confirming we have a steady state!\n\nAlternatively, we can used the isfixpoint function to check if the state is a fixpoint:\n\n@assert isfixpoint(nw_dyn, u0_dyn)\nnothing #hide","category":"section"},{"location":"generated/init_tutorial/#Simulating-the-Dynamic-Model","page":"Initialization","title":"Simulating the Dynamic Model","text":"With our properly initialized model, we can now simulate the system to observe its behavior. To make the simulation more interesting, we'll introduce a disturbance to see how the system responds from its steady state.\n\nWe'll use a callback to increase consumer demand at a specific time. For more information on callbacks, see the documentation on Callbacks.\n\naffect = ComponentAffect([], [:q̃_prosumer]) do u, p, ctx\n    @info \"Increase consumer demand at t=$(ctx.t)\"\n    p[:q̃_prosumer] -= 0.1\nend\ncb = PresetTimeComponentCallback([1.0], affect)\nset_callback!(nw_dyn[VIndex(2)], cb) # attach disturbance to second node\nnothing #hide\n\nCreate and solve the ODE problem with the callback. Note that we're using the flat representation of our initialized state (via uflat and pflat) as input to the ODE solver:\n\nprob = ODEProblem(nw_dyn, copy(uflat(u0_dyn)), (0, 7), copy(pflat(u0_dyn));\n    callback=get_callbacks(nw_dyn))\n\nFor less boilerplate, we can also use a NetworkDynamics specific problem constructor which extracts flat arrays and callbacks automatically:\n\nprob = ODEProblem(nw_dyn, u0_dyn, (0, 7))\n\nThe system can then be solved:\n\nsol = solve(prob, Tsit5())\nnothing #hide","category":"section"},{"location":"generated/init_tutorial/#Visualizing-the-Results","page":"Initialization","title":"Visualizing the Results","text":"Finally, let's visualize the results of our simulation. The plots show how our gas network responds to the increased consumer demand at t=1:\n\nPressure at nodes: We see a pressure drop at all nodes after the disturbance before the pressure is stabilized by the controller.\nInjection by producer: Node 1 increases its injection to compensate for the higher demand.\nConsumption by consumers: The solid lines show the actual flows at nodes 2 and 3, while the dashed lines show the set consumer demands. At t=1, we see the step change in consumer demand at node 2.\nFlows through pipes: Shows how the flows in all pipes adjust to the new demand pattern.\n\nlet\n    fig = Figure(size=(1000,1000))\n    ax = Axis(fig[1, 1]; title=\"Pressure at nodes\")\n    for i in 1:3\n        lines!(ax, sol; idxs=VIndex(i, :p), label=\"Node $i\", color=Cycled(i))\n    end\n\n    ax = Axis(fig[2, 1]; title=\"Injection by producer\")\n    lines!(ax, sol; idxs=VIndex(1, :q̃_inj), label=\"Node 1\", color=Cycled(1))\n\n    ax = Axis(fig[3, 1]; title=\"Consumption by consumers\")\n    for i in 2:3\n        lines!(ax, sol; idxs=@obsex(-1*VIndex(i, :q̃_inj)), label=\"Node $i\", color=Cycled(i))\n        lines!(ax, sol; idxs=@obsex(-1*VIndex(i, :q̃_prosumer)), label=\"Node $i\", linestyle=:dash, color=Cycled(i))\n    end\n\n    ax = Axis(fig[4, 1]; title=\"Flows through pipes\")\n    for i in 1:3\n        lines!(ax, sol; idxs=@obsex(abs(EIndex(i, :q̃))), label=\"Pipe $i\", color=Cycled(i))\n    end\n\n    fig\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"inspector/#Interactive-Solution-Inspection","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"An interactive solution inspection tool based on WGLMakie and Bonito is provided through the helper package NetworkDynamicsInspector.\n\nFirst, we need to define the system we want to inspect.\n\ndetails: Define some network, simulate it and get a solution object\nusing NetworkDynamics\nusing NetworkDynamicsInspector\nusing NetworkDynamicsInspector: NetworkDynamicsInspector as NDI #hide\nusing Electron # hide\nusing OrdinaryDiffEqTsit5\nusing Graphs\n\ninclude(joinpath(pkgdir(NetworkDynamics), \"test\", \"ComponentLibrary.jl\"))\nfunction get_sol(;limit=1.0)\n    g = SimpleGraph([0 1 1 0 1;\n                    1 0 1 1 0;\n                    1 1 0 1 0;\n                    0 1 1 0 1;\n                    1 0 0 1 0])\n    vs = [Lib.swing_mtk() for _ in 1:5];\n    set_default!(vs[1], :Pmech, -1)\n    set_default!(vs[2], :Pmech, 1.5)\n    set_default!(vs[3], :Pmech, -1)\n    set_default!(vs[4], :Pmech, -1)\n    set_default!(vs[5], :Pmech, 1.5)\n    ls = [Lib.line_mtk() for _ in 1:7];\n    nw = Network(g, vs, ls)\n    sinit = NWState(nw)\n    s0 = find_fixpoint(nw)\n    set_defaults!(nw, s0)\n\n    # set_position!(vs[1], (0.0, 0.0))\n    set_marker!(vs[1], :dtriangle)\n    set_marker!(vs[2], :utriangle)\n    set_marker!(vs[3], :dtriangle)\n    set_marker!(vs[4], :dtriangle)\n    set_marker!(vs[5], :utriangle)\n\n    cond = ComponentCondition([:P, :₋P, :srcθ], [:limit, :K]) do u, p, t\n        abs(u[:P]) - p[:limit]\n    end\n    affect = ComponentAffect([],[:active]) do u, p, ctx\n        @info \"Trip line $(ctx.eidx) between $(ctx.src) and $(ctx.dst) at t=$(ctx.t)\"\n        p[:active] = 0\n    end\n    cb = ContinuousComponentCallback(cond, affect)\n    set_callback!.(ls, Ref(cb))\n\n    tripfirst = PresetTimeComponentCallback(1.0, affect) # reuse the same affect\n    add_callback!(nw[EIndex(5)], tripfirst)\n\n    s0 = NWState(nw)\n    s0.p.e[:, :limit] .= limit\n\n    prob = ODEProblem(nw, uflat(s0), (0,6), copy(pflat(s0)))\n    sol = solve(prob, Tsit5())\nend\n\nsol = get_sol()\nnothing #hide\n\nNow that we have an ODESolution sol, we can call inspect to open the inspector GUI. The docstring provides several options to customize how the app is displayed.\n\ninspect(sol; reset=true)\nsleep(1) # hide\ndefine_timeseries!([ # hide\n    (; selcomp=[EIndex(i) for i in 1:7], states=[:P]) # hide\n]) # hide\nsleep(3) # hide\nNDI.save_electron_screenshot(\"screenshot.png\") #hide\n\n(Image: screenshot)","category":"section"},{"location":"inspector/#Programmatic-Access-and-GUI-State-Manipulation","page":"Interactive Solution Inspection","title":"Programmatic Access and GUI State Manipulation","text":"Internally, the NetworkDynamicsInspector maintains a global reference to an AppState object. This AppState reflects changes made to the GUI by the user and can also be modified programmatically.\n\nSee the NetworkDynamicsInspector API for a complete list of available functions. A good starting point is the dump_app_state function, which helps you recreate a GUI state that was previously configured manually.\n\nLet's say we've adjusted the AppState to include an additional time series plot for the node states.\n\nset_state!(; t=1.75) #hide\ndefine_timeseries!([ #hide\n    (; selcomp=[VIndex(i) for i in 1:5], states=[:θ, :ω]) #hide\n    (; selcomp=[EIndex(i) for i in 1:7], states=[:P]) #hide\n]) #hide\nsleep(3) #hide\nnothing #hide\n\nWe can dump the code which helps us to recreate the app state:\n\ndump_app_state()\n\nNow we can use this code to recreate the app state even though we've reseted it.\n\nbuf = IOBuffer() #hide\ndump_app_state(buf) #hide\ncode = String(take!(buf)) #hide\ninspect(sol; reset=true)\nsleep(1) #hide\neval(Meta.parse(\"begin;\"*code*\"end;\")) #hide\nsleep(3) #hide\nNDI.save_electron_screenshot(\"screenshot2.png\") #hide\n\"copy-paste and execute code returned by `dump_app_state` here\" #hide\n\n(Image: screenshot)","category":"section"},{"location":"initialization/#initialization-guide","page":"Initialization","title":"Initialization","text":"Initialization is a critical step in simulation dynamical systems on networks, involving finding valid initial conditions that satisfy the system's constraints. NetworkDynamics provides several layers of initialization tools, from individual component initialization to full network initialization.","category":"section"},{"location":"initialization/#Initialization-Hierarchy","page":"Initialization","title":"Initialization Hierarchy","text":"NetworkDynamics offers a tiered approach to initialization:\n\nFull-System Initialization: Finding a steady state for the entire network at once\nComponent-wise Network Initialization: Initializing each component individually while respecting network coupling\nSingle Component Initialization: Finding valid internal states for a single component","category":"section"},{"location":"initialization/#Full-System-Initialization","page":"Initialization","title":"Full-System Initialization","text":"Full system initialization aims to find a fixed point/steady state of the entire system simultaneously.\n\nTo do so, you can use find_fixpoint, which creates a SteadyStateProblem of the whole network and attempts to solve it:\n\n# Create a network\nnw = Network(vertices, edges)\n\n# Find a fixed point for the entire system\nstate = find_fixpoint(nw)\n\nThis approach works well for simpler systems but may face convergence challenges for complex networks with many interacting components.","category":"section"},{"location":"initialization/#Component-wise-Network-Initialization","page":"Initialization","title":"Component-wise Network Initialization","text":"For more complex networks, a component-by-component approach is often more robust. NetworkDynamics provides initialize_componentwise and initialize_componentwise! functions that:\n\nInitialize each component individually\nVerify the combined solution works for the entire network\n\n# Initialize each component in the network individually\nstate = initialize_componentwise(nw)\n\n# Or using the mutating version that updates component metadata\nstate = initialize_componentwise!(nw)","category":"section"},{"location":"initialization/#Two-Step-Initialization-Pattern","page":"Initialization","title":"Two-Step Initialization Pattern","text":"A common initialization pattern for complex networks involves:\n\nSolving a simplified static model first\nUsing those results to initialize a more complex dynamic model\n\n# 1. Solve a static/simplified model\nstatic_model = create_static_network(...)\nstatic_state = find_fixpoint(static_model)\n\n# 2. Extract interface values\ninterface_vals = interface_values(static_state)\n\n# 3. Use them to initialize a dynamic model\ndynamic_model = create_dynamic_network(...)\ndyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)\n\nSee the Tutorial on Initialization for a complete example of this approach.","category":"section"},{"location":"initialization/#Single-Component-Initialization","page":"Initialization","title":"Single Component Initialization","text":"At the lowest level, NetworkDynamics provides tools for initializing individual components based on their internal dynamics and interface constraints.","category":"section"},{"location":"initialization/#Mathematical-Meaning","page":"Initialization","title":"Mathematical Meaning","text":"According to the Mathematical Model of NetworkDynamics.jl, a component forms an \"input-output-system\" of the form\n\nbeginaligned\nMfracmathrmdmathrmdtx = f(x i p t)\ny = g(x i p t)\nendaligned\n\nwhere x are the internal states, i are the inputs, y are the outputs, and p are the parameters. To initialize at a fixed point, we require the RHS to be zero,\n\nbeginaligned\n0 = f(x i p t)\n0 = g(x i p t) - y\nendaligned\n\nforming a nonlinear least squares problem for the residual. Each variable in x, i, y and p is either considered free or fixed with respect to the nonlinear problem stated above. Symbols that have a default value (see Metadata) are considered fixed. All other symbols are considered free and must provide a guess value as an initial starting point for the nonlinear solver.\n\nThe defaults and guesses can be either obtained from the Metadata directly or provided as arguments.","category":"section"},{"location":"initialization/#Non-mutating-vs-Mutating-Initialization","page":"Initialization","title":"Non-mutating vs Mutating Initialization","text":"NetworkDynamics provides two approaches for component-wise initialization:\n\nNon-mutating approach using initialize_component: Returns a dictionary of values without modifying the component\nMutating approach using initialize_component!: Directly updates the component metadata with initialization results\n\nBoth options take guesses and defaults from metadata by default; however, it is possible to specify otherwise (see method documentation).\n\nThe non-mutating version initialize_component is useful when you don't want to modify the metadata, for a more \"stateless\" approach:\n\n# Get initialization results as a dictionary\ninit_state = initialize_component(vf; default_overrides=Dict(:x => 4))\n\nIt will return a Dict{Symbol,Float64} which contains values for all symbols in the model.\n\nThe mutating version initialize_component! directly updates the component's metadata with initialization results:\n\ninitialize_component!(vf; verbose=true) # set `init` metadata for free symbols\n\nThe same pattern applies at the network level with initialize_componentwise and initialize_componentwise!.","category":"section"},{"location":"initialization/#Example","page":"Initialization","title":"Example","text":"Let's consider the following example of a Swing-equation generator model.\n\nusing NetworkDynamics, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\n\n@mtkmodel Swing begin\n    @variables begin\n        u_r(t)=1, [description=\"bus d-voltage\", output=true]\n        u_i(t)=0.1, [description=\"bus q-voltage\", output=true]\n        i_r(t)=1, [description=\"bus d-current (flowing into bus)\", input=true]\n        i_i(t)=0.1, [description=\"bus d-current (flowing into bus)\", input=true]\n        ω(t), [guess=0.0, description=\"Rotor frequency\"]\n        θ(t), [guess=0.0, description=\"Rotor angle\"]\n        Pel(t), [guess=1, description=\"Electrical Power injected into the grid\"]\n    end\n    @parameters begin\n        M=0.005, [description=\"Inertia\"]\n        D=0.1, [description=\"Damping\"]\n        V, [guess=1.0, description=\"Voltage magnitude\"]\n        ω_ref=0, [description=\"Reference frequency\"]\n        Pm, [guess=0.1,description=\"Mechanical Power\"]\n    end\n    @equations begin\n        Dt(θ) ~ ω - ω_ref\n        Dt(ω) ~ 1/M * (Pm - D*ω - Pel)\n        Pel ~ u_r*i_r + u_i*i_i\n        u_r ~ V*cos(θ)\n        u_i ~ V*sin(θ)\n    end\nend\nsys = Swing(name=:swing)\nvf = VertexModel(sys, [:i_r, :i_i], [:u_r, :u_i])\n\nYou can see in the provided metadata that we've set default values for the node outputs u_r, u_i, the node inputs i_r, i_i, and most parameters. For some states and parameters, we've only provided a guess rather than a default. Variables that only have guesses are considered \"tunable\" for the initialization algorithm.","category":"section"},{"location":"initialization/#Using-the-non-mutating-initialization","page":"Initialization","title":"Using the non-mutating initialization","text":"We can use initialize_component to get the initialized values without modifying the component:\n\ninit_values = initialize_component(vf; default_overrides=Dict(:u_i=>0), verbose=true)\n\nThe code returns a dictionary which pins all the variables of the component to some values which satisfy the initialization condition.","category":"section"},{"location":"initialization/#Using-the-mutating-initialization","page":"Initialization","title":"Using the mutating initialization","text":"Alternatively, we can make use of the mutating version to store the results of the initialization in the metadata:\n\ninitialize_component!(vf; verbose=true)\n\nWhich stored the initialisation results as :init metadata of the component model vf:\n\nget_init(vf, :V) # get the value of :V at initialized state\n\nIt is possible to inspect initial states (works also for observed symbols) using get_initial_state. As a quick test we can ensure that the angle indeed matches the voltage angle:\n\nget_initial_state(vf, :θ) ≈ atan(get_initial_state(vf, :u_i), get_initial_state(vf, :u_r))\n\nYou can print out the whole state using dump_initial_state.\n\ndump_initial_state(vf)","category":"section"},{"location":"initialization/#Advanced-Component-Initialization:-Formulas-and-Constraints","page":"Initialization","title":"Advanced Component Initialization: Formulas and Constraints","text":"NetworkDynamics provides three complementary mechanisms for customizing component initialization beyond the basic defaults and guesses: initialization formulas ,initialization constraints and guess formulas. These operate at different stages of the initialization pipeline and serve distinct purposes:\n\ninit formulas reduce the number of free variables (by setting additional defaults),\ninit constraints increase the number of equations for the init problem and\nguess formulas refine starting values for the initialization rootfinding problem.\n\nThe execution order is:\n\nCollect defaults, guesses, and bounds from metadata\nApply init formulas → update defaults (fix more variables)\nApply guess formulas → update guesses (improve starting point)\nCreate and solve the nonlinear least squares problem with additonal constraints","category":"section"},{"location":"initialization/#Initialization-Formulas-(InitFormula)","page":"Initialization","title":"Initialization Formulas (InitFormula)","text":"Initialization formulas act early in the initialization pipeline to compute and set default values based on other known values. They are particularly useful for deriving dependent quantities or ensuring consistency between related variables.\n\nEach formula can only reference symbols that are already available - it cannot use intermediate values computed within the same formula.\n\nBasic Usage: Use the @initformula macro to define formulas with assignment syntax:\n\n# Example: Set voltage magnitude and electrical power based on voltage components\nvoltage_formula = @initformula begin\n    :V = sqrt(:u_r^2 + :u_i^2)     # Voltage magnitude from components\n    :Pel = :u_r * :i_r + :u_i * :i_i # Electrical power calculation\nend\nnothing #hide\n\nApplying Formulas: Formulas can be either added to the metadata of components (set_initformula!, add_initformula!) or passed as additional_initformula to the initialize_component[!] functions.\n\nDependency Resolution: When applying multiple separate formulas, NetworkDynamics automatically sorts them topologically to ensure correct evaluation order.","category":"section"},{"location":"initialization/#Initialization-Constraints-(InitConstraint)","page":"Initialization","title":"Initialization Constraints (InitConstraint)","text":"Initialization constraints add equations to the nonlinear system that must be satisfied during the initialization solve. Unlike formulas, they don't directly set values but impose mathematical relationships.\n\nBasic Usage: Use the @initconstraint macro to define constraint equations:\n\n# Example: Constrain electrical power and voltage magnitude\npower_constraint = @initconstraint begin\n    :Pel - 1.0                        # Electrical power must equal 1.0\n    sqrt(:u_r^2 + :u_i^2) - 1.0      # Voltage magnitude must equal 1.0\nend\nnothing #hide\n\nApplying Constraints: Constraints can be either added to the metadata of components (set_initconstraint!, add_initconstraint!) or passed as additional_initconstraint to the initialize_component[!] functions.","category":"section"},{"location":"initialization/#Guess-Formulas-(GuessFormula)","page":"Initialization","title":"Guess Formulas (GuessFormula)","text":"Guess formulas operate later in the initialization pipeline than init formulas. While init formulas set default values (thereby reducing the number of free variables), guess formulas refine the initial guesses for free variables to improve solver convergence without changing the problem dimension.\n\nWhile InitFormulas use defaults to update other defaults, GuessFormulas update guesses based on other defaults and guesses (if some variable has a default and guess defined, the default takes precedence). They act after the InitFormulas, thus having access to the updated defaults.\n\nSimilar to InitFormulas, NetworkDyanmics makes sure that there are no circular dependencies between guess formulas and you can't have multiple guess formulas updating the same variables. It performs some topological sorting on multiple guesses to update in order.\n\nBasic Usage: Use the @guessformula macro with the same assignment syntax as init formulas:\n\n# Example: Improve angle and voltage guesses from interface values\nsetpoint_guesses = @guessformula begin\n    :V_set = sqrt(:u_r^2 + :u_i^2)     # guess voltage mag setpoint close to actual voltage\n    :P_set = :u_r * :i_r + :u_i * :i_i # guess power setpoint close to actual power\nend\nnothing #hide\n\nApplying GuessFormulas: Like init formulas and constraints, guess formulas can be stored in metadata (set_guessformula!) or passed directly using the additional_guessformula keyword in initialize_componentwise, initialize_component and friends.","category":"section"},{"location":"initialization/#Analysing-Fixpoints","page":"Initialization","title":"Analysing Fixpoints","text":"In order to analyse fixpoints NetworkDynamis provides the functions isfixpoint, is_linear_stable and jacobian_eigenvals.","category":"section"},{"location":"generated/heterogeneous_system/#Modeling-a-heterogeneous-system","page":"Heterogeneous Systems","title":"Modeling a heterogeneous system","text":"This example can be downloaded as a normal Julia script here.\n\nOne of the main purposes of NetworkDynamics.jl is to facilitate the modeling systems whose components can differ in their parameters as well as their dynamics. These are known as Coupled systems with heterogeneities.","category":"section"},{"location":"generated/heterogeneous_system/#Heterogeneous-parameters","page":"Heterogeneous Systems","title":"Heterogeneous parameters","text":"We start by setting up a simple system of Kuramoto oscillators.\n\nusing NetworkDynamics, OrdinaryDiffEqTsit5, Plots, Graphs\n\nN = 8\ng = watts_strogatz(N, 2, 0) # ring network\n\nfunction kuramoto_edge!(e, θ_s, θ_d, (K,), t)\n    e[1] = K * sin(θ_s[1] - θ_d[1])\n    nothing\nend\nedge! = EdgeModel(g=AntiSymmetric(kuramoto_edge!), outdim=1, psym=[:K=>3])\n\nfunction kuramoto_vertex!(dθ, θ, esum, (ω0,), t)\n    dθ[1] = ω0 + esum[1]\n    nothing\nend\nvertex! = VertexModel(f=kuramoto_vertex!, g=StateMask(1:1), sym=[:θ], psym=[:ω0], name=:kuramoto)\n\nnw = Network(g, vertex!, edge!)\n\nTo assign parameters, we can create a NWParameter object based on the nw definition. This parameter object will be pre-filled with the default parameters.\n\np = NWParameter(nw)\n\nTo set the vertex parameters, we can use indexing of the p.v field:\n\nω = collect(1:N) ./ N\nω .-= sum(ω) / N\np.v[:, :ω0] = ω\nnothing #hide\n\nHere, the index pairing :, :ω is used to index state ω for all node indices.\n\nThe parameter object contains information about the network structure. For the actual problem definition we need to throw away this wrapper and use the flat-vector representation of the parameters pflat(p). Note that pflat(p)\n\nSimilarily, we could use NWState(nw) to create an indexable wrapper of the initial state. However in this case we can also fill create the flat state array manually:\n\nx0 = collect(1:N) ./ N\nx0 .-= sum(x0) ./ N\ntspan = (0.0, 10.0)\nprob = ODEProblem(nw, x0, tspan, pflat(p))\nsol = solve(prob, Tsit5())\nplot(sol; ylabel=\"θ\", fmt=:png)","category":"section"},{"location":"generated/heterogeneous_system/#Heterogeneous-dynamics","page":"Heterogeneous Systems","title":"Heterogeneous dynamics","text":"Two paradigmatic modifications of the node model above are static nodes and nodes with inertia. A static node has no internal states and instead fixes the variable at a constant value.\n\nfunction static_g(out, u, p, t)\n    out[1] = p[1]\n    nothing\nend\nstatic! = VertexModel(g=static_g, outsym=[:θ], psym=[:θfix => ω[1]], name=:static)\n\nBut wait! NetworkDynamics classified this as PureFeedForward, because it cannot distinguish between the function signatures\n\ng(out, u, p, t)    # PureFeedForward\ng(out, ins, p, t)  # NoFeedForward\n\nand since dim(u)=0 it wrongfully assumes that the latter is meant. We can overwrite the classification by passing the ff keyword:\n\nstatic! = VertexModel(g=static_g, outsym=[:θ], psym=[:θfix => ω[1]], ff=NoFeedForward(), name=:static)\n\nA Kuramoto model with inertia consists of two internal variables leading to more complicated (and for many applications more realistic) local dynamics.\n\nfunction kuramoto_inertia!(dv, v, esum, (ω0,), t)\n    dv[1] = v[2]\n    dv[2] = ω0 - 1.0 * v[2] + esum[1]\n    nothing\nend\n\ninertia! = VertexModel(f=kuramoto_inertia!, g=1:1, sym=[:θ, :ω], psym=[:ω0], name=:inertia)\n\nSince now we model a system with heterogeneous node dynamics we can no longer straightforwardly pass a single VertexModel to the Network constructor but instead have to hand over an Array.\n\nvertex_array    = VertexModel[vertex! for i in 1:N]\nvertex_array[1] = static!\nvertex_array[5] = inertia! # index should correspond to the node's index in the graph\nnw_hetero! = Network(g, vertex_array, edge!)\n\nNow we have to take a bit more care with defining initial conditions and parameters.\n\nFirst, we can generate a NWState object based on the nw_hetero! object which will be populated with the default values.\n\nstate = NWState(nw_hetero!)\n\nThe node with inertia is two-dimensional, hence we need to specify two initial conditions. For the first dimension we keep the initial conditions from above and insert! another one into x0 at the correct index.\n\nFor the θ states we will use the same initial conditins as before:\n\nstate.v[2:8,:θ] = x0[2:8]\nnothing #hide\n\nWe're still missing one initial condition: the second variable ω of the 5th vertex.\n\nstate.v[5,:ω] = 5\nnothing #hide\n\nThe NWState object also contains a parameter object accessible via state.p. The edge parameters are already filled with default values. The vertex parameters can be copied from our old parmeter object p.\n\nstate.p.v[2:8, :ω0] = p.v[2:8, :ω0]\nnothing #hide\n\nFor the problem construction, we need to convert the nested stuctures to flat arrays using the uflat and pflat methods.\n\nprob_hetero = ODEProblem(nw_hetero!, uflat(state), tspan, pflat(state))\nsol_hetero = solve(prob_hetero, Tsit5());\nnothing #hide\nplot(sol_hetero)\n\nFor clarity we plot only the variables referring to the oscillator's angle θ and color them according to their type.\n\ncolors = map(vertex_array) do vertexf\n    if vertexf.name == :kuramoto\n        colorant\"lightseagreen\"\n    elseif vertexf.name == :static\n        colorant\"orange\"\n    elseif vertexf.name == :inertia\n        colorant\"darkred\"\n    end\nend\n\nplot(sol_hetero; ylabel=\"θ\", idxs=vidxs(1:8,:θ), lc=colors', fmt=:png)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"metadata/#Metadata","page":"Metadata","title":"Metadata","text":"Component models such as VertexModel and EdgeModel can store metadata. We distinguish between two kinds of metadata: component metadata and symbol metadata.","category":"section"},{"location":"metadata/#Component-Metadata","page":"Metadata","title":"Component Metadata","text":"Component metadata is a Dict{Symbol,Any} attached to each component to store various information. Use metadata to retrieve the full dict.\n\nTo access the data, you can use the methods has_metadata, get_metadata, set_metadata! and delete_metadata! (see Component Metadata API).\n\nSpecial metadata:\n\n:graphelement: optional field to specialize the graphelement for each component (vidx) for vertices, (;src,dst) named tuple of either vertex names or vertex indices for edges. Has special accessors has_/get_/set_graphelement.\n:callback: optional field to define callback functions on the component level. See Callbacks and Callbacks API for more information.\n:position: Store a tuple (x, y) with position of the node for plotting. Has special accessors has_/get_/set_position.\n:marker: Store a Symbol for the graph plot. Possible values could be :circle, :rect, :utriangle, :cross, :diamond, :dtriangle, :pentagon, :xcross or anything which works as a marker keyword argument in Makie.\n:initconstraint: Store additional initialization constrains. Has special has_/get_/set_/delete_initconstraint accessors. See Initialization for further\n\ndetails.\n\n:initformula: Similar to initconstraint, but is a straight forward explicit mapping to initialize some variables.","category":"section"},{"location":"metadata/#Symbol-Metadata","page":"Metadata","title":"Symbol Metadata","text":"Each component stores symbol metadata. The symbol metadata is a Dict{Symbol, Dict{Symbol, Any}} which stores a metadata dict per symbol. Symbols are everything that appears in sym, psym, obssym and insym.\n\nTo access the data, you can use the methods has_metadata, get_metadata, set_metadata! and delete_metadata! (see Per Symbol Metadata API). These functions also support pattern matching using String or Regex patterns to match symbol names, making it easier to work with symbols containing special characters or when you only know part of the symbol name.\n\nSpecial cases for symbol metadata are:\n\ndefault: Stores default values for states/parameters. In initialization, those are considered fixed.\nguess: Stores a guess for a state/parameter which needs to be solved during initialization (\"free\" variables).\nbounds: Stores bounds for variables/parameters\ninit: Stores the solution of the \"free\" variables, this is rarely set manually but instead when calling initialize_component!.\n\nFor those, there are special functions has_*, get_*, set_*!, delete_*! and strip_*!. The strip_*! functions remove all metadata of a specific type from all symbols in a component. See Per Symbol Metadata API.\n\nThese are closely aligned with the metadata use in ModelingToolkit. They are automatically copied from the System if you use MTK models to create NetworkDynamics models.","category":"section"},{"location":"metadata/#Metadata-Utils","page":"Metadata","title":"Metadata Utils","text":"Accessing metadata (especially defaults) of states and parameters is a very common task. We provide several helper methods to do so. Please check out their docstrings for further explanation:\n\ndump_state\ndump_initial_state\nget_initial_state\nfree_u - find variables without default values\nfree_p - find parameters without default values\ndescribe_vertices (needs DataFrames.jl loaded)\ndescribe_edges (needs DataFrames.jl loaded)","category":"section"},{"location":"symbolic_indexing/#Symbolic-Indexing","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"By using SciML's SymbolicIndexingInterface.jl, ND.jl  provides numerous methods to access and change variables and parameters.","category":"section"},{"location":"symbolic_indexing/#Provide-Symbol-Names","page":"Symbolic Indexing","title":"Provide Symbol Names","text":"When constructing component models, you can pass symbolic names using the sym and psym keywords.\n\nusing NetworkDynamics, Graphs, OrdinaryDiffEqTsit5, Plots\nfunction _edgef!(e, v_s, v_d, (K,), t)\n    e .= K * (v_s[1] .- v_d[1])\nend\nedgef = EdgeModel(;g=AntiSymmetric(_edgef!), outsym=[:flow], psym=[:K=>1])\n\nHere we create a static diffusion edge with suitable variable and parameter names. Similarly, we define the diffusion vertex with symbolic names.\n\nfunction _vertexf!(dv, v, esum, p, t)\n    dv[1] = esum[1]\nend\nvertexf = VertexModel(f=_vertexf!, g=1, sym=[:storage])\n\nWhen constructing component models using ModelingToolkit, the variable names are extracted automatically. ","category":"section"},{"location":"symbolic_indexing/#Fundamental-Symbolic-Indices","page":"Symbolic Indexing","title":"Fundamental Symbolic Indices","text":"The main types for symbolic indexing are VIndex and EIndex for vertices and edges respectively. Each symbolic index consists of 2 elements: a reference to the network component and a reference to the symbol within that component. Indices may reference states and parameters, but also things like outputs, inputs and observables which do not directly appear in the state/parameter vector.\n\nFor accessing by symbol:\n\nVIndex(2, :x) refers to variable with symbolic name :x in vertex number 2.\nEIndex(4, :K) refers to parameter :K of the edge component for the 4th edge.\n\nFor numeric indexing, use StateIdx and ParamIdx wrappers:\n\nVIndex(2, StateIdx(1)) refers to the first state of vertex 2.\nEIndex(4, ParamIdx(2)) refers to the second parameter of edge 4.\n\ndetails: Setup code to make following examples work\ng = wheel_graph(5)\nnw = Network(g, vertexf, edgef)\ns = NWState(nw)\ns.v[:,:storage] .= randn(5)\nprob = ODEProblem(nw, uflat(s), (0,2), pflat(s))\nsol = solve(prob, Tsit5()) \nnothing #hide\n\nThose fundamental indices can be used in a lot of scenarios. Most importantly you can use them to extract points or timeseries from a solution object\n\nts = 0:0.1:1\nsol(ts; idxs=VIndex(1,:storage)) # value of VIndex(1,:storage) at each t in ts\n\nAlternatively, you can use them directly in specialized plotting recipes:\n\nplot(sol; idxs=[VIndex(1, :storage), VIndex(5,:storage)]) # plot storage of vertex 1 and vertex 5\n\nIt is often advised to choose your timesteps for plotting directly, i.e.\n\nts = range(0, 1; length=1000)\nplot(ts, sol(ts; idxs=VIndex(1,:storage)).u)\nnothing #hide\n\ngives you more control over how many points are used within the range (01).","category":"section"},{"location":"symbolic_indexing/#Generate-Symbolic-Indices","page":"Symbolic Indexing","title":"Generate Symbolic Indices","text":"Often, you need many individual symbolic indices. NetworkDynamics provides several approaches:","category":"section"},{"location":"symbolic_indexing/#Quick-Access-with-Helper-Functions","page":"Symbolic Indexing","title":"Quick Access with Helper Functions","text":"The helper methods vidxs, eidxs, vpidxs and epidxs provide shortcuts for common patterns\n\nvidxs(nw, :, :storage) # get state variable \"storage\" for all vertices\n\nplot(sol; idxs=vidxs(nw, :, :storage))","category":"section"},{"location":"symbolic_indexing/#Advanced-Generation-with-generate_indices","page":"Symbolic Indexing","title":"Advanced Generation with generate_indices","text":"For more complex filtering, use generate_indices, which provides the underlying functionality:\n\n# All edge parameters containing \"K\" in their name\ngenerate_indices(nw, EIndex(:), \"K\"; s=false, p=true, out=false)\n\nThe helper functions are actually just shortcuts to generate_indices calls:\n\nvidxs(nw, cf, vf) = generate_indices(nw, VIndex(cf), vf; s=true, p=false, out=true, obs=true)","category":"section"},{"location":"symbolic_indexing/#NWState-and-NWParameter-Objects","page":"Symbolic Indexing","title":"NWState and NWParameter Objects","text":"Internally, both state and parameters of a Network are represented using flat arrays. To access the state or parameters of a network, you can use the NWState and NWParameter objects.\n\np = NWParameter(nw)\n\ncreates a NWParameter object for the network nw. It essentially creates a new flat parameter array and fills it with the default parameter values defined in the component. The parameters in the NWParameter object can be accessed using symbolic indices.\n\np[EIndex(5, :K)] = 2.0 # change the parameter K of the 5th edge\nnothing #hide\n\nSimilarly, you can create a NWState object for the network nw using\n\ns = NWState(nw)\n\nNo default values were provided in the network components, so the state array is filled with NaN values.\n\nWe can set those values like this:\n\ns[VIndex(:, :storage)] .= randn(5) # set the (initial) storage for all vertices \ns #hide\n\nFor both NWState and NWParameter objects, there is a more convenient way to access the variables and parameters using the FilteringProxy interface. The filtering proxy can be accessed by calling .v or .e on a state:\n\ns.v\n\nYou can then subsequently filter the list by \"indexing\" into the FilteringProxy object:\n\ns.v[1:2]\n\n... until you've filtered on both components and variables and the indexing returns the actual values:\n\ns.v[1:2][:storage]\n\nCheck out the docstring of FilteringProxy for an in-depth explanation.\n\nThe NWState and NWParameter objects are mutable, thus changing them will also change the underlying wrapped flat arrays.\n\nFor example, we can use the syntax introduced above to update the values within the state\n\ns.v[1:2][:storage] = [1,2]\nnothing #hide\n\nWe can confirm the update by inspecting the values again:\n\ns.v\n\nYou can always access the flat representations by calling uflat and pflat. The ordering of elements  in these flat arrays corresponds exactly to the order returned by variable_symbols and  parameter_symbols respectively.\n\nnote: Note\nThe NWState and NWParameter wrappers can be constructed from various objects. For example, within a callback you might construct p = NWParameter(integrator) to then change the parameters of the network within the callback.","category":"section"},{"location":"symbolic_indexing/#Interactive-Filtering-with-FilteringProxy","page":"Symbolic Indexing","title":"Interactive Filtering with FilteringProxy","text":"The FilteringProxy system provides an intuitive way to explore and access network variables through progressive filtering. When you access .v, .e, or .p properties of NWState/NWParameter objects, you get a filtering proxy that can be refined step by step.","category":"section"},{"location":"symbolic_indexing/#Observables","page":"Symbolic Indexing","title":"Observables","text":"Sometimes, the \"states\" you're interested in aren't really states in the DAE sense but rather algebraic derivations from DAE states, parameters, and time – in accordance with the naming in  the SciML ecosystem, these values are called Observables.\n\nA prime example of Observables are edge/vertex-outputs, such as the flow in the edge model defined above. It is also possible to define additional Observables manually by using the obssym and obsf keyword on the EdgeModel/VertexModel constructors. When building models using ModelingToolkit, the reduced algebraic states will be preserved automatically as observables.\n\nObservables can be accessed like any other state. For example, the flows in the network don't show up in the state array  but can be accessed in all the ways discussed above.  For example:\n\nplot(sol; idxs=eidxs(nw, :, :flow))","category":"section"},{"location":"symbolic_indexing/#Derived-ObservableExpressions-using-@obsex","page":"Symbolic Indexing","title":"Derived ObservableExpressions using @obsex","text":"Sometimes it is useful to plot or observe simple derived quantities. For that, one can use the @obsex macro to define simple derived quantities.\n\nFor example, we can directly plot the storage difference with respect to storage of node 1.\n\nplot(sol; idxs=@obsex(vidxs(nw,:,:storage) .- VIndex(1,:storage)))\n\nOther examples include calculating the magnitude and argument of complex values that are modeled using real and  imaginary parts.\n\n@obsex mag = sqrt(VIndex(1, :u_r)^2 + VIndex(2, :u_i)^2)","category":"section"},{"location":"symbolic_indexing/#Low-level-accessors-for-flat-array-indices","page":"Symbolic Indexing","title":"Low-level accessors for flat array indices","text":"Sometimes, you want to know the indices of your states in the flat arrays. For that, you can use the low-level methods defined in SymbolicIndexingInterface.jl:\n\nusing NetworkDynamics: SII # SII = SymbolicIndexingInterface\nidxs = SII.variable_index(nw, vidxs(nw, 1:2, :storage))\n\nuflat(s)[idxs] == s.v[1:2, :storage]\n\nAnalogous with parameters:\n\nidxs = SII.parameter_index(nw, [EIndex(1, :K), EIndex(2, :K)])\npflat(s)[idxs] == s.p.e[1:2, :K]\n\nIf you need the symbols of all the states/parameters in order, you can use:\n\nSII.variable_symbols(nw)\n\nand\n\nSII.parameter_symbols(nw)\n\nThese functions return the symbolic indices in the exact order they appear in the flat arrays returned by uflat and pflat, making them essential when you need to map between flat array indices and symbolic representations.\n\nAll above examples also work on other \"symbolic containers\", e.g. SII.variable_symbols(::NWState).","category":"section"},{"location":"API/#API","page":"API","title":"API","text":"The following functions are designed for public use.","category":"section"},{"location":"API/#Network-Construction-API","page":"API","title":"Network Construction API","text":"","category":"section"},{"location":"API/#Component-Models","page":"API","title":"Component Models","text":"","category":"section"},{"location":"API/#Component-Models-with-MTK","page":"API","title":"Component Models with MTK","text":"","category":"section"},{"location":"API/#Output-Function-Helpers/Wrappers","page":"API","title":"Output Function Helpers/Wrappers","text":"","category":"section"},{"location":"API/#Accessors-for-Component-Properties","page":"API","title":"Accessors for Component Properties","text":"","category":"section"},{"location":"API/#FeedForwardType-Traits","page":"API","title":"FeedForwardType-Traits","text":"","category":"section"},{"location":"API/#Symbolic-Indexing-API","page":"API","title":"Symbolic Indexing API","text":"","category":"section"},{"location":"API/#Network-Parameter-Object","page":"API","title":"Network Parameter Object","text":"","category":"section"},{"location":"API/#Network-State-Object","page":"API","title":"Network State Object","text":"","category":"section"},{"location":"API/#Symbolic-Indices","page":"API","title":"Symbolic Indices","text":"Retained for backward compatibility:","category":"section"},{"location":"API/#Index-generators","page":"API","title":"Index generators","text":"","category":"section"},{"location":"API/#Metadata-API","page":"API","title":"Metadata API","text":"","category":"section"},{"location":"API/#Component-Metadata-API","page":"API","title":"Component Metadata API","text":"","category":"section"},{"location":"API/#Per-Symbol-Metadata-API","page":"API","title":"Per-Symbol Metadata API","text":"","category":"section"},{"location":"API/#Metadata-and-Inspection-Utils","page":"API","title":"Metadata and Inspection Utils","text":"","category":"section"},{"location":"API/#Initialization","page":"API","title":"Initialization","text":"","category":"section"},{"location":"API/#Init-Constraints","page":"API","title":"Init-Constraints","text":"","category":"section"},{"location":"API/#Init-Formulas","page":"API","title":"Init-Formulas","text":"","category":"section"},{"location":"API/#Guess-Formulas","page":"API","title":"Guess-Formulas","text":"","category":"section"},{"location":"API/#Linear-Stability-Analysis","page":"API","title":"Linear Stability Analysis","text":"","category":"section"},{"location":"API/#Callbacks-API","page":"API","title":"Callbacks API","text":"","category":"section"},{"location":"API/#Define-Callbacks","page":"API","title":"Define Callbacks","text":"","category":"section"},{"location":"API/#Attach-Callbacks-to-Edge/VertexModels","page":"API","title":"Attach Callbacks to Edge/VertexModels","text":"","category":"section"},{"location":"API/#Sparsity-Detection","page":"API","title":"Sparsity Detection","text":"","category":"section"},{"location":"API/#Execution-Types","page":"API","title":"Execution Types","text":"","category":"section"},{"location":"API/#Aggregators","page":"API","title":"Aggregators","text":"","category":"section"},{"location":"API/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"API/#NetworkDynamicsInspector-API","page":"API","title":"NetworkDynamicsInspector API","text":"","category":"section"},{"location":"API/#NetworkDynamics.Network","page":"API","title":"NetworkDynamics.Network","text":"Network([g,] vertexf, edgef; kwarg...)\n\nConstruct a Network object from a graph g and edge and component models vertexf and edgef.\n\nArguments:\n\ng::AbstractGraph: The graph on which the network is defined.  Optional, can be ommittet if all component models have a defined graphelement.  See vidx and src/dst keywors for VertexModel and EdgeModel constructors respectively.\nvertexm:  A single VertexModel or a vector of VertexModel objects.  The order of the vertex models must mirror the order of the vertices(g) iterator.\nedgem: A single EdgeModel or a vector of EdgeModel objects.  The order of the edge models must mirror the order of the edges(g) iterator.\n\nOptional keyword arguments:\n\nexecution=SequentialExecution{true}():  Execution model of the network. E.g. SequentialExecution, KAExecution, PolyesterExecution or ThreadedExecution.\naggregator=execution isa SequentialExecution ? SequentialAggregator(+) : PolyesterAggregator(+):  Aggregation function applied to the edge models. E.g. SequentialAggregator, PolyesterAggregator, ThreadedAggregator, SparseAggregator.\ncheck_graphelement=true:  Check if the graphelement metadata is consistent with the graph.\ndealias=false  Check if the components alias eachother and create copies if necessary.  This is necessary if the same component model is referenced in multiple places in the Network but you want to  dynamicially asign metadata, such as initialization information to specific instances.\nverbose=false:  Show additional information during construction.\n\n\n\n\n\nNetwork(nw::Network; g, vertexm, edgem, copy_components=true, kwargs...)\n\nRebuild the Network with same graph and vertex/edge models but possibly different kwargs. If copy_components=true (default) then the vertex and edge models are copied.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.get_graph","page":"API","title":"NetworkDynamics.get_graph","text":"get_graph(nw::Network)\n\nExtracts the underlying graph of the network.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.dim-Tuple{Network}","page":"API","title":"NetworkDynamics.dim","text":"dim(nw::Network)\n\nReturns the number of dynamic states in the network, corresponts to the length of the flat state vector.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.pdim-Tuple{Network}","page":"API","title":"NetworkDynamics.pdim","text":"pdim(nw::Network)\n\nReturns the number of parameters in the network, corresponts to the length of the flat parameter vector.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.VertexModel-Tuple{}","page":"API","title":"NetworkDynamics.VertexModel","text":"VertexModel(; kwargs...)\n\nBuild a VertexModel according to the keyword arguments.\n\nMain Arguments:\n\nf=nothing: Dynamic function of the component. Can be nothing if dim is 0.\ng: Output function of the component. Usefull helpers: StateMask\nsym/dim: Symbolic names of the states. If dim is provided, sym is set automaticially.\noutsym/outdim:  Symbolic names of the outputs. If outdim is provided, outsym is set automaticially.  Can be infered automaticially if g isa StateMask.\npsym/pdim=0: Symbolic names of the parameters. If pdim is provided, psym is set automaticially.\nmass_matrix=I: Mass matrix of component. Can be a vector v and is then interpreted as Diagonal(v).\nname=dim>0 ? :VertexM : :StaticVertexM: Name of the component.\n\nOptional Arguments:\n\ninsym/indim: Symbolic names of the inputs. If indim is provided, insym is set automaticially.\nvidx: Index of the vertex in the graph, enables graphless constructor.\nff: FeedForwardType of component. Will be typically infered from g automaticially.\nobssym/obsf: Define additional \"observable\" states.\nsymmetadata/metadata: Provide prefilled metadata dictionaries.\nextin=nothing:  Define \"external\" inputs for the model with Network indices, i.e. extin=[VIndex(7,:x), ..].  Those inputs will be provided as another input vector f(x, in, extin, p, t) and g(y, x, in, extin, p, t).\n\nAll Symbol arguments can be used to set default values, i.e. psym=[:K=>1, :p].\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.EdgeModel-Tuple{}","page":"API","title":"NetworkDynamics.EdgeModel","text":"EdgeModel(; kwargs...)\n\nBuild a EdgeModel according to the keyword arguments.\n\nMain Arguments:\n\nf=nothing: Dynamic function of the component. Can be nothing if dim is 0.\ng: Output function of the component. Usefull helpers: AntiSymmetric, Symmetric, Fiducial, Directed and StateMask.\nsym/dim: Symbolic names of the states. If dim is provided, sym is set automaticially.\noutsym/outdim:  Symbolic names of the outputs. If outdim is provided, outsym is set automaticially.  In general, outsym for edges isa named tuple (; src, dst). However, depending on the g function,  it might be enough to provide a single vector or even nothing (e.g. AntiSymmetric(StateMask(1:2))).  See Building EdgeModels for examples.\npsym/pdim=0: Symbolic names of the parameters. If pdim is provided, psym is set automaticially.\nmass_matrix=I: Mass matrix of component. Can be a vector v and is then interpreted as Diagonal(v).\nname=dim>0 ? :EdgeM : :StaticEdgeM: Name of the component.\n\nOptional Arguments:\n\ninsym/indim: Symbolic names of the inputs. If indim is provided, insym is set automaticially.  For edges, insym is a named tuple (; src, dst). If give as vector tuple is created automaticially.\nsrc/dst: Index or name of the vertices at src and dst end. Enables graphless constructor.\nff: FeedForwardType of component. Will be typically infered from g automaticially.\nobssym/obsf: Define additional \"observable\" states.\nsymmetadata/metadata: Provide prefilled metadata dictionaries.\nextin=nothing:  Define \"external\" inputs for the model with Network indices, i.e. extin=[VIndex(7,:x), ..].  Those inputs will be provided as another input vector f(x, insrc, indst, extin, p, t) and g(ysrc, ydst, x, insrc, indst, extin, p, t).\n\nAll Symbol arguments can be used to set default values, i.e. psym=[:K=>1, :p].\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.LoopbackConnection","page":"API","title":"NetworkDynamics.LoopbackConnection","text":"LoopbackConnection(; potential, flow, kwargs...)\n\nA LoopbackConnection is a special EdgeModel that enables direct connection of \"injector nodes\" to a \"hub\" node without requiring aggregation logic. An injector node is an \"inverted\" VertexModel, which gets the networks potential as an input and outputs a flow variable.\n\nThe LoopbackConnection allows a direct, star-like connection of injector nodes to a single hub nodes. The LoopbackConnection is a directed edge model from injector to hub!\n\n       ┊\n    ┄┄┄◯   ● injector 1\n      ╱ ╲ ╱\n   ┄┄◯╶─╴◯╶─╴● injector 2\n     ┊    ╲\n           ● injector 3\n\nInjector nodes:\n\nhave a flipped interface (potential in, flow out)\nmust be leaf nodes (one neighbor only),\nmust be connected through a LoopbackConnection EdgeModel and\nmay have feed-forward (direct dependency of flow-output on potential-input).\n\nnote: Sign Convention\nFor normal vertices, positive flow as an input means flow into the vertex. This convention is maintained for injector nodes (though it may seem counter-intuitive):Positive flow: Draw from the hub (consumption)\nNegative flow: Injection into the hub (production)When using ModelingToolkit models, you only need to flip the input/output variable declarations—the equations themselves remain unchanged. For example, a resistor with p.i ~ p.v/R keeps the same equation; only the interface changes from VertexModel(..., [:p₊i], [:p₊v]) to VertexModel(..., [:p₊v], [:p₊i]).\n\n                       △\n      ╭────────────────┼────────────╮\n      │      potential │ φ out      │\n━━━━━━▽━━┓   ╔═════════△═════════╗  │  ┏━━━━━━━┓   ╔═══════════════════╗\n normal  ┃   ║ VertexModel (hub) ║  ╰──▷┄┄┄┄┄┄┄▷───▷ Injector Vertex   ║\nEdgeModel┃   ║ ẋ = f(x, Φ, p, t) ║     ┃       ┃   ║ ẋ = f(x, φ, p, t) ║\n         ┃   ║ φ = g(x, p, t)    ║  ╭──◁┄×(-1)┄◁───◁ Φ = g(x, φ, p, t) ║\n━━━━━━▽━━┛   ╚═════════△═════════╝  │  ┗━━━━━━━┛   ╚═══════════════════╝\n flow │ Φ out        ╭─┴─╮          │  special      ⋅ flipped interface:\n      ╰──────────────▷ + ◁──────────╯  \"Loopback\"     ▷ potential φ in\n       (aggregation) ╰─△─╯             EdgeModel      ◁ flow Φ out\n                       │               inj => hub   ⋅ feed forward allowed\n\nFor input-output naming you need to provide the potential and flow symbols.\n\njulia> LoopbackConnection(; potential=[:u_r, :u_i], flow=[:i_r, :i_i], src=1, dst=2)\nEdgeModel :loopback PureFeedForward() @ Edge 1=>2\n ├─ 2/2 inputs:  src=[injector₊i_r, injector₊i_i] dst=[hub₊u_r, hub₊u_i]\n ├─   0 states:  []\n └─ 2/2 outputs: src=[injector₊u_r, injector₊u_i] dst=[hub₊i_r, hub₊i_i]\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.VertexModel-Tuple{System, Any, Any}","page":"API","title":"NetworkDynamics.VertexModel","text":"VertexModel(sys::System, inputs, outputs;\n            verbose=false, name=getname(sys), extin=nothing, ff_to_constraint=true, kwargs...)\n\nCreate a VertexModel object from a given System created with ModelingToolkit. You need to provide 2 lists of symbolic names (Symbol or Vector{Symbols}):\n\ninputs: names of variables in you equation representing the aggregated edge states\noutputs: names of variables in you equation representing the node output\n\nAdditional kw arguments:\n\nname: Set name of the component model. Will be lifted from the System name.\nextin=nothing: Provide external inputs as pairs, i.e. extin=[:extvar => VIndex(1, :a)]  will bound the variable extvar(t) in the equations to the state a of the first vertex.\nff_to_constraint=true: Controls, whether output transformations g which depend on inputs should be transformed into constraints. Defaults to true since ND.jl does not handle vertices with FF yet.\nassume_io_coupling=false: If true, assumes direct dependency chain from outputs to inputs by adding implicit output terms to all inputs. This forces MTK to consider the dependency during compilation and can help in cases where MTK simplification results in derivatives of inputs.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.EdgeModel-Tuple{System, Vararg{Any, 4}}","page":"API","title":"NetworkDynamics.EdgeModel","text":"EdgeModel(sys::System, srcin, dstin, srcout, dstout;\n          verbose=false, name=getname(sys), extin=nothing, ff_to_constraint=false, kwargs...)\n\nCreate a EdgeModel object from a given System created with ModelingToolkit. You need to provide 4 lists of symbolic names (Symbol or Vector{Symbols}):\n\nsrcin: names of variables in you equation representing the node state at the source\ndstin: names of variables in you equation representing the node state at the destination\nsrcout: names of variables in you equation representing the output at the source\ndstout: names of variables in you equation representing the output at the destination\n\nAdditional kw arguments:\n\nname: Set name of the component model. Will be lifted from the System name.\nextin=nothing: Provide external inputs as pairs, i.e. extin=[:extvar => VIndex(1, :a)]  will bound the variable extvar(t) in the equations to the state a of the first vertex.\nff_to_constraint=false: Controls, whether output transformations g which depend on inputs should be transformed into constraints.\nassume_io_coupling=false: If true, assumes direct dependency chain from outputs to inputs by adding implicit output terms to all inputs. This forces MTK to consider the dependency during compilation and can help in cases where MTK simplification results in derivatives of inputs.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.EdgeModel-Tuple{System, Any, Any, Any}","page":"API","title":"NetworkDynamics.EdgeModel","text":"EdgeModel(sys::System, srcin, dstin, AntiSymmetric(dstout); kwargs...)\n\nCreate a EdgeModel object from a given System created with ModelingToolkit for single sided models.\n\nHere you only need to provide one list of output symbols: dstout. To make it clear how to handle the single-sided output definition, you must wrap the symbol vector in\n\nAntiSymmetric(dstout),\nSymmetric(dstout), or\nDirected(dstout).\n\nAdditional kwargs are the same as for the double-sided EdgeModel MTK constructor.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.ComponentPostprocessing","page":"API","title":"NetworkDynamics.ComponentPostprocessing","text":"ComponentPostprocessing\n\nCustom MTK metadata type, you can add it to register a postprocessing function f for your model\n\nfunction my_postproc(cm::Union{VertexModel, EdgeModel}, namespace)\n    # alter the cm as needed, for example add callbacks\nend\n@mtkmodel MyModel begin\n    ...\n    @metadata begin\n        ComponentPostprocessing = my_postproc\n    end\n    ...\nend\n\nThe postprocessing function will be called at the end of the VertexModel/EdgeModel construction after the model compilation. You can use it to add custom callbacks or init functions/metadata to the generated component. The function gets both the component model to modify and the namespace (as string) of the model.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.with_mtk_model_cache","page":"API","title":"NetworkDynamics.with_mtk_model_cache","text":"NetworkDynamics.with_mtk_model_cache(f, usecache=true)\n\nExperimental: Enable caching of compiled MTK component functions during model construction.\n\nWhen building multiple VertexModel or EdgeModel components from ModelingToolkit systems, the expensive symbolic processing and code generation steps can be cached and reused. This function provides a convenient block syntax to enable caching temporarily.\n\nArguments\n\nf: A callable (typically a do block) that performs component model construction\nusecache=true: Optional boolean to enable/disable caching for this block\n\nUsage\n\nNetworkDynamics.with_mtk_model_cache() do\n    # code which generates and compiles mtk models\nend\n\nThe cache is automatically disabled when the block exits, ensuring clean state.\n\nWhen to Use\n\nThis optimization is beneficial when:\n\nBuilding multiple components from identical MTK systems (e.g., repeated vertex types)\nPerforming batch or exploratory model construction workflows\nConstructing components in parallel across multiple threads\n\nThe cache is thread safe, so you can safely build components concurrently.\n\nwarning: Experimental Feature\nThis caching mechanism is experimental and may change in future versions. The cache assumes that MTK equation processing is deterministic and does not change between calls.\n\nSee also: NetworkDynamics.mtk_cache_stats\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.mtk_cache_stats","page":"API","title":"NetworkDynamics.mtk_cache_stats","text":"NetworkDynamics.mtk_cache_stats()\n\nPrint statistics about the MTK model cache usage during the last NetworkDynamics.with_mtk_model_cache block.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.StateMask","page":"API","title":"NetworkDynamics.StateMask","text":"StateMask(i::AbstractArray)\nStateMaks(i::Number)\n\nA StateMask is a predefined output function. It can be used to define the output of a component model by picking from the internal state.\n\nI.e. g=StateMask(2:3) in a vertex function will output the internal states 2 and 3. In many contexts, StateMasks can be constructed implicitly by just providing the indices, e.g. g=1:2.\n\nFor EdgeModel this needs to be combined with a Directed, Symmetric, AntiSymmetric or Fiducial coupling, e.g. g=Fiducial(1:2, 3:4) forwards states 1:2 to dst and states 3:4 to src.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.Symmetric","page":"API","title":"NetworkDynamics.Symmetric","text":"Symmetric(g)\n\nWraps a single-sided output function g turns it into a double sided output function which applies\n\ny_dst = g(...)\ny_src = y_dst\n\ng can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also AntiSymmetric, Directed, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.AntiSymmetric","page":"API","title":"NetworkDynamics.AntiSymmetric","text":"AntiSymmetric(g_dst)\n\nWraps a single-sided output function g_dst turns it into a double sided output function which applies\n\ny_dst = g_dst(...)\ny_src = -y_dst\n\ng_dst can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also Symmetric, Directed, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.Directed","page":"API","title":"NetworkDynamics.Directed","text":"Directed(g_dst)\n\nWraps a single-sided output function g_dst turns it into a double sided output function which applies\n\ny_dst = g_dst(...)\n\nWith Directed there is no output for the src side. g_dst can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also AntiSymmetric, Symmetric, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.Fiducial","page":"API","title":"NetworkDynamics.Fiducial","text":"Fiducial(g_src, g_dst)\n\nWraps two single-sided output function g_src and g_dst and turns them into a double sided output function which applies\n\ny_dst = g_src(...)\ny_src = g_dst(...)\n\ng can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also AntiSymmetric, Directed, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.fftype","page":"API","title":"NetworkDynamics.fftype","text":"fftype(x)\n\nRetrieve the feed forward trait of x.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.dim-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"NetworkDynamics.dim","text":"dim(c::ComponentModel)::Int\n\nRetrieve the dimension of the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.sym","page":"API","title":"NetworkDynamics.sym","text":"sym(c::ComponentModel)::Vector{Symbol}\n\nRetrieve the symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.outdim","page":"API","title":"NetworkDynamics.outdim","text":"outdim(c::VertexModel)::Int\noutdim(c::EdgeModel)::@NamedTuple(src::Int, dst::Int)\n\nRetrieve the output dimension of the component\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.outsym","page":"API","title":"NetworkDynamics.outsym","text":"outsym(c::VertexModel)::Vector{Symbol}    outsym(c::EdgeModel)::@NamedTuple{src::Vector{Symbol}, dst::Vector{Symbol}}\n\nRetrieve the output symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.pdim-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"NetworkDynamics.pdim","text":"pdim(c::ComponentModel)::Int\n\nRetrieve the parameter dimension of the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.psym","page":"API","title":"NetworkDynamics.psym","text":"psym(c::ComponentModel)::Vector{Symbol}\n\nRetrieve the parameter symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.obssym","page":"API","title":"NetworkDynamics.obssym","text":"obssym(c::ComponentModel)::Vector{Symbol}\n\nRetrieve the observation symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.hasinsym","page":"API","title":"NetworkDynamics.hasinsym","text":"hasinsym(c::ComponentModel)\n\nChecks if the optioan field insym is present in the component model.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.insym","page":"API","title":"NetworkDynamics.insym","text":"insym(c::VertexModel)::Vector{Symbol}\ninsym(c::EdgeModel)::@NamedTuple{src::Vector{Symbol}, dst::Vector{Symbol}}\n\nMusst be called after hasinsym/hasindim returned true. Gives the insym vector(s). For vertex model just a single vector, for edges it returns a named tuple (; src, dst) with two symbol vectors.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.hasindim","page":"API","title":"NetworkDynamics.hasindim","text":"hasindim(c::ComponentModel)\n\nChecks if the optioan field insym is present in the component model.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.indim","page":"API","title":"NetworkDynamics.indim","text":"indim(c::VertexModel)::Int\nindim(c::EdgeModel)::@NamedTuple{src::Int,dst::Int}\n\nMusst be called after hasinsym/hasindim returned true. Gives the input dimension(s).\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.FeedForwardType","page":"API","title":"NetworkDynamics.FeedForwardType","text":"abstract type FeedForwardType end\n\nAbstract supertype for the FeedForwardType traits.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PureFeedForward","page":"API","title":"NetworkDynamics.PureFeedForward","text":"PureFeedForward <: FeedForwardType\n\nTrait for component output functions g that have pure feed forward behavior (do not depend on x):\n\ng!(outs..., ins..., p, t)\n\nSee also FeedForward, NoFeedForward and PureStateMap.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.FeedForward","page":"API","title":"NetworkDynamics.FeedForward","text":"FeedForward <: FeedForwardType\n\nTrait for component output functions g that have feed forward behavior. May depend on everything:\n\ng!(outs..., x, ins..., p, t)\n\nSee also PureFeedForward, NoFeedForward and PureStateMap.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.NoFeedForward","page":"API","title":"NetworkDynamics.NoFeedForward","text":"NoFeedForward <: FeedForwardType\n\nTrait for component output functions g that have no feed forward behavior (do not depend on inputs):\n\ng!(outs..., x, p, t)\n\nSee also PureFeedForward, FeedForward and PureStateMap.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PureStateMap","page":"API","title":"NetworkDynamics.PureStateMap","text":"PureStateMap <: FeedForwardType\n\nTrait for component output functions g that only depends on state:\n\ng!(outs..., x)\n\nSee also PureFeedForward, FeedForward and NoFeedForward.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.NWParameter","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(nw_or_nw_wrapper, pflat)\n\nIndexable wrapper for flat parameter array pflat. Needs Network or wrapper of Network, e.g. ODEProblem.\n\np = NWParameter(nw)\np.v[idx, :sym]               # get parameter :sym of vertex idx\np.e[idx, :sym]               # get parameter :sym of edge idx\np[VIndex(idx, :sym)]         # get parameter using VIndex\np[VIndex(idx, ParamIdx(1))]  # get first parameter by numeric index\n\nUsing the special .v and .e properties, you get a FilteringProxy object which allows for interactive filtering, inspection and changing of parameters. See FilteringProxy for details.\n\nGet flat array representation using pflat. The order of parameters in the flat representation corresponds to the order given by parameter_symbols.\n\nSee also: NWState, VIndex, EIndex, generate_indices, FilteringProxy\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.NWParameter-Tuple{Any}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(nw_or_nw_wrapper;\n            ptype=Vector{Float64}, pfill=filltype(ptype), default=true)\n\nCreates \"empty\" NWParameter object for the Network/Wrapper nw with flat type ptype. The array will be prefilled with pfill (defaults to NaN).\n\nIf default=true the default parameter values attached to the network components will be loaded.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWParameter-Tuple{NWParameter}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(p::NWParameter; ptype=typeof(p.pflat))\n\nCreate NWParameter based on other parameter object, just convert type.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWParameter-Tuple{SciMLBase.DEIntegrator}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(int::SciMLBase.DEIntegrator)\n\nCreate NWParameter object from integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.pflat","page":"API","title":"NetworkDynamics.pflat","text":"pflat(p::NWParameter)\npflat(s::NWState)\n\nRetrieve the wrapped flat array representation of the parameters. The order of parameters in this flat representation corresponds exactly to the order given by parameter_symbols.\n\n\n\n\n\n","category":"function"},{"location":"API/#SymbolicIndexingInterface.parameter_symbols","page":"API","title":"SymbolicIndexingInterface.parameter_symbols","text":"SymbolicIndexingInterface.parameter_symbols(nw::Network)\n\nReturns a vector of all symbolic network indices which in the same order as the flat parameter vector.\n\nSee also: NWParameter, NWState, pflat.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.NWState","page":"API","title":"NetworkDynamics.NWState","text":"NWState(nw_or_nw_wrapper, uflat, [pflat], [t])\n\nIndexable wrapper for flat state & parameter array. Needs Network or wrapper of Network, e.g. ODEProblem.\n\ns = NWState(nw)\ns.v[idx, :sym]                   # get state :sym of vertex idx\ns.e[idx, :sym]                   # get state :sym of edge idx\ns.p.v[idx, :sym]                 # get parameter :sym of vertex idx\ns.p.e[idx, :sym]                 # get parameter :sym of edge idx\ns[VIndex(idx, :sym)]             # get state using VIndex\ns[VIndex(idx, StateIdx(1))]      # get first state by numeric index\ns[VIndex(idx, ParamIdx(1))]      # get first parameter by numeric index\n\nUsing the special .v and .e properties, you get a FilteringProxy object which allows for interactive filtering, inspection and changing of states. See FilteringProxy for details.\n\nGet flat array representation using uflat and pflat. The order of states in the flat representation corresponds to the order given by variable_symbols, and the order of parameters corresponds to parameter_symbols.\n\nSee also: NWParameter, VIndex, EIndex, generate_indices, FilteringProxy\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.NWState-Tuple{Any}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(nw_or_nw_wrapper;\n        utype=Vector{Float64}, ufill=filltype(utype),\n        ptype=Vector{Float64}, pfill=filltype(ptype), default=true)\n\nCreates \"empty\" NWState object for the Network/Wrapper nw with flat types utype & ptype. The arrays will be prefilled with ufill and pfill respectively (defaults to NaN).\n\nIf default=true the default state & parameter values attached to the network components will be loaded.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWState-Tuple{NWState}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(s::NWState; utype=typeof(uflat(s)), ptype=typeof(pflat(s)))\n\nCreate NWState based on other state object, just convert types.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWState-Tuple{NWParameter}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(p::NWParameter; utype=Vector{Float64}, ufill=filltype(utype), default=true)\n\nCreate NWState based on existing NWParameter object.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWState-Tuple{SciMLBase.DEIntegrator}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(int::SciMLBase.DEIntegrator)\n\nCreate NWState object from integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.uflat","page":"API","title":"NetworkDynamics.uflat","text":"uflat(s::NWState)\n\nRetrieve the wrapped flat array representation of the state. The order of states in this flat representation corresponds exactly to the order given by variable_symbols.\n\n\n\n\n\n","category":"function"},{"location":"API/#SymbolicIndexingInterface.variable_symbols","page":"API","title":"SymbolicIndexingInterface.variable_symbols","text":"SymbolicIndexingInterface.variable_symbols(nw::Network)\n\nReturns a vector of all symbolic network indices which in the same order as the flat state vector.\n\nSee also: NWState, uflat.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.VIndex","page":"API","title":"NetworkDynamics.VIndex","text":"VIndex{C,S} <: SymbolicIndex{C,S}\nidx = VIndex(comp, sub)\n\nA symbolic index for a vertex variable.\n\ncomp: the component index, either int, symbol or a collection\nsub: the subindex, either int, symbol or a collection of those.\n\nSymbolic indices are rather flexible and can potentially point to states, parameters, inputs, outputs, or observables.\n\nThe most basic form is VIndex(1, :P) which points to the variable with the name :P in the first vertex model. The component can be also given by unique name, so VIndex(:a, :P) would point to the vertex with unique name :a.\n\nIt is also possible to have \"collections\" of indices, such as\n\nVIndex(1:5, 1)     # first state of vertices 1 to 5\nVIndex(7, (:x,:y)) # states :x and :y of vertex 7\n\nThey can be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWState, NWParameter or ODESolution.\n\nIt is also possible to construct vertices without a sub index, in which case they point to a component rather than a specific variable:\n\nVIndex(2)          # references the second vertex model\nVIndex(:a)         # references vertex with unique name :a\n\nFor example nw[VIndex(2)] would return the 2nd VertexModel in the Network.\n\nSee also: EIndex, StateIdx, ParamIdx, generate_indices, NWState, NWParameter\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.EIndex","page":"API","title":"NetworkDynamics.EIndex","text":"EIndex{C,S} <: SymbolicIndex{C,S}\nidx = EIndex(comp, sub)\n\nA symbolic index for an edge variable.\n\ncomp: the component index, either int, symbol, pair or a collection\nsub: the subindex, either int, symbol or a collection of those.\n\nSymbolic indices are rather flexible and can potentially point to states, parameters, inputs, outputs, or observables.\n\nThe most basic form is EIndex(1, :P) which points to the variable with the name :P in the first edge model. The component can be also given by unique name, so EIndex(:a, :P) would point to the edge with unique name :a. For edges, the component can also be specified as a source-destination pair:\n\nEIndex(1=>2, :P)    # variable :P in edge from vertex 1 to vertex 2\nEIndex(:a=>:b, :P)  # variable :P in edge from vertex :a to vertex :b\n\nIt is also possible to have \"collections\" of indices, such as\n\nEIndex(1:5, 1)     # first state of edges 1 to 5\nEIndex(7, (:x,:y)) # states :x and :y of edge 7\n\nThey can be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWState, NWParameter or ODESolution.\n\nIt is also possible to construct edges without a sub index, in which case they point to a component rather than a specific variable:\n\nEIndex(2)          # references the second edge model\nEIndex(1=>2)       # references edge from v1 to v2\nEIndex(:a=>:b)     # references edge from vertex :a to vertex :b\n\nFor example nw[EIndex(2)] would return the 2nd EdgeModel in the Network.\n\nSee also: VIndex, StateIdx, ParamIdx, generate_indices, NWState, NWParameter\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ParamIdx","page":"API","title":"NetworkDynamics.ParamIdx","text":"ParamIdx{T} <: NumericSubIndex{T}\n\nWrapper type for indexing into parameters by index rather than symbol. VPIndex(:name, 1) is equivalent to VIndex(:name, ParamIdx(1)) and tells NetworkDynamics that you mean the first parameter of the component in contrast to the first state of the component. Similarly, ParamIdx(:), ParamIdx(1:3) or ParamIdx([1,2,3]) can be used to access multiple parameters by numeric index at once.\n\nSee also: StateIdx, VIndex, EIndex\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.StateIdx","page":"API","title":"NetworkDynamics.StateIdx","text":"StateIdx{T} <: NumericSubIndex{T}\n\nWrapper type for indexing into states by index rather than symbol. VIndex(:name, 1) is equivalent to VIndex(:name, StateIdx(1)) and tells NetworkDynamics that you mean the first state of the component in contrast to the first parameter of the component. Similarly, StateIdx(:), StateIdx(1:3) or StateIdx([1,2,3]) can be used to access multiple states by numeric index at once.\n\nSee also: ParamIdx, VIndex, EIndex\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.@obsex","page":"API","title":"NetworkDynamics.@obsex","text":"@obsex([name =] expression)\n\nDefine observable expressions, which are simple combinations of known states/parameters/observables. @obsex(...) returns an ObservableExpression which can be used as an symbolic index. This is mainly intended for quick plotting or export of common \"derived\" variables, such as the argument of a 2-component complex state. For example:\n\nsol(t; idxs=@obsex(arg = atan(VIndex(1,:u_i), VIndex(1,:u_r))]\nsol(t; idxs=@obsex(δrel = VIndex(1,:δ) - VIndex(2,:δ)))\n\n\n\n\n\n","category":"macro"},{"location":"API/#NetworkDynamics.VPIndex","page":"API","title":"NetworkDynamics.VPIndex","text":"VPIndex(c, s)\n\nBackward compatibility constructor for vertex parameter indices. Wraps integer-like subindices in ParamIdx, leaves other types unchanged. Equivalent to VIndex(c, ParamIdx(s)) when s is integer-like, otherwise VIndex(c, s).\n\nSee also: VIndex, ParamIdx\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.EPIndex","page":"API","title":"NetworkDynamics.EPIndex","text":"EPIndex(c, s)\n\nBackward compatibility constructor for edge parameter indices. Wraps integer-like subindices in ParamIdx, leaves other types unchanged. Equivalent to EIndex(c, ParamIdx(s)) when s is integer-like, otherwise EIndex(c, s).\n\nSee also: EIndex, ParamIdx\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.generate_indices","page":"API","title":"NetworkDynamics.generate_indices","text":"generate_indices(inpr, compfilter=nothing, varfilter=nothing;\n                s=true, p=true, out=true, obs=true, in=true, just_count=false)\n\nGenerate collections of valid symbolic indices with flexible filtering criteria.\n\nArguments\n\ninpr: Index provider - Network or Network wrapper like NWState, NWParameter, sol, etc.\ncompfilter\nnothing - matches all components (default)\nVIndex(1) - matches component by number\nVIndex(:name) - matches by exact component name\nVIndex(\"pattern\") or VIndex(r\"pattern\") - matches by contains(name, pattern)\nVector-like: VIndex(1:10) matches vertices 1-10, [VIndex(:), EIndex(:)] matches all vertices and edges\nEIndex(src=>dst) - matches edges where src and dst vertices match (can be Int, Symbol, Regex, ...)\nvarfilter\nnothing - matches all variables (default)\n:name - matches variable :name exactly\n\"namepart\" or r\"namepart\" - matches by contains(variable_name, pattern)\nStateIdx(1) or ParamIdx(1) - matches by numeric position\nVector-like: [:foo, StateIdx(1), r\"part\"] matches any of the filters\n\nKeyword Arguments\n\ns=true - include states\np=true - include parameters\nout=true - include outputs\nobs=false - include observables\nin=false - include inputs\njust_count=false - return count instead of indices\n\nExamples\n\n# All vertex states and parameters\ngenerate_indices(nw, VIndex(:))\n\n# Parameters of vertex with name :generator\ngenerate_indices(nw, VIndex(:generator); s=false, p=true, out=false)\n\n# All variables containing \"voltage\" in vertices 1-5\ngenerate_indices(nw, VIndex(1:5), \"voltage\")\n\n# First parameter of all vertices using numeric indexing\ngenerate_indices(nw, VIndex(:), ParamIdx(1); s=false, out=false)\n\nSee also: FilteringProxy, vidxs, eidxs, vpidxs, epidxs\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.vidxs","page":"API","title":"NetworkDynamics.vidxs","text":"vidxs(nw, cf=:, vf=nothing; kwargs...)\n\nGenerate vertex indices for states, parameters, inputs, outputs, and observables. Equivalent to generate_indices(nw, VIndex(cf), vf; s=true, p=true, in=true, out=true, obs=true, kwargs...).\n\nSee also: generate_indices\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.eidxs","page":"API","title":"NetworkDynamics.eidxs","text":"eidxs(nw, cf=:, vf=nothing; kwargs...)\n\nGenerate edge indices for states, parameters, inputs, outputs, and observables. Equivalent to generate_indices(nw, EIndex(cf), vf; s=true, p=true, in=true, out=true, obs=true, kwargs...).\n\nSee also: generate_indices\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.vpidxs","page":"API","title":"NetworkDynamics.vpidxs","text":"vpidxs(nw, cf=:, vf=nothing; kwargs...)\n\nGenerate vertex parameter indices. Equivalent to generate_indices(nw, VIndex(cf), vf; s=false, p=true, in=false, out=false, obs=false, kwargs...).\n\nSee also: generate_indices\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.epidxs","page":"API","title":"NetworkDynamics.epidxs","text":"epidxs(nw, cf=:, vf=nothing; kwargs...)\n\nGenerate edge parameter indices. Equivalent to generate_indices(nw, EIndex(cf), vf; s=false, p=true, in=false, out=false, obs=false, kwargs...).\n\nSee also: generate_indices\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.FilteringProxy","page":"API","title":"NetworkDynamics.FilteringProxy","text":"FilteringProxy{S,CF,VF} <: IndexingProxy{S}\nFilteringProxy(s::NWState)\nFilteringProxy(p::NWParameter)\n(s::NWState).v # creates a FilteringProxy\n\nInteractive filtering proxy for exploring and accessing states/parameters in NetworkDynamics objects.\n\nFilteringProxy provides a flexible, interactive way to filter and access network variables through a progressive refinement system. It acts as a \"proxy\" that changes indexing rules while operating on the same underlying data, allowing both exploration and modification of network states/parameters.\n\nCore Concept\n\nThe proxy uses a filter refinement approach where each indexing operation either:\n\nReturns a more refined FilteringProxy (if the filter needs more specificity)\nReturns the actual values (if the filter is fully specified)\n\nAll filtering operations translate to equivalent generate_indices calls under the hood.\n\nStage 1: Component Filtering\n\nAccess vertices and edges using .v and .e properties:\n\ns = NWState(nw)\ns.v          # FilteringProxy for all vertices\ns.e          # FilteringProxy for all edges\ns.v[1]       # Refine to vertex 1\ns.v[:gen]    # Refine to vertices named :gen\ns.v[r\"load\"] # Refine to vertices matching pattern\nFilteringProxy(s)[[VIndex(1), EIndex(2)]] # filter down to the first vertex and second edge\n\nStage 2: Variable Filtering\n\nOnce the component filter is set, the next indexing operation will refine the variable filter.\n\ns.v[1][:voltage]          # value of Vertex(1) + variable called :voltage\ns.v[:][r\"δ\"]              # value of all variables containing \"δ\" of all vertices\ns.e[1=>2].s[StateIdx(1)]  # First state of edge from vertex 1 to 2\n\nVariable Type Filtering\n\nUse type switches to select specific variable categories:\n\ns.v.p        # Parameters only\ns.v.s        # States only\ns.v.out      # Outputs only\ns.v.obs      # Observables only\ns.v.in       # Inputs only\ns.v.all      # All variable types\ns.v(; p=true, s=true) # fine grade filter update using function call syntax\n\nFunction Call Syntax\n\nUse function call syntax proxy(args...) to refine without collapsing to values:\n\nproxy = s.v(1)(:voltage)  # Build filter without accessing values\nvalue = proxy[]           # Access value when ready\n\nThe function call syntax can also be used to refine any other properties. The properties match the argument names of generate_indices\n\ns.v[1](; p=true)            # equivalent to s.v[1].p\ns.v(; compfilter=EIndex(:)) # resets the compfilter and now matches all edges\n\nUtility Methods\n\nkeys(proxy) - Get matching symbolic indices via generate_indices\nvalues(proxy) / proxy[] - Get actual values for all matching indices\n\nSee also: generate_indices, NWState, NWParameter, VIndex, EIndex\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.metadata","page":"API","title":"NetworkDynamics.metadata","text":"metadata(c::ComponentModel)\n\nRetrieve metadata object for the component.\n\nSee also metadata\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}","page":"API","title":"NetworkDynamics.has_metadata","text":"has_metadata(c::ComponentModel, key::Symbol)\nhas_metadata(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)\n\nChecks if metadata key is present for the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}","page":"API","title":"NetworkDynamics.get_metadata","text":"get_metadata(c::ComponentModel, key::Symbol)\nget_metadata(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)\n\nRetrieves the metadata key for the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}","page":"API","title":"NetworkDynamics.set_metadata!","text":"set_metadata!(c::ComponentModel, key::Symbol, value)\nset_metadata!(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol, value)\n\nSets the metadata key for the component to value.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol}","page":"API","title":"NetworkDynamics.delete_metadata!","text":"delete_metadata!(c::ComponentModel, key::Symbol)\ndelete_metadata!(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)\n\nRemoves the component-wide metadata key from the component model, or from a component referenced by idx in a network. Returns true if the metadata existed and was removed, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.has_graphelement","page":"API","title":"NetworkDynamics.has_graphelement","text":"has_graphelement(c::ComponentModel)\nhas_graphelement(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the edge or vertex function has the graphelement metadata.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_graphelement","page":"API","title":"NetworkDynamics.get_graphelement","text":"get_graphelement(c::EdgeModel)::@NamedTuple{src::T, dst::T}\nget_graphelement(c::VertexModel)::Int\nget_graphelement(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the graphelement metadata for the component model. For edges this returns a named tuple (;src, dst) where both are either integers (vertex index) or symbols (vertex name).\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_graphelement!","page":"API","title":"NetworkDynamics.set_graphelement!","text":"set_graphelement!(c::EdgeModel, nt::@NamedTuple{src::T, dst::T})\nset_graphelement!(c::EdgeModel, p::Pair)\nset_graphelement!(c::VertexModel, vidx::Int)\nset_graphelement!(nw::Network, idx::Union{VIndex,EIndex}, value)\n\nSets the graphelement metadata for the component. For edges this takes a named tuple (;src, dst) where both are either integer (vertex index) or symbol (vertex name). For vertices it takes a single integer vidx.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_position","page":"API","title":"NetworkDynamics.has_position","text":"has_position(v::VertexModel)\nhas_position(nw::Network, vidx::VIndex)\n\nChecks if vertex v has position metadata.\n\nSee also: get_position, set_position!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_position","page":"API","title":"NetworkDynamics.get_position","text":"get_position(v::VertexModel)\nget_position(nw::Network, vidx::VIndex)\n\nReturns the position metadata of vertex v. Might error if not present.\n\nSee also: has_position, set_position!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_position!","page":"API","title":"NetworkDynamics.set_position!","text":"set_position!(v::VertexModel, val)\nset_position!(nw::Network, vidx::VIndex, val)\n\nSets the position metadata of vertex v to val.\n\nSee also: has_position, get_position.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_marker","page":"API","title":"NetworkDynamics.has_marker","text":"has_marker(v::VertexModel)\nhas_marker(nw::Network, vidx::VIndex)\n\nChecks if vertex v has marker metadata.\n\nSee also: get_marker, set_marker!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_marker","page":"API","title":"NetworkDynamics.get_marker","text":"get_marker(v::VertexModel)\nget_marker(nw::Network, vidx::VIndex)\n\nReturns the marker metadata of vertex v. Might error if not present.\n\nSee also: has_marker, set_marker!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_marker!","page":"API","title":"NetworkDynamics.set_marker!","text":"set_marker!(v::VertexModel, val)\nset_marker!(nw::Network, vidx::VIndex, val)\n\nSets the marker metadata of vertex v to val.\n\nSee also: has_marker, get_marker.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.symmetadata","page":"API","title":"NetworkDynamics.symmetadata","text":"symmetadata(c::ComponentModel)::Dict{Symbol,Dict{Symbol,Any}}\n\nRetrieve the metadata dictionary for the symbols. Keys are the names of the symbols as they appear in sym, psym, obssym and insym.\n\nSee also symmetadata\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}","page":"API","title":"NetworkDynamics.get_metadata","text":"get_metadata(c::ComponentModel, sym::Symbol, key::Symbol)\nget_metadata(nw::Network, sni::SymbolicIndex, key::Symbol)\n\nRetrieves the metadata key for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can also be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nThrows an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}","page":"API","title":"NetworkDynamics.has_metadata","text":"has_metadata(c::ComponentModel, sym::Symbol, key::Symbol)\nhas_metadata(nw::Network, sni::SymbolicIndex, key::Symbol)\n\nChecks if symbol metadata key is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can also be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nThrows an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol, Any}","page":"API","title":"NetworkDynamics.set_metadata!","text":"set_metadata!(c::ComponentModel, sym::Symbol, key::Symbol, value)\nset_metadata!(nw::Network, sni::SymbolicIndex, key::Symbol, value)\nset_metadata!(c::ComponentModel, sym::Symbol, pair::Pair)\nset_metadata!(nw::Network, sni::SymbolicIndex, pair::Pair)\n\nSets the metadata key for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nFor component models, you can also use a String or Regex pattern to match symbol names:\n\nString patterns use substring matching (e.g., \"δ\" matches machine₊δ)\nRegex patterns use full regex matching (e.g., r\"P$\" matches symbols ending with \"P\")\n\nThis will error if there are none or multiple matches.\n\nIf the pattern matches multiple symbols, an error is thrown. Use a more specific pattern. Throws an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}","page":"API","title":"NetworkDynamics.delete_metadata!","text":"delete_metadata!(c::ComponentModel, sym::Symbol, key::Symbol)\ndelete_metadata!(nw::Network, sni::SymbolicIndex, key::Symbol)\n\nRemoves the metadata key for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can also be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nReturns true if the metadata existed and was removed, false otherwise. Throws an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.strip_metadata!","page":"API","title":"NetworkDynamics.strip_metadata!","text":"strip_metadata!(c::ComponentModel, key::Symbol)\n\nRemove all metadata of type key from the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_default","page":"API","title":"NetworkDynamics.has_default","text":"has_default(c::ComponentModel, sym::Symbol)\nhas_default(nw::Network, sni::SymbolicIndex)\n\nChecks if a default value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_default, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_default","page":"API","title":"NetworkDynamics.get_default","text":"get_default(c::ComponentModel, sym::Symbol)\nget_default(nw::Network, sni::SymbolicIndex)\n\nReturns the default value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_default, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_default!","page":"API","title":"NetworkDynamics.set_default!","text":"set_default!(c::ComponentModel, sym::Symbol, value)\nset_default!(nw::Network, sni::SymbolicIndex, value)\n\nSets the default value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_default, get_default.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_default!","page":"API","title":"NetworkDynamics.delete_default!","text":"delete_default!(c::ComponentModel, sym::Symbol)\ndelete_default!(nw::Network, sni::SymbolicIndex)\n\nRemoves the default value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_default, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_defaults!","page":"API","title":"NetworkDynamics.strip_defaults!","text":"strip_default!(c::ComponentModel)\nstrip_default!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all default values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_default!, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_guess","page":"API","title":"NetworkDynamics.has_guess","text":"has_guess(c::ComponentModel, sym::Symbol)\nhas_guess(nw::Network, sni::SymbolicIndex)\n\nChecks if a guess value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_guess, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_guess","page":"API","title":"NetworkDynamics.get_guess","text":"get_guess(c::ComponentModel, sym::Symbol)\nget_guess(nw::Network, sni::SymbolicIndex)\n\nReturns the guess value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_guess, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_guess!","page":"API","title":"NetworkDynamics.set_guess!","text":"set_guess!(c::ComponentModel, sym::Symbol, value)\nset_guess!(nw::Network, sni::SymbolicIndex, value)\n\nSets the guess value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_guess, get_guess.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_guess!","page":"API","title":"NetworkDynamics.delete_guess!","text":"delete_guess!(c::ComponentModel, sym::Symbol)\ndelete_guess!(nw::Network, sni::SymbolicIndex)\n\nRemoves the guess value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_guess, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_guesses!","page":"API","title":"NetworkDynamics.strip_guesses!","text":"strip_guess!(c::ComponentModel)\nstrip_guess!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all guess values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_guess!, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_init","page":"API","title":"NetworkDynamics.has_init","text":"has_init(c::ComponentModel, sym::Symbol)\nhas_init(nw::Network, sni::SymbolicIndex)\n\nChecks if a init value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_init, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_init","page":"API","title":"NetworkDynamics.get_init","text":"get_init(c::ComponentModel, sym::Symbol)\nget_init(nw::Network, sni::SymbolicIndex)\n\nReturns the init value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_init, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_init!","page":"API","title":"NetworkDynamics.set_init!","text":"set_init!(c::ComponentModel, sym::Symbol, value)\nset_init!(nw::Network, sni::SymbolicIndex, value)\n\nSets the init value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_init, get_init.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_init!","page":"API","title":"NetworkDynamics.delete_init!","text":"delete_init!(c::ComponentModel, sym::Symbol)\ndelete_init!(nw::Network, sni::SymbolicIndex)\n\nRemoves the init value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_init, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_inits!","page":"API","title":"NetworkDynamics.strip_inits!","text":"strip_init!(c::ComponentModel)\nstrip_init!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all init values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_init!, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_bounds","page":"API","title":"NetworkDynamics.has_bounds","text":"has_bounds(c::ComponentModel, sym::Symbol)\nhas_bounds(nw::Network, sni::SymbolicIndex)\n\nChecks if a bounds value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_bounds, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_bounds","page":"API","title":"NetworkDynamics.get_bounds","text":"get_bounds(c::ComponentModel, sym::Symbol)\nget_bounds(nw::Network, sni::SymbolicIndex)\n\nReturns the bounds value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_bounds, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_bounds!","page":"API","title":"NetworkDynamics.set_bounds!","text":"set_bounds!(c::ComponentModel, sym::Symbol, value)\nset_bounds!(nw::Network, sni::SymbolicIndex, value)\n\nSets the bounds value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_bounds, get_bounds.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_bounds!","page":"API","title":"NetworkDynamics.delete_bounds!","text":"delete_bounds!(c::ComponentModel, sym::Symbol)\ndelete_bounds!(nw::Network, sni::SymbolicIndex)\n\nRemoves the bounds value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_bounds, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_bounds!","page":"API","title":"NetworkDynamics.strip_bounds!","text":"strip_bounds!(c::ComponentModel)\nstrip_bounds!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all bounds values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_bounds!, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_defaults!","page":"API","title":"NetworkDynamics.set_defaults!","text":"set_defaults!(nw::Network, s::NWState)\n\nSet the default values of the network to the values of the given state. Can be used to \"store\" the found fixpoint in the network metadata.\n\nValues of missing, nothing or NaN are ignored.\n\n\n\n\n\nset_defaults!(nw::Network, p::NWParameter)\n\nSet the parameter default values of the network to the values of the given parameter object.\n\nValues of missing, nothing or NaN are ignored.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_interface_defaults!","page":"API","title":"NetworkDynamics.set_interface_defaults!","text":"set_interface_defaults!(nw::Network, s::NWState; verbose=false)\n\nSets the interface (i.e., node and edge inputs/outputs) defaults of a given network to the ones defined by the given state. Notably, while the graph topology and interface dimensions of the target network nw and the source network of s must be identical, the systems may differ in the dynamical components.\n\nThis is mainly intended for initialization purposes: solve the interface values with a simpler – possibly static – network and \"transfer\" the steady state interface values to the full network.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_defaults_dict","page":"API","title":"NetworkDynamics.get_defaults_dict","text":"get_defaults_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their default values. Only includes symbols that have default values set.\n\nSee also: get_guesses_dict, get_inits_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_guesses_dict","page":"API","title":"NetworkDynamics.get_guesses_dict","text":"get_guesses_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their guess values. Only includes symbols that have guess values set.\n\nSee also: get_defaults_dict, get_inits_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_bounds_dict","page":"API","title":"NetworkDynamics.get_bounds_dict","text":"get_bounds_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their bounds values. Only includes symbols that have bounds values set.\n\nSee also: get_defaults_dict, get_guesses_dict, get_inits_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_inits_dict","page":"API","title":"NetworkDynamics.get_inits_dict","text":"get_inits_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their initialization values. Only includes symbols that have initialization values set.\n\nSee also: get_defaults_dict, get_guesses_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.free_u","page":"API","title":"NetworkDynamics.free_u","text":"free_u(nw::Network)\nfree_u(cf::ComponentModel)\n\nReturns the \"free\" variables/states (variables without default values) for the given system.\n\nReturns\n\nVector of variable/state symbols that do not have default values set\n\nSee also: free_p, has_default, set_default!\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.free_p","page":"API","title":"NetworkDynamics.free_p","text":"free_p(cf::ComponentModel)\nfree_p(nw::Network)\n\nReturns the \"free\" parameters (parameters without default values) for the given system.\n\nReturns\n\nVector of parameter symbols that do not have default values set\n\nSee also: free_u, has_default, set_default!\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.dump_state","page":"API","title":"NetworkDynamics.dump_state","text":"dump_state([IO=stdout], sol, t, idx; sigdigits=5)\n\nTakes a Network solution sol and prints the state at t as well as the initial state of the specified component model to IO (defaults to stdout).\n\nidx musst a valid component index, i.e. VIndex or EIndex without symbol specification.\n\ndump_state(sol, 1.0, VIndex(4))\ndump_state(sol, 1.0, EIndex(2))\n\nSee also: dump_initial_state.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.dump_initial_state","page":"API","title":"NetworkDynamics.dump_initial_state","text":"dump_initial_state([IO=stdout], cf::ComponentModel,\n                   [defaults=get_defaults_dict(cf)],\n                   [inits=get_inits_dict(cf)],\n                   [guesses=get_guesses_dict(cf)],\n                   [bounds=get_bounds_dict(cf)];\n                   sigdigits=5, p=true, obs=true)\n\nPrints the initial state of the component model cf to IO (defaults to stdout). Optionally contains parameters and observed.\n\nSee also: get_initial_state and dump_state.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_initial_state","page":"API","title":"NetworkDynamics.get_initial_state","text":"get_initial_state(c::ComponentModel, [state=get_defaults_or_inits_dict(c)], syms; missing_val=nothing)\nget_initial_state(nw::Network, sni::SymbolicIndex; missing_val=nothing)\n\nReturns the initial state for symbol sym (single symbol or vector) of the component model c. Returns missing_val if the symbol is not initialized. Also works for observed symbols.\n\nSee also: dump_initial_state.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.describe_vertices","page":"API","title":"NetworkDynamics.describe_vertices","text":"describe_vertices(nw::Network, extras...; parameters=true, states=true, batch=nothing)\n\nCreates a DataFrame containing information about the vertices in a Network.\n\nArguments\n\nnw::Network: The network to describe\nextras...: Additional pairs of (key, function) to include as columns,  where the function gets the VertexModel as its only parameter  to extract a custom metadata field for example..\nparameters=true: Whether to include parameter values\nstates=true: Whether to include state values\nbatch=nothing: Optionally filter by specific batches\n\nReturns\n\nA DataFrame with columns for vertex indices, names, batch numbers, and any parameter/state values.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.describe_edges","page":"API","title":"NetworkDynamics.describe_edges","text":"describe_edges(nw::Network, extras...; parameters=true, states=true, batch=nothing)\n\nCreates a DataFrame containing information about the edges in a Network.\n\nArguments\n\nnw::Network: The network to describe\nextras...: Additional pairs of (key, function) to include as columns,  where the function gets the EdgeModel as its only parameter  to extract a custom metadata field for example..\nparameters=true: Whether to include parameter values\nstates=true: Whether to include state values\nbatch=nothing: Optionally filter by specific batches\n\nReturns\n\nA DataFrame with columns for edge indices, source-destination pairs, names, batch numbers, and any parameter/state values.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.find_fixpoint","page":"API","title":"NetworkDynamics.find_fixpoint","text":"find_fixpoint(nw::Network, [x0::NWState=NWState(nw)], [p::NWParameter=x0.p]; kwargs...)\nfind_fixpoint(nw::Network, x0::AbstractVector, p::AbstractVector; kwargs...)\n\nFind a steady-state (fixed-point) solution of the network dynamics by solving the nonlinear equation f(u, p, t) = 0, where f represents the network's right-hand side function.\n\nThis is a convenience wrapper around SteadyStateProblem from the SciML ecosystem that constructs and solves the steady state problem, returning the solution as an NWState.\n\nArguments\n\nnw::Network: The network dynamics to find a fixed point for\nx0: Initial guess for the state variables. Can be:\nNWState: Complete network state (default: NWState(nw; ufill=0))\nAbstractVector: Flat state vector\np: Network parameters. Can be:\nNWParameter: Complete parameter object (default: extracted from x0 or NWParameter(nw))\nAbstractVector: Flat parameter vector\n\nKeyword Arguments\n\nalg=SSRootfind(): Steady state solver algorithm from NonlinearSolve.jl\nt=NaN: Time at which to evaluate the system (for time-dependent networks)\nAdditional kwargs are passed to the SciML solve function\n\nReturns\n\nNWState: Network state at the found fixed point\n\nSee also: NWState, NWParameter, initialize_componentwise\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_componentwise","page":"API","title":"NetworkDynamics.initialize_componentwise","text":"initialize_componentwise[!](\n    nw::Network;\n    default_overrides=nothing,\n    guess_overrides=nothing,\n    bound_overrides=nothing,\n    additional_initformula=nothing,\n    additional_guessformula=nothing,\n    additional_initconstraint=nothing,\n    verbose=false,\n    subverbose=false,\n    tol=1e-10,\n    nwtol=1e-10,\n    t=NaN,\n    subalg=nothing,\n    subsolve_kwargs=nothing,\n    parallel=false,\n    vset=[VIndex(i) for i in 1:nv(nw)],\n    eset=[EIndex(i) for i in 1:ne(nw)],\n) :: NWState\n\nInitialize a network by solving initialization problems for each component individually, then verifying the combined solution works for the full network.\n\nThere are two versions of that function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_component! internally, the non-mutating one initialize_component. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The network to initialize\ndefault_overrides: Dictionary mapping symbolic indices to values that should be used as defaults. Use nothing as a value for any key to remove that default.\nguess_overrides: Dictionary mapping symbolic indices to values to use as initial guesses. Use nothing as a value for any key to remove that guess.\nbound_overrides: Dictionary mapping symbolic indices to bounds for constrained variables. Use nothing as a value for any key to remove those bounds.\nadditional_initformula: Dictionary mapping component indices (VIndex/EIndex) to additional initialization formulas. InitFormulas compute and set default values, reducing the number of free variables.\nadditional_guessformula: Dictionary mapping component indices (VIndex/EIndex) to additional guess formulas. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.\nadditional_initconstraint: Dictionary mapping component indices (VIndex/EIndex) to additional initialization constraints.\nverbose: Whether to print information about each component initialization\nsubverbose: Whether to print detailed information within component initialization. Can be Vector [VIndex(1), EIndex(3), ...] for selective output\ntol: Tolerance for individual component residuals\nnwtol: Tolerance for the full network residual\nt: Time at which to evaluate the system\nsubalg: Nonlinear solver algorithm to use for component initialization (defaults to NonlinearSolve.jl default). Can be passed as single value or dict mapping VIndex/EIndex to alg (non-existent keys use default).\nsubsolve_kwargs: Additional keyword arguments passed to the SciML solve function for component initialization. Can be passed as single value or dict mapping VIndex/EIndex to kwargs (non-existent keys use empty kwargs (;)).\nparallel=false: (Experimental) Whether to initialize components in parallel using multithreading.\nvset: Vector of VIndex values specifying which vertices to initialize (defaults to all vertices).\neset: Vector of EIndex values specifying which edges to initialize (defaults to all edges).\n\nReturns\n\nNWState: A fully initialized network state that can be used for simulation\n\nExample of two-step initialization\n\n# First solve a static model\nstatic_model = create_static_network(...)\nstatic_state = find_fixpoint(static_model)\n\n# Extract interface values and use them to initialize dynamic model\ninterface_vals = interface_values(static_state)\ndynamic_model = create_dynamic_network(...)\ndyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)\n\n# Simulate the dynamic model from this initialized state\nprob = ODEProblem(dynamic_model, uflat(dyn_state), tspan, pflat(dyn_state))\nsol = solve(prob)\n\nSee also: initialize_component, interface_values, find_fixpoint\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_componentwise!","page":"API","title":"NetworkDynamics.initialize_componentwise!","text":"initialize_componentwise[!](\n    nw::Network;\n    default_overrides=nothing,\n    guess_overrides=nothing,\n    bound_overrides=nothing,\n    additional_initformula=nothing,\n    additional_guessformula=nothing,\n    additional_initconstraint=nothing,\n    verbose=false,\n    subverbose=false,\n    tol=1e-10,\n    nwtol=1e-10,\n    t=NaN,\n    subalg=nothing,\n    subsolve_kwargs=nothing,\n    parallel=false,\n    vset=[VIndex(i) for i in 1:nv(nw)],\n    eset=[EIndex(i) for i in 1:ne(nw)],\n) :: NWState\n\nInitialize a network by solving initialization problems for each component individually, then verifying the combined solution works for the full network.\n\nThere are two versions of that function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_component! internally, the non-mutating one initialize_component. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The network to initialize\ndefault_overrides: Dictionary mapping symbolic indices to values that should be used as defaults. Use nothing as a value for any key to remove that default.\nguess_overrides: Dictionary mapping symbolic indices to values to use as initial guesses. Use nothing as a value for any key to remove that guess.\nbound_overrides: Dictionary mapping symbolic indices to bounds for constrained variables. Use nothing as a value for any key to remove those bounds.\nadditional_initformula: Dictionary mapping component indices (VIndex/EIndex) to additional initialization formulas. InitFormulas compute and set default values, reducing the number of free variables.\nadditional_guessformula: Dictionary mapping component indices (VIndex/EIndex) to additional guess formulas. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.\nadditional_initconstraint: Dictionary mapping component indices (VIndex/EIndex) to additional initialization constraints.\nverbose: Whether to print information about each component initialization\nsubverbose: Whether to print detailed information within component initialization. Can be Vector [VIndex(1), EIndex(3), ...] for selective output\ntol: Tolerance for individual component residuals\nnwtol: Tolerance for the full network residual\nt: Time at which to evaluate the system\nsubalg: Nonlinear solver algorithm to use for component initialization (defaults to NonlinearSolve.jl default). Can be passed as single value or dict mapping VIndex/EIndex to alg (non-existent keys use default).\nsubsolve_kwargs: Additional keyword arguments passed to the SciML solve function for component initialization. Can be passed as single value or dict mapping VIndex/EIndex to kwargs (non-existent keys use empty kwargs (;)).\nparallel=false: (Experimental) Whether to initialize components in parallel using multithreading.\nvset: Vector of VIndex values specifying which vertices to initialize (defaults to all vertices).\neset: Vector of EIndex values specifying which edges to initialize (defaults to all edges).\n\nReturns\n\nNWState: A fully initialized network state that can be used for simulation\n\nExample of two-step initialization\n\n# First solve a static model\nstatic_model = create_static_network(...)\nstatic_state = find_fixpoint(static_model)\n\n# Extract interface values and use them to initialize dynamic model\ninterface_vals = interface_values(static_state)\ndynamic_model = create_dynamic_network(...)\ndyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)\n\n# Simulate the dynamic model from this initialized state\nprob = ODEProblem(dynamic_model, uflat(dyn_state), tspan, pflat(dyn_state))\nsol = solve(prob)\n\nSee also: initialize_component, interface_values, find_fixpoint\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_component","page":"API","title":"NetworkDynamics.initialize_component","text":"initialize_component(cf;\n                     defaults=get_defaults_dict(cf),\n                     guesses=get_guesses_dict(cf),\n                     bounds=get_bounds_dict(cf),\n                     default_overrides=nothing,\n                     guess_overrides=nothing,\n                     bound_overrides=nothing,\n                     additional_initformula=nothing,\n                     additional_guessformula=nothing,\n                     additional_initconstraint=nothing,\n                     verbose=true,\n                     apply_bound_transformation=true,\n                     t=NaN,\n                     tol=1e-10,\n                     residual=nothing,\n                     alg=nothing, # defaults to FastShortcutNLLSPolyalg(linsolve=QRFactorization())\n                     solve_kwargs=(;),\n                     io=stdout,\n                     kwargs...)\n\nThe function solves a nonlinear problem to find values for all free variables/parameters (those without defaults) that satisfy the component equations in steady state (i.e. RHS equals 0). The initial guess for each variable depends on the provided guesses parameter (defaults to the metadata guess values).\n\nParameters\n\ncf: ComponentModel to initialize\ndefaults: Dictionary of default values (defaults to metadata defaults)\nguesses: Dictionary of initial guesses (defaults to metadata guesses)\nbounds: Dictionary of bounds (defaults to metadata bounds)\ndefault/guess/bound_overrides: Dictionary to merge with defaults/guesses/bounds. You can use nothing as a value for any key to remove that entry from the respective dictionary.\nadditional_initformula: Additional initialization formulas to apply beyond those in component metadata. InitFormulas compute and set default values, reducing the number of free variables.\nadditional_guessformula: Additional guess formulas to apply beyond those in component metadata. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.\nadditional_initconstraint: Additional initialization constraints to apply beyond those in component metadata\nverbose: Whether to print information during initialization\napply_bound_transformation: Whether to apply bound-conserving transformations\nt: Time at which to solve for steady state. Only relevant for components with explicit time dependency.\ntol: Tolerance for the residual of the initialized model (defaults to 1e-10). Init throws error if resid ≥ tol.\nresidual: Optional Ref{Float64} which gets the final residual of the initialized model.\nalg=nothing: Nonlinear solver algorithm (defaults to NonlinearSolve.jl default with QR factorization, since init problems tend to be ill-conditioned.)\nsolve_kwargs=(;): Additional keyword arguments passed to the SciML solve function\nio=stdout: IO stream for printing information\n\nReturns\n\nDictionary mapping symbols to their values (complete state including defaults and initialized values)\n\nBounds of free variables\n\nWhen encountering any bounds in the free variables, NetworkDynamics will try to conserve them by applying a coordinate transformation. This behavior can be suppressed by setting apply_bound_transformation=false. The following transformations are used:\n\n(a, b) intervals where both a and b are positive are transformed to u^2/sqrt(u)\n(a, b) intervals where both a and b are negative are transformed to -u^2/sqrt(-u)\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_component!","page":"API","title":"NetworkDynamics.initialize_component!","text":"initialize_component!(cf::ComponentModel;\n                      defaults=nothing,\n                      guesses=nothing,\n                      bounds=nothing,\n                      default_overrides=nothing,\n                      guess_overrides=nothing,\n                      bound_overrides=nothing,\n                      additional_initformula=nothing,\n                      additional_guessformula=nothing,\n                      additional_initconstraint=nothing,\n                      verbose=true,\n                      t=NaN,\n                      kwargs...)\n\nMutating version of initialize_component. See this docstring for all details. In contrast to the non mutating version, this function reads in defaults and guesses from the symbolic metadata and writes the initialized values back in to the metadata.\n\nParameters\n\ncf: ComponentModel to initialize\ndefaults: Optional dictionary to replace all metadata defaults\nguesses: Optional dictionary to replace all metadata guesses\nbounds: Optional dictionary to replace all metadata bounds\ndefault/guess/bound_overrides: Dict of values that override existing  default/guess/bound metadata. Use nothing as a value for any key to remove  that metadata entry from the component model.\nadditional_initformula: Additional initialization formulas to apply beyond those in component metadata. InitFormulas compute and set default values, reducing the number of free variables.\nadditional_guessformula: Additional guess formulas to apply beyond those in component metadata. GuessFormulas compute improved initial guesses for free variables, improving solver convergence.\nadditional_initconstraint: Additional initialization constraints to apply beyond those in component metadata\nverbose: Whether to print information during initialization\nt: Time at which to solve for steady state. Only relevant for components with explicit time dependency.\nAll other kwargs are passed to initialize_component, see its docstring for details!\n\nWhen defaults, guesses, or bounds are provided, they replace the corresponding metadata in the component model. Any keys in the original metadata that are not in the provided dictionaries will be removed, and new keys will be added.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.init_residual","page":"API","title":"NetworkDynamics.init_residual","text":"init_residual(cf::ComponentModel, [state=get_defaults_or_inits_dict(cf)]; t=NaN, verbose=false)\n\nCalculates the residual |du| for the given component model using the values provided. If no state dictionary is provided, it uses the values from default/init Metadata.\n\nIf verbose=true prints the residual of every single state.\n\nSee also initialize_component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.interface_values","page":"API","title":"NetworkDynamics.interface_values","text":"interface_values(s::NWState) :: OrderedDict{SymbolicIndex, Float64}\n\nExtract all interface values (inputs and outputs) from a network state and return them as a dictionary mapping symbolic indices to their values.\n\nThis function is particularly useful in two-step initialization workflows where you want to:\n\nSolve a simplified static model first (using find_fixpoint)\nUse the resulting interface values to initialize a more complex dynamic model componentwise.\n\nIn that scenario, use interface_values to for the default_overrides argument of initialize_componentwise.\n\nSee also: initialize_componentwise, find_fixpoint and initialize_component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.InitConstraint","page":"API","title":"NetworkDynamics.InitConstraint","text":"struct InitConstraint{F}\nInitConstraint(f, sym, dim)\n\nA representation of an additional constraint that is applied during the initialization phase of a component. It contains a function f that defines the constraint, a vector of symbols sym that are involved in the constraint, and the dimension dim of the constraint.\n\nInitConstraint([:x, :y], 2) do res, u\n    res[1] = u[:x]^2 + u[:y]^2 - 1\nend\n\nSee also @initconstraint for a macro to create such constraints.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.@initconstraint","page":"API","title":"NetworkDynamics.@initconstraint","text":"@initconstraint\n\nGenerate an InitConstraint from an expression using symbols.\n\n@initconstraint begin\n    :x + :y\n    :z^2\nend\n\nis equal to\n\nInitConstraint([:x, :y, :z], 2) do out, u\n    out[1] = u[:x] + u[:y]\n    out[2] = u[:z]^2\nend\n\n\n\n\n\n","category":"macro"},{"location":"API/#NetworkDynamics.set_initconstraint!","page":"API","title":"NetworkDynamics.set_initconstraint!","text":"set_initconstraint!(c::ComponentModel, constraint; check=true)\nset_initconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nSets the initialization constraint(s) for the component. Overwrites any existing constraints. constraint can be a single InitConstraint or a tuple of InitConstraint objects.\n\nSee also: add_initconstraint!, get_initconstraints, delete_initconstraints!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_initconstraints!","page":"API","title":"NetworkDynamics.delete_initconstraints!","text":"delete_initconstraints!(c::ComponentModel)\ndelete_initconstraints!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the initialization constraint from the component model, or from a component referenced by idx in a network. Returns true if the constraint existed and was removed, false otherwise.\n\nSee also: set_initconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_initconstraint","page":"API","title":"NetworkDynamics.has_initconstraint","text":"has_initconstraint(c::ComponentModel)\nhas_initconstraint(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization constraint in metadata.\n\nSee also: get_initconstraints, set_initconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_initconstraints","page":"API","title":"NetworkDynamics.get_initconstraints","text":"get_initconstraints(c::ComponentModel)\nget_initconstraints(nw::Network, idx::Union{VIndex,EIndex})\n\nGets all initialization constraints for the component. Returns a tuple, even if there is only a single constraint.\n\nSee also: has_initconstraint, set_initconstraint!, add_initconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.add_initconstraint!","page":"API","title":"NetworkDynamics.add_initconstraint!","text":"add_initconstraint!(c::ComponentModel, constraint; check=true)\nadd_initconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nAdds an initialization constraint to the component. Does not overwrite existing constraints. constraint should be a single InitConstraint object.\n\nSee also: set_initconstraint!, get_initconstraints.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.InitFormula","page":"API","title":"NetworkDynamics.InitFormula","text":"InitFormula(f, outsym, sym)\n\nA representation of initialization formulas that are applied during the initialization phase of a component. InitFormulas act earlier in the initialization pipeline than InitConstraints - they essentially set additional defaults rather than adding equations to the nonlinear system.\n\nIt contains a function f that defines the formulas, a vector of output symbols outsym that will be set by the formulas, a vector of input symbols sym that are used in the formulas, and an optional pretty-print string.\n\nInitFormula([:Vset], [:u_r, :u_i]) do out, u\n    out[:Vset] = sqrt(u[:u_r]^2 + u[:u_i]^2)\nend\n\nSee also @initformula for a macro to create such formulas.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.@initformula","page":"API","title":"NetworkDynamics.@initformula","text":"@initformula\n\nGenerate an InitFormula from an expression using symbols.\n\n@initformula begin\n    :Vset = sqrt(:u_r^2 + :u_i^2)\n    :Pset = :u_r * :i_r + :u_i * :i_i\nend\n\nis equal to\n\nInitFormula([:Vset, :Pset], [:u_r, :u_i, :i_r, :i_i]) do out, u\n    out[:Vset] = sqrt(u[:u_r]^2 + u[:u_i]^2)\n    out[:Pset] = u[:u_r] * u[:i_r] + u[:u_i] * u[:i_i]\nend\n\n\n\n\n\n","category":"macro"},{"location":"API/#NetworkDynamics.has_initformula","page":"API","title":"NetworkDynamics.has_initformula","text":"has_initformula(c::ComponentModel)\nhas_initformula(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has initialization formulas in metadata.\n\nSee also: get_initformulas, set_initformula!, add_initformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_initformulas","page":"API","title":"NetworkDynamics.get_initformulas","text":"get_initformulas(c::ComponentModel)\nget_initformulas(nw::Network, idx::Union{VIndex,EIndex})\n\nGets all initialization formulas for the component. Returns a tuple, even if there is only a single formula.\n\nSee also: has_initformula, set_initformula!, add_initformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_initformula!","page":"API","title":"NetworkDynamics.set_initformula!","text":"set_initformula!(c::ComponentModel, formula; check=true)\nset_initformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nSets the initialization formula(s) for the component. Overwrites any existing formulas. formula can be a single InitFormula or a tuple of InitFormula objects.\n\nSee also: add_initformula!, get_initformulas, delete_initformulas!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.add_initformula!","page":"API","title":"NetworkDynamics.add_initformula!","text":"add_initformula!(c::ComponentModel, formula; check=true)\nadd_initformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nAdds an initialization formula to the component. Does not overwrite existing formulas. formula should be a single InitFormula object.\n\nSee also: set_initformula!, get_initformulas.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_initformulas!","page":"API","title":"NetworkDynamics.delete_initformulas!","text":"delete_initformulas!(c::ComponentModel)\ndelete_initformulas!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all initialization formulas from the component model, or from a component referenced by idx in a network. Returns true if formulas existed and were removed, false otherwise.\n\nSee also: set_initformula!, add_initformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.GuessFormula","page":"API","title":"NetworkDynamics.GuessFormula","text":"GuessFormula(f, outsym, sym)\n\nA representation of guess formulas that improve initial guesses during component initialization. GuessFormulas are applied after InitFormulas in the pipeline, reading from both defaults and guesses to compute improved guess values for free variables.\n\nUnlike InitFormulas which set defaults (reducing free variables), GuessFormulas only update the guesses dictionary to improve solver convergence without changing the problem dimension.\n\nIt contains a function f that defines the formulas, a vector of output symbols outsym that will be set by the formulas, a vector of input symbols sym that are used in the formulas, and an optional pretty-print string.\n\nInput Lookup Behavior\n\nWhen evaluating a GuessFormula, input symbols are looked up with this priority:\n\nFirst check defaults dict (fixed/known values take precedence)\nThen check guesses dict (free variable current guesses)\nError if symbol not found in either\n\nExamples\n\nGuessFormula([:V, :theta], [:u_r, :u_i]) do out, u\n    out[:V] = sqrt(u[:u_r]^2 + u[:u_i]^2)\n    out[:theta] = atan(u[:u_i], u[:u_r])\nend\n\nSee also @guessformula for a macro to create such formulas.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.@guessformula","page":"API","title":"NetworkDynamics.@guessformula","text":"@guessformula\n\nGenerate a GuessFormula from an expression using symbols.\n\nThis macro provides convenient syntax for creating guess formulas using assignment expressions with quoted symbols. Each assignment computes a guess value for a free variable.\n\nSyntax\n\n@guessformula begin\n    :output1 = expression_with(:input_symbols)\n    :output2 = other_expression(:more_inputs)\nend\n\nInput Symbol Lookup\n\nInput symbols (on RHS) are looked up with this priority:\n\nFirst from defaults dict (fixed values)\nThen from guesses dict (current guesses)\nError if not found in either\n\nOutput Symbol Target\n\nOutput symbols (on LHS) must be:\n\nValid component symbols (states, parameters, inputs, outputs)\nNOT observables (observables are computed, not guessed)\n\nSee also: GuessFormula, @initformula, initialize_component\n\n\n\n\n\n","category":"macro"},{"location":"API/#NetworkDynamics.has_guessformula","page":"API","title":"NetworkDynamics.has_guessformula","text":"has_guessformula(c::ComponentModel)\nhas_guessformula(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has guess formulas in metadata.\n\nSee also: get_guessformulas, set_guessformula!, add_guessformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_guessformulas","page":"API","title":"NetworkDynamics.get_guessformulas","text":"get_guessformulas(c::ComponentModel)\nget_guessformulas(nw::Network, idx::Union{VIndex,EIndex})\n\nGets all guess formulas for the component. Returns a tuple, even if there is only a single formula.\n\nSee also: has_guessformula, set_guessformula!, add_guessformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_guessformula!","page":"API","title":"NetworkDynamics.set_guessformula!","text":"set_guessformula!(c::ComponentModel, formula; check=true)\nset_guessformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nSets the guess formula(s) for the component. Overwrites any existing formulas. formula can be a single GuessFormula or a tuple of GuessFormula objects.\n\nSee also: add_guessformula!, get_guessformulas, delete_guessformulas!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.add_guessformula!","page":"API","title":"NetworkDynamics.add_guessformula!","text":"add_guessformula!(c::ComponentModel, formula; check=true)\nadd_guessformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nAdds a guess formula to the component. Does not overwrite existing formulas. formula should be a single GuessFormula object.\n\nSee also: set_guessformula!, get_guessformulas.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_guessformulas!","page":"API","title":"NetworkDynamics.delete_guessformulas!","text":"delete_guessformulas!(c::ComponentModel)\ndelete_guessformulas!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all guess formulas from the component model, or from a component referenced by idx in a network. Returns true if formulas existed and were removed, false otherwise.\n\nSee also: set_guessformula!, add_guessformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.isfixpoint","page":"API","title":"NetworkDynamics.isfixpoint","text":"isfixpoint(nw::Network, s0::NWState; tol=1e-10)\n\nCheck if the state s0 is a fixpoint of the network nw by calculating the the RHS and check that every entry is within the given tolerance tol.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.jacobian_eigenvals","page":"API","title":"NetworkDynamics.jacobian_eigenvals","text":"jacobian_eigenvals(nw::Network, s0::NWState; eigvalf=LinearAlgebra.eigvals)\n\nCompute the eigenvalues of the Jacobian matrix for linear stability analysis of the network dynamics at state s0.\n\nFor systems without algebraic constraints (identity mass matrix), this returns the eigenvalues of the full Jacobian matrix. For constrained systems (non-identity mass matrix), it computes the eigenvalues of the reduced Jacobian following the approach for differential-algebraic equations outlined in [1]\n\nArguments\n\nnw::Network: The network dynamics object\ns0::NWState: The state at which to compute the Jacobian eigenvalues\neigvalf: Function to compute eigenvalues (default: LinearAlgebra.eigvals)\n\nReturns\n\nVector: Eigenvalues of the Jacobian (or reduced Jacobian for constrained systems)\n\nAlgorithm\n\nFor unconstrained systems (M = I):\n\nComputes eigenvalues of the full Jacobian J\n\nFor constrained systems (M ≠ I, differential-algebraic equations):\n\nThe system has the form: M * dz/dt = f(z, t) where M is a diagonal mass matrix\nVariables are partitioned into differential (Mii = 1) and algebraic (Mii = 0) components\nLet z = [x; y] where x are differential and y are algebraic variables\nThe Jacobian J = ∂f/∂z is partitioned as:\nJ = [f_x  f_y]  where f_x = ∂f_d/∂x, f_y = ∂f_d/∂y\n    [g_x  g_y]        g_x = ∂g_a/∂x, g_y = ∂g_a/∂y\nFor the algebraic constraints 0 = ga(x, y), we have dy/dt = -gy^(-1) * g_x * dx/dt\nSubstituting into the differential equations gives the reduced system: dx/dt = (fx - fy * gy^(-1) * gx) * x = A_s * x\nThe eigenvalues of the reduced Jacobian A_s determine stability\nThis approach follows the theory of differential-algebraic equations [1]\n\nReferences\n\n[1] \"Power System Modelling and Scripting\", F. Milano, Chapter 7.2.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.is_linear_stable","page":"API","title":"NetworkDynamics.is_linear_stable","text":"is_linear_stable(nw::Network, s0::NWState; marginally_stable=false, kwargs...)\n\nCheck if the fixpoint s0 of the network nw is linearly stable by computing the eigenvalues of the Jacobian matrix (or reduced Jacobian for constrained systems).\n\nA fixpoint is linearly stable if all eigenvalues of the Jacobian have negative real parts. For systems with algebraic constraints (non-identity mass matrix), the reduced Jacobian is used following the approach in [1]. See jacobian_eigenvals for more details.\n\nArguments\n\nnw::Network: The network dynamics object\ns0::NWState: The state to check for linear stability (must be a fixpoint)\nmarginally_stable::Bool=false: If true, eigenvalues with zero real part are considered stable.\natol::Float64=1e-14: Absolute tolerance for determining marginal stability. When marginally_stable=true, eigenvalues with |real(λ)| < atol are treated as having zero real part.\nkwargs...: Additional keyword arguments passed to jacobian_eigenvals\n\nReturns\n\nBool: true if the fixpoint is linearly stable, false otherwise\n\nReferences\n\n[1] \"Power System Modelling and Scripting\", F. Milano, Chapter 7.2.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.ComponentCallback","page":"API","title":"NetworkDynamics.ComponentCallback","text":"abstract type ComponentCallback end\n\nAbstract type for a component based callback. A component callback bundles a ComponentCondition as well as a ComponentAffect which can be then tied to a component model using add_callback! or set_callback!.\n\nOn a Network level, you can automatically create network wide CallbackSets using get_callbacks.\n\nSee ContinuousComponentCallback and VectorContinuousComponentCallback for concrete implementations of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ContinuousComponentCallback","page":"API","title":"NetworkDynamics.ContinuousComponentCallback","text":"ContinuousComponentCallback(condition, affect; affect_neg! = affect, kwargs...)\n\nConnect a ComponentCondition and a ComponentAffect to a continuous callback which can be attached to a component model using add_callback! or set_callback!.\n\nThe affect_neg! is also a ComponentAffect but will be triggered on downcrossing. It defaults to the same affect as on upcrossing.\n\nThe kwargs will be forwarded to the VectorContinuousCallback when the component based callbacks are collected for the whole network using get_callbacks. DiffEq.jl docs for available options.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.VectorContinuousComponentCallback","page":"API","title":"NetworkDynamics.VectorContinuousComponentCallback","text":"VectorContinuousComponentCallback(condition, affect, len; affect_neg! = affect, kwargs...)\n\nConnect a ComponentCondition and a ComponentAffect to a continuous callback which can be attached to a component model using add_callback! or set_callback!. This vector version allows for conditions which have len output dimensions. The affect will be triggered with the additional event_idx argument to know in which dimension the zerocrossing was detected.\n\nThe affect_neg! is also a ComponentAffect but will be triggered on downcrossing. It defaults to the same affect as on upcrossing.\n\nThe kwargs will be forwarded to the VectorContinuousCallback when the component based callbacks are collected for the whole network using get_callbacks(::Network). DiffEq.jl docs for available options.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.DiscreteComponentCallback","page":"API","title":"NetworkDynamics.DiscreteComponentCallback","text":"DiscreteComponentCallback(condition, affect; kwargs...)\n\nConnect a ComponentCondition and a ComponentAffect to a discrete callback which can be attached to a component model using add_callback! or set_callback!.\n\nNote that the condition function returns a boolean value, as the discrete callback perform no rootfinding.\n\nThe kwargs will be forwarded to the DiscreteCallback when the component based callbacks are collected for the whole network using get_callbacks(::Network). DiffEq.jl docs for available options.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PresetTimeComponentCallback","page":"API","title":"NetworkDynamics.PresetTimeComponentCallback","text":"PresetTimeComponentCallback(ts, affect; kwargs...)\n\nTrigger a ComponentAffect at given timesteps ts in discrete callback, which can be attached to a component model using add_callback! or set_callback!.\n\nThe kwargs will be forwarded to the PresetTimeCallback when the component based callbacks are collected for the whole network using get_callbacks(::Network).\n\nThe PresetTimeCallback will take care of adding the timesteps to the solver, ensuring to exactly trigger at the correct times.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ComponentCondition","page":"API","title":"NetworkDynamics.ComponentCondition","text":"ComponentCondition(f::Function, sym, psym)\n\nCreates a callback condition for a [ComponentCallback].\n\nf: The condition function. Must be a function of the form out=f(u, p, t) when used for ContinuousComponentCallback or DiscreteComponentCallback and f!(out, u, p, t) when used for VectorContinuousComponentCallback.\nArguments of f\nu: The current value of the selected sym states, provided as a SymbolicView object.\np: The current value of the selected psym parameters.\nt: The current simulation time.\nsym: A vector or tuple of symbols, which represent states (including inputs, outputs, observed) of the component model. Determines, which states will be available through parameter u in the callback condition function f.\npsym: A vector or tuple of symbols, which represent parameters of the component mode. Determines, which parameters will be available in the condition function f\n\nExample\n\nConsider a component model with states [:u1, :u2], inputs [:i], outputs [:o] and parameters [:p1, :p2].\n\nComponentCondition([:u1, :o], [:p1]) do u, p, t\n    # access states symbolically or via int index\n    u[:u1] == u[1]\n    u[:o] == u[2]\n    p[:p1] == p[1]\n    # the states/prameters `:u2`, `:i` and `:p2` are not available as\n    # they are not listed in the `sym` and `psym` arguments.\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ComponentAffect","page":"API","title":"NetworkDynamics.ComponentAffect","text":"ComponentAffect(f::Function, sym, psym)\n\nCreates a callback condition for a [ComponentCallback].\n\nf: The affect function. Must be a function of the form f(u, p, [event_idx], ctx) where event_idx is only available in VectorContinuousComponentCallback.\nArguments of f\nu: The current (mutable) value of the selected sym states, provided as a SymbolicView object.\np: The current (mutable) value of the selected psym parameters.\nevent_idx: The current event index, i.e. which out element triggered in case of VectorContinuousComponentCallback.\nctx::NamedTuple a named tuple with context variables.\nctx.model: a reference to the component model\nctx.vidx/ctx.eidx: The index of the vertex/edge model.\nctx.src/ctx.dst: src and dst indices (only for edge models).\nctx.integrator: The integrator object. Use extract_nw to obtain the network.\nctx.t=ctx.integrator.t: The current simulation time.\nsym: A vector or tuple of symbols, which represent states (excluding inputs, outputs, observed) of the component model. Determines, which states will be available through parameter u in the callback condition function f.\npsym: A vector or tuple of symbols, which represent parameters of the component mode. Determines, which parameters will be available in the condition function f\n\nExample\n\nConsider a component model with states [:u1, :u2], inputs [:i], outputs [:o] and parameters [:p1, :p2].\n\nComponentAffect([:u1, :o], [:p1]) do u, p, ctx\n    u[:u1] = 0 # change the state\n    p[:p1] = 1 # change the parameter\n    @info \"Changed :u1 and :p1 on vertex $(ctx.vidx)\" # access context\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SymbolicView","page":"API","title":"NetworkDynamics.SymbolicView","text":"SymbolicView{N,VT} <: AbstractVetor{VT}\n\nIs a (smallish) fixed size vector type with named dimensions. Its main purpose is to allow named acces to variables in ComponentCondition and ComponentAffect functions.\n\nI.e. when the ComponentAffect declared sym=[:x, :y], you can acces u[:x] and u[:y] inside the condition function.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.get_callbacks-Tuple{Network}","page":"API","title":"NetworkDynamics.get_callbacks","text":"get_callbacks(nw::Network, additional_callbacks=Dict())::CallbackSet\n\nReturns a CallbackSet composed of all the \"component-based\" callbacks in the metadata of the Network components.\n\nYou can inject additional callbacks at that stage by passing\n\nget_callbacks(nw, VIndex(7) => cb)\nget_callbacks(nw, Dict(VIndex(1)=>cb1, EIndex(2)=>cb2))\n\nwhich won't be stored in the metadata of the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.has_callback","page":"API","title":"NetworkDynamics.has_callback","text":"has_callback(c::ComponentModel)\nhas_callback(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has a callback function in metadata.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_callbacks-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"NetworkDynamics.get_callbacks","text":"get_callbacks(c::ComponentModel)\nget_callbacks(nw::Network, idx::Union{VIndex,EIndex})\n\nGets all callback functions for the component. Wraps in tuple, even if there is only a single one.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.set_callback!","page":"API","title":"NetworkDynamics.set_callback!","text":"set_callback!(c::ComponentModel, cb; check=true)\nset_callback!(nw::Network, idx::Union{VIndex,EIndex}, cb; check=true)\n\nSets the callback function for the component. Overwrites any existing callback. See also add_callback!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.add_callback!","page":"API","title":"NetworkDynamics.add_callback!","text":"add_callback!(c::ComponentModel, cb; check=true)\nadd_callback!(nw::Network, idx::Union{VIndex,EIndex}, cb; check=true)\n\nAdds a callback function to the component. Does not overwrite existing callbacks. See also set_callback!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_callbacks!","page":"API","title":"NetworkDynamics.delete_callbacks!","text":"delete_callbacks!(c::ComponentModel)\ndelete_callbacks!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all callback functions from the component model, or from a component referenced by idx in a network. Returns true if callbacks existed and were removed, false otherwise.\n\nSee also: set_callback!, add_callback!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_jac_prototype","page":"API","title":"NetworkDynamics.get_jac_prototype","text":"get_jac_prototype(nw::Network; check=:auto, verbose=true, showerror)\n\nCompute the sparsity pattern of the Jacobian matrix for a NetworkDynamics network.\n\nThis function uses SparseConnectivityTracer.jl (SCT) to detect the sparsity pattern of the Jacobian matrix of the network's dynamics function. The resulting sparsity pattern can be used to  improve the performance of ODE solvers by providing structural information about the system.\n\nOn a per-batch basis (i.e. once per unique component), the function will attempt to get the sparsity pattern. Sometimes, certain component functions may not be compatible with SCT, in that case the function will attempt to\n\nfirst try to replace if/else in RuntimeGeneratedFunctions with something SCT can handle [1]\nif it still does not work, replace the component function with a dense equivalent.\n\nIf showerror=true the error which occurred during the compatibility test will be printed to stdout.\n\nThe check argument controls whether the detected sparsity pattern is verified against the forward-diff jacobian. This check will be disabled with a warning for large networks.\n\nReturns\n\nA sparse matrix representing the sparsity pattern of the Jacobian matrix\n\nnote: [1] On the transformation of conditionals:\na = if a < 0 & b <0\n    expr1\nelse\n    expr2\nendWhich is not compatible due to the & and due to the if..else. This will be repalced bya = expr1 + expr2which alters the semantics but keeps the conservative sparsity pattern.\n\nSee also NetworkDynamics.set_jac_prototype!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_jac_prototype!","page":"API","title":"NetworkDynamics.set_jac_prototype!","text":"set_jac_prototype!(nw::Network, jac::SparseMatrixCSC{Bool,Int})\n\nSet the Jacobian prototype for a NetworkDynamics network.\n\nThis function stores a pre-computed Jacobian sparsity pattern in the network object, which can be used by ODE solvers to improve performance during integration.\n\nArguments\n\nnw::Network: The NetworkDynamics network to modify\njac::SparseMatrixCSC{Bool,Int}: A sparse matrix representing the Jacobian sparsity pattern\n\n\n\n\n\nset_jac_prototype!(nw::Network; kwargs...)\n\nCompute and set the Jacobian prototype for a NetworkDynamics network.\n\nThis is a convenience function that automatically computes the Jacobian sparsity pattern using get_jac_prototype and stores it in the network object. Needs SparseConnectivityTracer to be loaded!\n\nArguments\n\nnw::Network: The NetworkDynamics network to modify\nkwargs...: Keyword arguments passed to get_jac_prototype\n\nExample Usage\n\nnw = Network(...)\nset_jac_prototype!(nw) # computs sparsity pattern and stores in network\nprob = ODEProblem(nw, x0, (0.0, 1.0), p0)\nsol = solve(prob, Rodas5P())\n\nSee also: get_jac_prototype\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.ExecutionStyle","page":"API","title":"NetworkDynamics.ExecutionStyle","text":"abstract type ExecutionStyle{buffered::Bool} end\n\nAbstract type for execution style. The coreloop dispatches based on the Execution style stored in the network object.\n\nbuffered=true means that the edge input es explicitly gathered, i.e. the vertex outputs in the output buffer will be copied into a dedicated input buffer for the edges.\nbuffered=false means, that the edge inputs are not explicitly gathered, but the corloop will perform a redirected lookup into the output buffer.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SequentialExecution","page":"API","title":"NetworkDynamics.SequentialExecution","text":"struct SequentialExecution{buffered::Bool}\n\nSequential execution, no parallelism. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PolyesterExecution","page":"API","title":"NetworkDynamics.PolyesterExecution","text":"struct PolyesterExecution{buffered}\n\nParallel execution using Polyester.jl. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ThreadedExecution","page":"API","title":"NetworkDynamics.ThreadedExecution","text":"struct ThreadedExecution{buffered}\n\nParallel execution using Julia threads. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.KAExecution","page":"API","title":"NetworkDynamics.KAExecution","text":"struct KAExecution{buffered}\n\nParallel execution using KernelAbstractions.jl. Works with GPU and CPU arrays. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.Aggregator","page":"API","title":"NetworkDynamics.Aggregator","text":"abstract type Aggregator end\n\nAbstract sypertype for aggregators. Aggregators operate on the output buffer of all components and fill the aggregation buffer with the aggregatated edge values per vertex.\n\nAll aggregators have the constructor\n\nAggegator(aggfun)\n\nfor example\n\nSequentialAggreator(+)\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SequentialAggregator","page":"API","title":"NetworkDynamics.SequentialAggregator","text":"SequentialAggregator(aggfun)\n\nSequential aggregation.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SparseAggregator","page":"API","title":"NetworkDynamics.SparseAggregator","text":"SparseAggregator(+)\n\nOnly works with additive aggregation +. Aggregates via sparse inplace matrix multiplication. Works with GPU Arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ThreadedAggregator","page":"API","title":"NetworkDynamics.ThreadedAggregator","text":"ThreadedAggregator(aggfun)\n\nParallel aggregation using Julia threads.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PolyesterAggregator","page":"API","title":"NetworkDynamics.PolyesterAggregator","text":"PolyesterAggregator(aggfun)\n\nParallel aggregation using Polyester.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.KAAggregator","page":"API","title":"NetworkDynamics.KAAggregator","text":"KAAggregator(aggfun)\n\nParallel aggregation using KernelAbstractions.jl. Works with both GPU and CPU arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#SciMLBase.ODEProblem-Tuple{Network, NWState, Any}","page":"API","title":"SciMLBase.ODEProblem","text":"SciMLBase.ODEProblem(nw::Network, args...;\n    add_comp_cb=Dict(),\n    add_nw_cb=nothing,\n    override_cb=nothing,\n    kwargs...\n)\n\nCustom constructor for creating ODEProblem base of a Network-Object. Its main purpose is to automatically handle callback construction from the component level callbacks.\n\nCallback Keywords\n\nThe callback system supports three keyword arguments that control how callbacks are managed:\n\nadd_comp_cb: Additional component callbacks: A Dict mapping component indices (e.g., VIndex(1) or EIndex(2)) to component callbacks. These are forwarded to get_callbacks and combined with callbacks stored in the network's component metadata. Use this to inject temporary component callbacks without modifying the network structure.\nadd_nw_cb: Additional network/system callbacks: A network-level callback or CallbackSet (e.g., PeriodicCallback, PresetTimeCallback) that is combined with the network's component callbacks. Use this for callbacks that don't fit the component-based pattern, such as periodic saving or global termination conditions.\noverride_cb: A callback or CallbackSet that completely replaces all network callbacks. When set, both add_comp_cb and add_nw_cb must be empty/nothing (enforced by ArgumentError). Use this for complete control over the callback system.\n\n\n\n\n\nSciMLBase.ODEProblem(nw::Network, s0::NWState, tspan; kwargs...)\nSciMLBase.ODEProblem(nw::Network, s0::NWState, tspan, p0::NWParameter; kwargs...)\n\nThis is a simple wrapper which:\n\nextracts the flat state and parameter vectors from s0 (and p0 if provided)\nmakes a copy of the parameter vector to avoid side effects due to callbacks\nconstructs the callbacks from the network and combines them with any additional callbacks\n\nCallback Keywords\n\nThe callback system supports three keyword arguments that control how callbacks are managed:\n\nadd_comp_cb: Additional component callbacks: A Dict mapping component indices (e.g., VIndex(1) or EIndex(2)) to component callbacks. These are forwarded to get_callbacks and combined with callbacks stored in the network's component metadata. Use this to inject temporary component callbacks without modifying the network structure.\nadd_nw_cb: Additional network/system callbacks: A network-level callback or CallbackSet (e.g., PeriodicCallback, PresetTimeCallback) that is combined with the network's component callbacks. Use this for callbacks that don't fit the component-based pattern, such as periodic saving or global termination conditions.\noverride_cb: A callback or CallbackSet that completely replaces all network callbacks. When set, both add_comp_cb and add_nw_cb must be empty/nothing (enforced by ArgumentError). Use this for complete control over the callback system.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.save_parameters!","page":"API","title":"NetworkDynamics.save_parameters!","text":"save_parameters!(integrator::SciMLBase.DEIntegrator)\n\nSave the current parameter values in the integrator. Call this function inside callbacks if the parameter values have changed. This will store a timeseries of said parameters in the solution object, thus alowing us to recosntruct observables which depend on time-dependet variables.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.ff_to_constraint","page":"API","title":"NetworkDynamics.ff_to_constraint","text":"ff_to_constraint(v::VertexModel)\n\nTakes VertexModel v with feed forward and turns all algebraic output states into internal states by defining algebraic constraints contraints 0 = out - g(...). The new output function is just a StateMask into the extended internal state vector.\n\nReturns the transformed VertexModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.copy-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"Base.copy","text":"copy(c::NetworkDynamics.ComponentModel)\n\nShallow copy of the component model. Creates a deepcopy of metadata and symmetadata but references the same objects everywhere else.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.extract_nw","page":"API","title":"NetworkDynamics.extract_nw","text":"extract_nw(thing)\n\nTry to extract the Network object from thing.\n\nThing can by many things, e.g. ODEProblem, ODESolution, Integrator, NWState, NWParameter, ...\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.implicit_output","page":"API","title":"NetworkDynamics.implicit_output","text":"implicit_output(x) = 0\nModelingToolkit.@register_symbolic implicit_output(x)\n\nThis is a helper function to define MTK models with fully implicit outputs. It is sort of a barrier for Symbolics to not descent in to the equation. When added to an equation, it does nothing (defined as 0), but it tricks MTK/Symbolics into believing the equation depends on x. This can be necessary to define a model with fully implicit outputs.\n\n@mtkmodel ImplicitForcing begin\n    @variables begin\n        u(t), [description = \"Input Variable\", input=true]\n        y(t), [description = \"fully implicit output\", output=true]\n    end\n    @equations begin\n        # 0 ~ u  # WRONG!\n        0 ~ u + implicit_output(y) # CORRECT!\n    end\nend\nVertexModel(ImplicitForcing(name=:implicit), [:u], [:y])\n\nFor more information see the NetworkDynamics docs on fully implicit outputs.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.pretty_f","page":"API","title":"NetworkDynamics.pretty_f","text":"NetworkDynamics.pretty_f(v::VertexModel)\n\nFor debugging vertex models based off MTK, this function pretty prints the underlying generated function f(du, u, in, p, t) in a more readable way.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.inspect","page":"API","title":"NetworkDynamicsInspector.inspect","text":"inspect(sol; restart=false, reset=false, display=nothing)\n\nMain entry point for gui. Starts the server and serves the app for solution sol.\n\nrestart: If true, the display will be restartet (i.e. new Electron window, new server or new Browser tab)\nreset: If true, reset the appstate with the new solution sol.\ndisplay=CURRENT_DISPLAY[]: Can be BrowserDisp(), ServerDisp() or ElectronDisp().  Per default, the current display will be used (defaults toBrowserDisp()).\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.dump_app_state","page":"API","title":"NetworkDynamicsInspector.dump_app_state","text":"dump_app_state()\n\nGenerate a list of set_sol!, set_state!, set_graphplot! and define_timeseries! commands to recreate the current appstate. The intended usecase is to quickly recreate \"starting points\" for interactive exploration.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_sol!","page":"API","title":"NetworkDynamicsInspector.set_sol!","text":"set_sol!(sol)\n\nSet the solution of the current appstate to sol.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_state!","page":"API","title":"NetworkDynamicsInspector.set_state!","text":"set_state!(; sol, t, tmin, tmax)\n\nSet the solution, current time and time limits of the current appstate.\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_graphplot!","page":"API","title":"NetworkDynamicsInspector.set_graphplot!","text":"set_graphplot!(; nstate, estate, nstate_rel, estate_rel, ncolorrange, ecolorrange)\n\nSet the properties of the graphplot of the current appstate.\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_timeseries!","page":"API","title":"NetworkDynamicsInspector.set_timeseries!","text":"set_timeseries!(key; selcomp, states, rel)\n\nSet properties of the timeseries plot with key key. See also define_timeseries!.\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.define_timeseries!","page":"API","title":"NetworkDynamicsInspector.define_timeseries!","text":"define_timeseries!(tsarray)\n\nDefines timeseries, where tsarray is an array of timeseries keyword arguments (see set_timeseries!).\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"injector_nodes/#injector-nodes","page":"Injector Nodes","title":"Injector Nodes","text":"In large network models, vertices often contain multiple internal components (e.g., generators, loads, storage devices). While these can be modeled as a single monolithic vertex model, splitting them into separate \"injector nodes\" connected via special loopback edges can offer performance and modularity advantages. This page explains the injector node pattern and demonstrates how to use LoopbackConnection edges.","category":"section"},{"location":"injector_nodes/#Concept","page":"Injector Nodes","title":"Concept","text":"Let's consider the following subset of a Network:\n\n   ⋮\n  ┏┷━━┓      input\n⋯─┨vₖ ┠───╮  aggr.  ┏━━━━━━━━┓\n  ┗━━━┛   ╰─────╮   ┃        ┃\n   ┏━━━┓       (+)──┨ Vertex ┃\n⋯──┨vⱼ ┠────────╯   ┃        ┃\n   ┗━┯━┛            ┗━━━━━━━━┛\n     ⋮\n\nwe have a vertex of interest which is connected to two other vertices in the network via edges. Generally, we follow the interface of having potential like outputs at the nodes and flow like outputs at the edges. I.e. the potential on the nodes depends on the sum of flows through the edges while the flows through the edges depend on the potential on the adjacent nodes.\n\nThe input-output structure of this system looks something like this:\n\n                                 more edges\n                                     △\nn ⋯───╮             ╭────────────────┼────────────────╮             ╭───⋯ n\ne     │             │      potential │ φ out          │             │     e\nx  ┏━━▽━━━━━━━━━━━━━▽━━┓   ╔═════════△═════════╗   ┏━━▽━━━━━━━━━━━━━▽━━┓  x\nt  ┃ EdgeModel         ┃   ║ VertexModel       ║   ┃ EdgeModel         ┃  t\n   ┃ ẋ = f(x, φ, p, t) ┃   ║ ẋ = f(x, Φ, p, t) ║   ┃ ẋ = f(x, φ, p, t) ┃\nn  ┃ Φ = g(x, φ, p, t) ┃   ║ φ = g(x, p, t)    ║   ┃ Φ = g(x, φ, p, t) ┃  n\no  ┗━━▽━━━━━━━━━━━━━▽━━┛   ╚═════════△═════════╝   ┗━━▽━━━━━━━━━━━━━▽━━┛  o\nd     │        flow │ Φ out        ╭─┴─╮         flow │ Φ out       │     d\ne ⋯───╯             ╰──────────────▷ + ◁──────────────╯             ╰───⋯ e\n                                   ╰─△─╯\n                                     │\n                                 more edges\n\nwhere, notably, only the edge models support feed forward behavior.\n\nIn typical NetworkDynamics modeling, the entire nodal dynamic is contained within a single VertexModel. However, vertices often have modular internal structure consisting of multiple components that inject or draw flows. For example, an electrical bus might have generators, loads, and storage devices all connected to it.\n\n   ⋮                ┏━━━━━━━━━━━━━━━━━━┓\n  ┏┷━━┓      input  ┃Vertex            ┃\n⋯─┨vₖ ┠───╮  aggr.  ┃     ╭──────────╮ ┃\n  ┗━━━┛   ╰─────╮   ┃  ╭──┤Injector A│ ┃\n   ┏━━━┓       (+)──╂─(+) ╰──────────╯ ┃\n⋯──┨vⱼ ┠────────╯   ┃  │  ╭──────────╮ ┃\n   ┗━┯━┛            ┃  ╰──┤Injector B│ ┃\n     ⋮              ┃     ╰──────────╯ ┃\n                    ┗━━━━━━━━━━━━━━━━━━┛\n\nWhile not strictly necessary, splitting these vertex models into \"clusters\" can improve performance and code organization. A cluster consists of a hub vertex and several injector vertices that connect to it. This approach can be particularly beneficial because:\n\nNetworkDynamics performs best when there are many identical components. Splitting components into smaller parts makes it more likely to have repeated, identical components.\nThe model structure matches the physical modularity of the system.\nFor ModelingToolkit models, large monolithic components can lead to higher compilation and symbolic simplification times compared to multiple smaller models.\n\nNotably, injector models have a flipped input-output scheme compared to normal vertices: they take the hub's potential as a direct input and output a flow.\n\n                Hub    Loopback  Satelites\n              ╭──────╮╭────────╮╭──────────╮\n   ⋮\n  ┏┷━━┓                         ┏━━━━━━━━━━┓\n⋯─┨vₖ ┠───╮   ┏━━━━━━┓    ╭─────┨Injector A┃\n  ┗━━━┛   ╰───┨      ┠────╯     ┗━━━━━━━━━━┛\n   ┏━━━┓      ┃ Σi=0 ┃\n⋯──┨vⱼ ┠──────┨      ┠────╮     ┏━━━━━━━━━━┓\n   ┗━┯━┛      ┗━━━━━━┛    ╰─────┨Injector B┃\n     ⋮                          ┗━━━━━━━━━━┛\n\n              ╰────────────────────────────╯\n                     Vertex Cluster\n\nTo connect this kind of injector nodes, we use the special EdgeModel LoopbackConnection. See the docstring below for a detailed explaination of the interfaces.","category":"section"},{"location":"injector_nodes/#Example","page":"Injector Nodes","title":"Example","text":"Following the other examples we'll showcase the feature on the a small electrical network. The network to model looks like this:\n\n                v1   Resistor   v2\n                ●─←────███────→─●\n                │            ╭──┼──╮\nideal v source (↗)           ┴  █  ⚕\n                │            ┬  █  ⚕  C + R + L\n                │            ╰──┼──╯\n                ⏚               ⏚\n\nFor demonstration purposes we'll model second vertex in two ways: as a single model enclosing all three components and as separate injector nodes.\n\nAs always, this is mainly a pedagogical example. For such a simple system, it is probably much cleaner to model it as a single vertex. However thats not always the case for very large networks with many complex vertex models!","category":"section"},{"location":"injector_nodes/#Prerequisites","page":"Injector Nodes","title":"Prerequisites","text":"The first few components building blocks are identical to the docs on ModelingToolkit Integration.\n\nusing NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\n\n@mtkmodel NWTerminal begin\n    @variables begin\n        v(t), [description=\"Voltage at node\"]\n        i(t), [description=\"Current flowing into node\"]\n    end\nend\n\n@mtkmodel VoltageSource begin\n    @components begin\n       p = NWTerminal()\n    end\n    @parameters begin\n        V = 1.0\n    end\n    @variables begin\n        i(t), [description=\"produced current by ideal voltage source (observable)\"]\n    end\n    @equations begin\n        i ~ -p.i\n        p.v ~ V\n    end\nend\n@named vs = VoltageSource()\nvs_vertex = VertexModel(vs, [:p₊i], [:p₊v])\n\n@mtkmodel Resistor begin\n    @components begin\n        src = NWTerminal()\n        dst = NWTerminal()\n    end\n    @parameters begin\n        R = 1\n    end\n    @equations begin\n        dst.i ~ (src.v - dst.v)/R\n        src.i ~ -dst.i\n    end\nend\n@named resistor = Resistor()\nnothing # hide","category":"section"},{"location":"injector_nodes/#Part-A:-Modeling-with-Injector-Nodes-and-LoopbackConnection","page":"Injector Nodes","title":"Part A: Modeling with Injector Nodes and LoopbackConnection","text":"We'll model the circuit using separate components connected via loopback edges. Since our capacitor has the equation\n\ndotu = frac1C i\n\nit is a natural voltage source. We'll use it as the \"hub\" node which will be accompanied by two injector nodes for the resistor and inductor.\n\n@mtkmodel Capacitor begin\n    @components begin\n        p = NWTerminal(;v=0)\n    end\n    @parameters begin\n        C = 1.0\n    end\n    @equations begin\n        D(p.v) ~ p.i / C\n    end\nend\n@named cap = Capacitor()\nhub_vertex = VertexModel(cap, [:p₊i], [:p₊v], name=:hub)\n\nNext, we define the resistor as an injector node. Unlike the regular Resistor edge model, this takes voltage as input and outputs current:\n\n@mtkmodel ResistorInjector begin\n    @components begin\n        p = NWTerminal()\n    end\n    @parameters begin\n        R = 100.0\n    end\n    @equations begin\n        p.i ~ p.v/R\n    end\nend\n@named resistor_inj = ResistorInjector()\nRinj_vertex = VertexModel(resistor_inj, [:p₊v], [:p₊i], name=:R_injector)\n\nNotice how we've flipped the interface: voltage becomes an input ([:p₊v]) and current becomes an output ([:p₊i]). However, the model above has a constraint instead of feed-forward behavior. By default, the VertexModel constructor transforms feed-forward relationships into constraint states—a sensible default since most vertex models should not have feed-forward behavior. For injector nodes, we need to opt out of this transformation:\n\nRinj_vertex = VertexModel(resistor_inj, [:p₊v], [:p₊i], name=:R_injector, ff_to_constraint=false)\n\nNext, we go for the Inductor injector node:\n\n@mtkmodel InductorInjector begin\n    @components begin\n        p = NWTerminal()\n    end\n    @parameters begin\n        L = 0.1\n    end\n    @equations begin\n        D(p.i) ~ p.v / L\n    end\nend\n@named inductor_inj = InductorInjector()\nLinj_vertex = VertexModel(inductor_inj, [:p₊v], [:p₊i], name=:L_injector, ff_to_constraint=false)\n\nNow, we need to define the connections between the hub and the injectors, and between voltage source and hub. For the two injectors we define the special LoopbackConnection endges from injector to hub. For the connection between voltage source and hub we use a regular edge model.\n\nedges = [\n    LoopbackConnection(potential=[:u], flow=[:i], src=:R_injector, dst=:hub, name=:R_loopback),\n    LoopbackConnection(potential=[:u], flow=[:i], src=:L_injector, dst=:hub, name=:L_loopback),\n    EdgeModel(resistor, [:src₊v], [:dst₊v], [:src₊i], [:dst₊i]; src=:vs, dst=:hub)\n]\nvertices = [vs_vertex, hub_vertex, Rinj_vertex, Linj_vertex]\nnw = Network(vertices, edges; warn_order=false)\n\nTo simulate the system we use the default initial conditions. We can inspect the states of our network to see how the different variables span the components:\n\ns0 = NWState(nw)\ns0.v\n\nWith that knowlege, we can set the initial condition:\n\ns0.v[:hub, :p₊v] = 0.0\ns0.v[:L_injector, :p₊i] = 0.0\nnothing #hide\n\nFrom initial state we can simulate and plot the results:\n\nprob = ODEProblem(nw, s0, (0.0, 10.0))\nsol = solve(prob, Tsit5())\n\nlet\n    fig = Figure()\n    ax = Axis(fig[1,1])\n    plot!(ax, sol; idxs=VIndex(:hub, :p₊v), label=\"Capacitor Voltage (Injector Nodes)\", color=Cycled(1))\n    plot!(ax, sol; idxs=VIndex(:L_injector, :p₊i), label=\"Inductor Current (Injector Nodes)\", color=Cycled(2))\n    axislegend(ax)\n    fig\nend","category":"section"},{"location":"injector_nodes/#Part-B:-Modeling-with-a-Single-VertexModel","page":"Injector Nodes","title":"Part B: Modeling with a Single VertexModel","text":"For comparison, we now model the same system using a single monolithic vertex that contains all three components (capacitor, resistor, and inductor) internally.\n\n@mtkmodel CRLModel begin\n    @components begin\n        cap = Capacitor()\n        resistor = ResistorInjector()\n        inductor = InductorInjector()\n    end\n    @variables begin\n        v(t), [description=\"Voltage at node\"]\n        i(t)=0, [description=\"Current flowing into node\"]\n    end\n    @equations begin\n        0 ~ resistor.p.i + inductor.p.i + cap.p.i - i\n        v ~ cap.p.v\n        v ~ resistor.p.v\n        v ~ inductor.p.v\n    end\nend\n@named crl_model = CRLModel()\ncrl_vertex = VertexModel(crl_model, [:i], [:v], name=:CRL_vertex)\n\nWith that definition we can define the network again:\n\nedges2 = [\n    EdgeModel(resistor, [:src₊v], [:dst₊v], [:src₊i], [:dst₊i]; src=:vs, dst=:CRL_vertex)\n]\nvertices2 = [vs_vertex, crl_vertex]\nnw2 = Network(vertices2, edges2; warn_order=false)\n\ns0_2 = NWState(nw2)\ns0_2[VIndex(:CRL_vertex, :v)] = 0.0\ns0_2[VIndex(:CRL_vertex, :inductor₊p₊i)] = 0.0\n\nprob2 = ODEProblem(nw2, s0_2, (0.0, 10.0))\nsol2 = solve(prob2, Tsit5())\nlet\n    fig = Figure()\n    ax = Axis(fig[1,1])\n    plot!(ax, sol; idxs=VIndex(:hub, :p₊v), label=\"Capacitor Voltage (Injector Nodes)\", color=Cycled(1), alpha=0.5)\n    plot!(ax, sol2; idxs=VIndex(:CRL_vertex, :v), label=\"Capacitor Voltage (Single Vertex)\", color=Cycled(1), linestyle=:dash)\n    plot!(ax, sol; idxs=VIndex(:L_injector, :p₊i), label=\"Inductor Current (Injector Nodes)\", color=Cycled(2), alpha=0.5)\n    plot!(ax, sol2; idxs=VIndex(:CRL_vertex, :inductor₊p₊i), label=\"Inductor Current (Single Vertex)\", color=Cycled(2), linestyle=:dash)\n    axislegend(ax)\n    fig\nend\n\nAs expected, we get identical results from both modeling approaches.","category":"section"},{"location":"injector_nodes/#NetworkDynamics.LoopbackConnection-injector_nodes","page":"Injector Nodes","title":"NetworkDynamics.LoopbackConnection","text":"LoopbackConnection(; potential, flow, kwargs...)\n\nA LoopbackConnection is a special EdgeModel that enables direct connection of \"injector nodes\" to a \"hub\" node without requiring aggregation logic. An injector node is an \"inverted\" VertexModel, which gets the networks potential as an input and outputs a flow variable.\n\nThe LoopbackConnection allows a direct, star-like connection of injector nodes to a single hub nodes. The LoopbackConnection is a directed edge model from injector to hub!\n\n       ┊\n    ┄┄┄◯   ● injector 1\n      ╱ ╲ ╱\n   ┄┄◯╶─╴◯╶─╴● injector 2\n     ┊    ╲\n           ● injector 3\n\nInjector nodes:\n\nhave a flipped interface (potential in, flow out)\nmust be leaf nodes (one neighbor only),\nmust be connected through a LoopbackConnection EdgeModel and\nmay have feed-forward (direct dependency of flow-output on potential-input).\n\nnote: Sign Convention\nFor normal vertices, positive flow as an input means flow into the vertex. This convention is maintained for injector nodes (though it may seem counter-intuitive):Positive flow: Draw from the hub (consumption)\nNegative flow: Injection into the hub (production)When using ModelingToolkit models, you only need to flip the input/output variable declarations—the equations themselves remain unchanged. For example, a resistor with p.i ~ p.v/R keeps the same equation; only the interface changes from VertexModel(..., [:p₊i], [:p₊v]) to VertexModel(..., [:p₊v], [:p₊i]).\n\n                       △\n      ╭────────────────┼────────────╮\n      │      potential │ φ out      │\n━━━━━━▽━━┓   ╔═════════△═════════╗  │  ┏━━━━━━━┓   ╔═══════════════════╗\n normal  ┃   ║ VertexModel (hub) ║  ╰──▷┄┄┄┄┄┄┄▷───▷ Injector Vertex   ║\nEdgeModel┃   ║ ẋ = f(x, Φ, p, t) ║     ┃       ┃   ║ ẋ = f(x, φ, p, t) ║\n         ┃   ║ φ = g(x, p, t)    ║  ╭──◁┄×(-1)┄◁───◁ Φ = g(x, φ, p, t) ║\n━━━━━━▽━━┛   ╚═════════△═════════╝  │  ┗━━━━━━━┛   ╚═══════════════════╝\n flow │ Φ out        ╭─┴─╮          │  special      ⋅ flipped interface:\n      ╰──────────────▷ + ◁──────────╯  \"Loopback\"     ▷ potential φ in\n       (aggregation) ╰─△─╯             EdgeModel      ◁ flow Φ out\n                       │               inj => hub   ⋅ feed forward allowed\n\nFor input-output naming you need to provide the potential and flow symbols.\n\njulia> LoopbackConnection(; potential=[:u_r, :u_i], flow=[:i_r, :i_i], src=1, dst=2)\nEdgeModel :loopback PureFeedForward() @ Edge 1=>2\n ├─ 2/2 inputs:  src=[injector₊i_r, injector₊i_i] dst=[hub₊u_r, hub₊u_i]\n ├─   0 states:  []\n └─ 2/2 outputs: src=[injector₊u_r, injector₊u_i] dst=[hub₊i_r, hub₊i_i]\n\n\n\n\n\n","category":"function"},{"location":"mathematical_model/#Mathematical-Model","page":"Mathematical Model","title":"Mathematical Model","text":"The core of the NetworkDynamics.jl package is the Network function. It accepts functions describing the local dynamics on the edges and nodes of the graph g as inputs, and returns a composite function compatible with the DifferentialEquations.jl syntax as output.\n\nnd = Network(g, vertex_dynamics,  edge_dynamics)\nnd(dx, x, p, t)\n\nIn general, the local dynamics on the edges and nodes of a graph can be described through the use of (a) algebraic equations, (b) differential algebraic equations (DAEs) in mass matrix form, or (c) ordinary differential equations (ODEs). The NetworkDynamics.jl package uses Differential-Algebraic-Equations (DAE) to express the overall network dynamics:\n\nMfracmathrmdmathrmdtu = f^mathrmnw(u p t)\n\nwhere M is a (possibly singular) mass matrix, u is the internal state vector of the system, p are the parameters, and t is the time. To make this compatible with the solvers used in OrdinaryDiffEq.jl, the generated Network object is callable\n\nnw(du, u, p, t) # mutates du as an \"output\"\n\nand represents the right-hand-side (RHS) of the equation above. The mass-matrix M is stored in the Network object as well.","category":"section"},{"location":"mathematical_model/#Modeling-the-Dynamics-of-the-System","page":"Mathematical Model","title":"Modeling the Dynamics of the System","text":"Each component model mathrm c is modeled as a general input-output system:\n\nbeginaligned\nM_mathrm cfracmathrmdmathrmdtx_mathrm c = f^mathrm c(x^mathrm c i_mathrm c p_mathrm c t)\ny^mathrm c = g^mathrm c(x^mathrmc i_mathrm c p_mathrm c t)\nendaligned\n\nwhere M_mathrmc is the component mass matrix, x^mathrm c are the component states, i^mathrm c are the inputs of the component, and y^mathrm c is the output of the component. If mathrmdim(x^mathrmc) = 0, the number of internal states is 0.\n\nThe mathematical model of NetworkDynamics.jl splits the network system into two parts: the vertex and the edge components (the nodes and edges, respectively). Instead of defining the f^mathrmnw by hand, ND.jl builds it automatically based on a list of decentralized nodal and edge dynamics that the user provides (the VertexModel and EdgeModel objects).\n\nIn the context of the network, the output of the edges are flow variables and the outputs of vertices are potential variables. When the node and edge models are placed on a graph, the inputs and outputs are connected: the nodes receive the output of the adjacent edges as inputs and the edges receive the output of the adjacent nodes as inputs. Thus, the flow on the edges depends on the potentials at both ends as inputs. The potentials of the nodes depend on the incoming flows from all connected edges as an input. (Here, flow and potentials are meant in a conceptual and not necessarily physical way.)\n\n<picture>\n  <source srcset=\"../assets/mathmodel-dark.svg\" media=\"(prefers-color-scheme: dark)\">\n  <img src=\"../assets/mathmodel.svg\" width=\"100%\" height=\"100%\"/>\n</picture>\n\nIn this graphical representation of a partial network graph, three nodes are visible (node 1, node 2, and node 3) as well as the edges connecting node 1 and node 2 (e_mathrm12). Above the network, you can see the dynamical systems for both nodes 1 and 2 as well as the connecting edge. The figure shows how the outputs of the edge appear as inputs to the nodes and the outputs of the nodes appear as inputs to the edge models.","category":"section"},{"location":"mathematical_model/#Vertex-Models","page":"Mathematical Model","title":"Vertex Models","text":"The equations of a (single-layer) full vertex model are:\n\nbeginaligned\nM^mathrm vfracmathrmdmathrmdtx^mathrm v = f^mathrm v(x^mathrm v i^mathrm v p^mathrm v t)\ny^mathrm v = g^mathrm v(x^mathrm v i^mathrm v p^mathrm v t)\nendaligned\n\nand they correspond to the Julia functions:\n\nfunction fᵥ(dxᵥ, xᵥ, e_aggr, pᵥ, t)\n    # mutate dxᵥ\n    nothing\nend\nfunction gᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)\n    # mutate yᵥ\n    nothing\nend\nvertf = VertexModel(; f=fᵥ, g=gᵥ, mass_matrix=Mᵥ, ...)\n\nA (single-layer) full vertex model has one input, and one output. Its input is an aggregation/reduction over all the incident edge outputs which is calculated using:\n\ni^mathrm v = mathopmathrmagglimits_k^textincident y^mathrm e_k qquadtextoftenqquad\ni^mathrm v = sum_k^textincident y^mathrm e_k\n\nThe graphical representation of such a model is:\n\n<picture>\n  <source srcset=\"../assets/nodemodel-dark.svg\" media=\"(prefers-color-scheme: dark)\">\n  <img src=\"../assets/nodemodel.svg\" width=\"70%\" height=\"70%\"/>\n</picture>\n\nwhere y^e_i and y^e_j are two of the n incident edge outputs that are aggregated to produce the model input i^v and the model output y^v (the vertex model output).","category":"section"},{"location":"mathematical_model/#Edge-Models","page":"Mathematical Model","title":"Edge Models","text":"In contrast to vertex models, edge models in general have two inputs and two outputs, for both the source and the destination end of the edge. We commonly use src and dst to describe the source and destination ends of an edge, respectively.\n\nnote: On the directionality of edges\nMathematically, in a system defined on an undirected graph, there is no difference between edge (12) and edge (21), because the edge has no direction. However, from an implementation point of view, we always need to have some kind of ordering. For undirected graphs, the edges are always defined from src -> dst where src < dst (this convention matches the behavior of the edges iterator from Graphs.jl). I.e., the undirected edge between nodes 1 and 2 will always be referenced as 1 -> 2, never 2 -> 1. The source and destination naming is related to this notion of directionality; it is not related to the actual flows, i.e., a system might exist where there is a net flow from destination to source.\n\nThe full edge model equations are:\n\nbeginaligned\nM^mathrm efracmathrmdmathrmdtx^mathrm e = f^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t)\ny^mathrm e_mathrmdst = g_mathrmdst^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t)\ny^mathrm e_mathrmsrc = g_mathrmsrc^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t)\nendaligned\n\nand they correspond to the Julia functions:\n\nfunction fₑ(dxₑ, xₑ, v_src, v_dst, pₑ, t)\n    # mutate dxₑ\n    nothing\nend\nfunction gₑ(y_src, y_dst, xₑ, v_src, v_dst, pₑ, t)\n    # mutate y_src and y_dst\n    nothing\nend\nedgef = EdgeModel(; f=fₑ, g=gₑ, mass_matrix=Mₑ, ...)\n\nEach edge has:\n\ntwo inputs:\nthe node outputs of the source\nthe node outputs of the destination end of the edge\ntwo outputs:\nthe dst output (which is used as input for the vertex at the destination end)\nthe src output (which is used as input for the vertex at the source end)\n\nIn general, the two edge outputs y_mathrmsrc and y_mathrmdst are completely independent because there is no implicit conservation law dictating that their values should be identical. An example of such unbalanced systems is power lines in an energy grid with losses, where the power flowing into a line does not match the power flowing out of it, because some of the energy transported is lost in the form of heat. Another example would be a gas pipeline with some internal pressure: it is entirely possible to push in gas from both ends simultaneously. It would simply result in increased pressure within the pipe. For the (important) special cases where there is a strong correlation between source and destination output, see the section on Single Sided Edge Outputs below.\n\nThe vertex models connected to the edge do not know whether they are at the 'src' or the 'dst' end of the edge. Therefore, the sign convention for both outputs of an edge must be identical. Typically, a positive flow represents a flow into the connected vertex, whereas a negative flow represents a flow out of the connected vertex.\n\n          y_src ┌───────────────────┐ y_dst\n  V_src o───←───┤ internal dynamics ├───→───o V_dst\n                └───────────────────┘","category":"section"},{"location":"mathematical_model/#Single-Sided-Edge-Outputs","page":"Mathematical Model","title":"Single Sided Edge Outputs","text":"Often, the edge output functions g_mathrmsrc and g_mathrmdst are not independent, but rather one of them is a function of the other. For example, in an edge model with flow conservation without internal storage, the flow magnitude at the source end is equal to the flow magnitude at the destination end (what flows in must come out). Since the sign convention on both ends must be identical (e.g., positive flow is a flow towards the vertex), we get antisymmetric behavior: y_mathrmsrc = -y_mathrmdst.\n\nTo accommodate such cases, we can use the concept of single-sided edge output functions. A single-sided output function only defines a function for one of the outputs:\n\nfunction g_single(y, xᵥ, v_src, v_dst, pₑ, t)\n    # mutate y\n    nothing\nend\n\nThere are multiple wrappers available to automatically convert them into double-sided edge output functions:\n\nDirected(g_single) builds a double-sided function which only couples to the destination side (i.e., y_dst=y and y_src = 0).\nSymmetric(g_single) builds a double-sided function in which both ends receive y (i.e., y = y_src = y_dst).\nAntiSymmetric(g_single) builds a double-sided function where the destination receives y and the source receives -y (i.e., y=y_dst=-y_src).\nFiducial(g_single_src, g_single_dst) builds a double-sided edge output function based on two single-sided functions.","category":"section"},{"location":"mathematical_model/#Feed-Forward-Behavior","page":"Mathematical Model","title":"Feed Forward Behavior","text":"warning: Feed Forward Vertices\nAs of 11/2024, vertices with feed forward behavior (FF) are not supported at all. Use ff_to_constraint to transform them into vertex models without FF.\n\nComponent models can have a so-called feed forward behavior, which provides a direct link between the input and the output.\n\nThe most generic version of the component models can contain direct FFs from the input to the output. This means that the output function g depends directly on the component inputs i rather than just on the component state x.\n\nWhenever possible, you should define output functions without FFs in the following way:\n\ngᵥ_noff(yᵥ, xᵥ, pᵥ, t)\ngₑ_noff([y_src,] y_dst, xₑ, pₑ, t)\n\ninstead of the more general\n\ngᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)\ngₑ([y_src,] y_dst, xₑ, v_src, v_dst, pₑ, t)\n\nNetworkDynamics cannot couple two components with FFs to each other. However, it is always possible to transform feed forward behavior to an internal state x with mass matrix entry zero to circumvent this problem. This transformation can be performed automatically using ff_to_constraint.\n\nConcretely, NetworkDynamics distinguishes between 4 types of feed forward behaviors of g functions based on the FeedForwardType trait. The feed forward type is inferred automatically based on the provided function g (this is done by inspecting the available method signatures for g, i.e., NetworkDynamics checks how many arguments your g function takes). If the automatic inference of feed forward type fails, the user may specify it explicitly using the ff keyword argument of the Edge/VertexModel constructor.\n\nThe code block below presents the different g signatures for the different feed forward types:\n\nPureFeedForward()\n\ng!(outs...,          ins...,       p, t) # abstractly\ng!(out_dst,          v_src, v_dst, p, t) # single-sided edge\ng!(out_src, out_dst, v_src, v_dst, p, t) # double-sided edge\ng!(v_out,            e_aggr,       p, t) # single layer vertex\n\nFeedForward()\n\ng!(outs...,          x, ins...,       p, t) # abstractly\ng!(out_dst,          x, v_src, v_dst, p, t) # single-sided edge\ng!(out_src, out_dst, x, v_src, v_dst, p, t) # double-sided edge\ng!(v_out,            x, e_aggr,       p, t) # single layer vertex\n\nNoFeedForward()\n\ng!(outs...,          x, p, t) # abstractly\ng!(out_dst,          x, p, t) # single-sided edge\ng!(out_src, out_dst, x, p, t) # double-sided edge\ng!(v_out,            x, p, t) # single layer vertex\n\nPureStateMap()\n\ng!(outs...,          x) # abstractly\ng!(out_dst,          x) # single-sided edge\ng!(out_src, out_dst, x) # double-sided edge\ng!(v_out,            x) # single layer vertex","category":"section"},{"location":"data_structure/#Data-Structure","page":"Data Structure","title":"Data Structure","text":"A Network contains a list of vertex and edge models along with a graph. However, in tight numerical loops, it will never access these lists of models directly. Instead, the network maintains an internal representation that tracks all symbolic indices, defining the precise ordering of states and parameters in a flat array representation. To optimize performance, especially for heterogeneous networks, the network employs specialized data structures that batch identical models together.\n\nThis disconnect between the explicit lists and the internal data structures can be confusing.","category":"section"},{"location":"data_structure/#Flat-Parameter-and-State-Arrays","page":"Data Structure","title":"Flat Parameter and State Arrays","text":"The vertex and edge models may contain metadata, such as the initial values for states and parameters. Crucially, this metadata is only for the building and initialization of the simulation. During actual simulation, the state and parameters are handled as flat arrays, i.e., plain Vector{Float64} objects.\n\nNWState and NWParameter serve as wrappers around flat arrays and the Network objects, allowing you to inspect and modify those flat arrays by addressing vertices and edges directly.\n\nA typical workflow is the following:\n\nSet default values in the models using the metadata (see Metadata).\nCreate a network (see Network Construction).\nGenerate a state s = NWState(nw) which will be prefilled with the default values from the component metadata (see Symbolic Indexing).\nChange the values of s, i.e., s.v[1,:x] = 1.0: This changes the underlying flat array but not the metadata of the models.\nBuild a problem with the updated flat arrays using uflat(s) and pflat(s).","category":"section"},{"location":"data_structure/#Accessing-Components","page":"Data Structure","title":"Accessing Components","text":"Per default, the models are not copied on Network construction:\n\nusing NetworkDynamics # hide\nusing Graphs #hide\ninclude(joinpath(pkgdir(NetworkDynamics), \"test\", \"ComponentLibrary.jl\")) # hide\nkuramoto_first = Lib.kuramoto_vertex! # hide\nkuramoto_secnd = Lib.kuramoto_inertia! # hide\nkuramoto_edge = Lib.kuramoto_edge! # hide\n\nv1 = VertexModel(f=kuramoto_first, sym=[:θ], psym=[:ω], g=1)\nv2 = VertexModel(f=kuramoto_secnd, sym=[:δ, :ω], psym=[:M, :D, :Pm], g=1)\ne = EdgeModel(;g=AntiSymmetric(kuramoto_edge), outsym=[:P], psym=[:K])\nnw = Network(complete_graph(2), [v1, v2], e)\n\nYou can access the models using getindex/[] with VIndex or EIndex:\n\nv1 === nw[VIndex(1)]\n\nThis can be important when changing the metadata of components. i.e., both lines below are equivalent:\n\nset_position!(v1, (1,0))\nset_position!(nw[VIndex(1)], (1,0))\nnothing #hide\n\nnote: Aliasing of component models\nSince components are not copied, multiple entries in the vertex and edge lists might point to the same instance of a model. nw = Network(complete_graph(3), [v1,v2,v1], e)\nv1 === nw[VIndex(1)] === nw[VIndex(3)]Consequently, metadata set for one model might affect another model. This behavior can be beneficial for performance reasons. To force the copying of components, use the dealias keyword:nw = Network(complete_graph(3), [v1,v2,v1], e; dealias=true)\nnw[VIndex(1)] === nw[VIndex(3)] # neither of them === v1","category":"section"},{"location":"data_structure/#Extracting-a-Network-object-from-Containers","page":"Data Structure","title":"Extracting a Network-object from Containers","text":"NetworkDynamics.jl provides a extract_nw function, to get a reference to the wrapped Network object from different containers, such as solution objects or integrator objects. ","category":"section"},{"location":"generated/cascading_failure/#Cascading-Failure","page":"Cascading Failure","title":"Cascading Failure","text":"This script reimplements the minimal example of a dynamic cascading failure described in Schäfer et al. (2018) [1]. This is an example how to use callback functions to change network parameters. In this case to disable certain lines. This script can be dowloaded as a normal Julia script here.\n\n[1] Schäfer, B., Witthaut, D., Timme, M., & Latora, V. (2018). Dynamically induced cascading failures in power grids. Nature communications, 9(1), 1-13. https://www.nature.com/articles/s41467-018-04287-5\n\nThis example has three subchaperts:\n\nfirst we define the network model,\nsecondly, we implement component based callbacks and\nthirdly we solve the problem using systemwide callbacks.\n\nThe system is modeled using swing equation and active power edges. The nodes are characterized by the voltage angle δ, the active power on each line is symmetric and a function of the difference between source and destination angle δ_src - δ_dst.\n\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEqTsit5\nusing DiffEqCallbacks\nusing Plots\nusing Test #hide\nimport SymbolicIndexingInterface as SII","category":"section"},{"location":"generated/cascading_failure/#Defining-the-Model","page":"Cascading Failure","title":"Defining the Model","text":"For the nodes we define the swing equation. State v[1] = δ, v[2] = ω. The swing equation has three parameters: p = (P_ref, I, γ) where P_ref is the power setpopint, I is the inertia and γ is the droop or damping coeficcient.\n\nThe output of the node is just the first state. g=1 is a shorthand for g=StateMask(1:1) which implements a trivial output function g which just takes the first element of the state vector.\n\nfunction swing_equation(dv, v, esum, p,t)\n    P, I, γ = p\n    dv[1] = v[2]\n    dv[2] = P - γ * v[2] .+ esum[1]\n    dv[2] = dv[2] / I\n    nothing\nend\nvertex = VertexModel(f=swing_equation, g=1, sym=[:δ, :ω], psym=[:P_ref, :I=>1, :γ=>0.1])\n\nLets define a simple purely active power line whose active power flow is completlye determined by the connected voltage angles and the coupling constant K. We give an additonal parameter, the line limit, which we'll use later in the callback.\n\nfunction simple_edge(e, v_s, v_d, (K,), t)\n    e[1] = K * sin(v_s[1] - v_d[1])\nend\nedge = EdgeModel(;g=AntiSymmetric(simple_edge), outsym=:P, psym=[:K=>1.63, :limit=>1])\n\nWith the definition of the graph topology we can build the Network object:\n\ng = SimpleGraph([0 1 1 0 1;\n                 1 0 1 1 0;\n                 1 1 0 1 0;\n                 0 1 1 0 1;\n                 1 0 0 1 0])\nnw = Network(g, vertex, edge; dealias=true)\n\nNote that we used dealias=true to automaticially generate separate ComponentModels for each vertex/edge. Doing so allows us to later set different metadata (callbacks, default values, etc.) for each vertex/edge.\n\nWe proceed by setting the default reference power for the nodes:\n\nset_default!(nw, VIndex(1, :P_ref), -1.0) # load\nset_default!(nw, VIndex(2, :P_ref),  1.5) # generator\nset_default!(nw, VIndex(3, :P_ref), -1.0) # load\nset_default!(nw, VIndex(4, :P_ref), -1.0) # load\nset_default!(nw, VIndex(5, :P_ref),  1.5) # generator\nnothing #hide\n\nWe can use find_fixpoint to find a valid initial condition of the network. We also use set_defaults! to overwirte all the default values for states and parameters with the one of the fixpoint, this means that we can allways re-extract this setpoint by using u0 = NWState(nw).\n\nu0 = find_fixpoint(nw)\nset_defaults!(nw, u0)\nnothing #hide","category":"section"},{"location":"generated/cascading_failure/#Component-based-Callbacks","page":"Cascading Failure","title":"Component-based Callbacks","text":"For the component based callback we need to define a condtion and an affect. Both functions take three inputs:\n\nthe actual function f\nthe states which to be accessed sym\nthe parameters to be accessed psym\n\ncond = ComponentCondition([:P], [:limit]) do u, p, t\n    abs(u[:P]) - p[:limit]\nend\naffect = ComponentAffect([], [:K]) do u, p, ctx\n    println(\"Line $(ctx.eidx) tripped at t=$(ctx.integrator.t)\")\n    p[:K] = 0\nend\nedge_cb = ContinuousComponentCallback(cond, affect)\n\nTo enable the callback in simulation, we need to attach them to the individual edgemodels/vertexmodels.\n\nfor i in 1:ne(g)\n    edgemodel = nw[EIndex(i)]\n    set_callback!(edgemodel, edge_cb)\nend\nnothing #hide\n\nThe system starts at a steady state. In order to see any dynamic, we need to fail a first line intentionally. For that we use a PresetTimeComponentCallback, which triggers an ComponentAffect at a given time. We can reuse the previously defined component affect for that and just add it to line number 5 at time 1.0.\n\ntrip_first_cb = PresetTimeComponentCallback(1.0, affect)\nadd_callback!(nw[EIndex(5)], trip_first_cb)\nnothing #hide\n\nWhen we inspect the edge model for 5 no, we see that we've registered 2 callbacks:\n\nnw[EIndex(5)]\n\nNow we can simulate the network. The ODEProblem constructor accepts an NWState object directly and automatically extracts flat state and parameter arrays, constructs callbacks from component metadata, and handles parameter copying.\n\nu0 = NWState(nw)\nprob = ODEProblem(nw, u0, (0, 6))\n\nsol = solve(prob, Tsit5());\nnothing #hide\n\ntip: Tip\nFor more control over callback handling, the ODEProblem constructor provides keyword arguments like add_comp_cb, add_nw_cb, and override_cb. See the ODEProblem documentation for details.\n\nLastly we plot the power flow on all lines using the eidxs function to generate the symbolic indices for the states of interest:\n\nplot(sol; idxs=eidxs(sol, :, :P))","category":"section"},{"location":"generated/cascading_failure/#System-wide-Callbacks","page":"Cascading Failure","title":"System wide Callbacks","text":"The above solution relies on the ComponentCallback features of NetworkDynamics. The \"low-level\" API would be to use VectorContinuousCallback and PresetTimeCallback directly to achieve the same effect, essentially doing manually what get_callbacks(::Network) is doing for us.\n\nWhile not necessary in this case, this method offers more flexibility than the component based approach.\n\nIn order to implement the line failures, we need to create a VectorContinuousCallback. In the callback, we compare the current flow on the line with the limit. If the limit is reached, the coupling K is set to 0.\n\nFirst we can define the affect function:\n\nfunction affect!(integrator, idx)\n    println(\"Line $idx tripped at t=$(integrator.t)\")\n    p = NWParameter(integrator) # get indexable parameter object\n    p.e[idx, :K] = 0\n    auto_dt_reset!(integrator)\n    save_parameters!(integrator)\n    nothing\nend\nnothing #hide\n\nThere is one important aspect to this function: the save_parameters! call. In the callback, we change the parameters of the network, making the parameters time dependent. The flow on the line is a function P(t) = f(u(t), p(t)). Thus we need to inform the integrator, that a discrete change in parameters happend. With this, the solution object not only tracks u(t) but also p(t) and we may extract the observable P(t) directly.\n\nThe callback trigger condition is a bit more complicated. The straight forward version looks like this:\n\nfunction naive_condition(out, u, t, integrator)\n    # careful,  u != integrator.u\n    # therefore construct nwstate with Network info from integrator but u\n    s = NWState(integrator, u, integrator.p, t)\n    for i in eachindex(out)\n        out[i] = abs(s.e[i,:P]) - s.p.e[1,:limit] # compare flow with limit for line\n    end\n    nothing\nend\nnothing #hide\n\nHowever, from a performacne perspectiv there are problems with this solution: on every call, we need to perform symbolic indexing into the NWState object. Symbolic indexing is not cheap, as it requires to gather meta data about the network. Luckily, the SymbolicIndexingInterface package which powers the symbolic indexing provides the lower level functions getp and getu which can be used to create and cache accessors to the internal states.\n\nThis still isn't ideal beacuse both getlim and getflow getters will create arrays within the callback. But is far better then resolving the flat state indices every time.\n\ncondition = let getlim = SII.getp(nw, epidxs(nw, :, :limit)),\n                getflow = SII.getu(nw, eidxs(nw, :, :P))\n    function (out, u, t, integrator)\n        # careful,  u != integrator.u\n        # therefore construct nwstate with Network info from integrator but u\n        s = NWState(integrator, u, integrator.p, t)\n        out .= getlim(s) .- abs.(getflow(s))\n        nothing\n    end\nend\nnothing #hide\n\nWe can combine affect and condition to form the callback.\n\ntrip_cb = VectorContinuousCallback(condition, affect!, ne(g));\nnothing #hide\n\nSimilarily to before, we need to generate a initial perturbation by failing one line using a PresetTimeCallback. We see that every flow is below the trip value 1.0. Therefor we need to add a distrubance to the network. We do this by manually disabeling line 5 at time 1.\n\ntrip_first_cb = PresetTimeCallback(1.0, integrator->affect!(integrator, 5));\nnothing #hide\n\nNow we are set for solving the system again. This time we create our own callback set by combining both Callbacks manually.\n\ntip: System-wide Callbacks\nWhen using system-wide callbacks instead of component-based callbacks, you can pass them using the add_nw_cb keyword argument to the ODEProblem constructor.\n\nu0 = NWState(nw)\ncbset = CallbackSet(trip_cb, trip_first_cb)\nprob = ODEProblem(nw, uflat(u0), (0,6), pflat(u0); add_nw_cb=cbset)\nsol2 = solve(prob, Tsit5());\n# we want to test the reconstruction of the observables # hide\n@test all(!iszero, sol2(sol2.t; idxs=eidxs(sol2,:,:P)).u[begin]) # hide\n@test all(iszero, sol2(sol2.t; idxs=eidxs(sol2,:,:P)).u[end][[1:5...,7]]) # hide\nnothing #hide\n\nThen again we plot the solution:\n\nplot(sol2; idxs=eidxs(sol2,:,:P))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"callbacks/#Callbacks","page":"Callbacks and Events","title":"Callbacks and Events","text":"Callback-functions are a way of handling discontinuities in differential equations. In a nutshell, the solver checks for some \"condition\" (i.e. a zero crossing of some variable) and calls some \"affect\" if the condition is fulfilled. Within the affect function, it is safe to modify the integrator, e.g. changing some state or some parameter.\n\nSince NetworkDynamics.jl provides nothing more than a RHS for DifferentialEquations.jl, please check their docs on event handling as a general reference. This page is introducing the general concepts, for a hands on example of a simulation with callbacks refer to the Cascading Failure example.\n\nwarning: Warning\nThe ODEProblem contains a reference to exactly one copy of the flat parameter array. If you use callbacks to change those parameters (as we often do), it is advised to copy the parameter array before passing it to the ODEProblem!  Also, this means you need to be careful when using the same prob for multiple subsequent solve calls, as the initial state of the prob object might have changed!","category":"section"},{"location":"callbacks/#Component-based-Callback-functions","page":"Callbacks and Events","title":"Component-based Callback functions","text":"In practice, events often act locally, meaning they only depend and act on a specific component or type of component. NetworkDynamics.jl provides a way of defining those callbacks on a component level and automatically combine them into performant VectorContinuousCallback and DiscreteCallback for the whole network.\n\nThe main entry points are the types ContinuousComponentCallback, VectorContinuousComponentCallback and DiscreteComponentCallback. All of those objects combine a ComponentCondition with an ComponentAffect.\n\nThe \"normal\" ContinuousComponentCallback and DiscreteComponentCallback have a condition which returns a single value. The corresponding affect is triggered when the return value hits zero. In contrast, the \"vector\" version has an in-place condition which writes len outputs. When any of those outputs hits zero, the affect is triggered with an additional argument event_idx which tells the effect which dimension encountered the zerocrossing.\n\nThere is a special type PresetTimeComponentCallback which has no explicit condition and triggers the affect at given times. This internally generates a PresetTimeCallback object from DiffEqCallbacks.jl.","category":"section"},{"location":"callbacks/#Defining-the-Callback","page":"Callbacks and Events","title":"Defining the Callback","text":"To construct a condition function, you need to tell network dynamics which states and parameters you'd like to \"observe\" within the condition. Within the actual condition, those states will be made available:\n\ncondition = ComponentCond([:x, :y], [:p1, :p2]) do u, p, t\n    u[:x]  == u[1] # access a state or observable :x at current time\n    p[:p2] == p[2] # access a parameter at current time\n    return some_condition(u[:x], u[:y], ...)\nend\n\nIn case of a VectorContinuousComponentCallback, the function signature looks slightly different:\n\nvectorcondition = ComponentCond([:x, :y], [:p1, :p2]) do out, u, p, t\n    out[1] = some_condition(u[...], p[...])\n    out[2] = some_condition(u[...], p[...])\n    return nothing\nend\n\nNote that the syms argument (here [:x, :y]) can be used to reference any named state of the component model, this includes \"ordinary\" states, observed, inputs and outputs. The arguments u and p will be passed as SymbolicView objects, which mean it is possible to use the getindex syntax to acces the desired states by name.\n\nThe affect takes a similar form:\n\naffect = ComponentAffect([:u], [:p]) do u, p, ctx\n   t = ctx.t # extract data from context\n   obs = NWState(ctx.integrator)[VIndex(ctx.vidx, :obs)] # extract some observed state from context\n   println(\"Trigger affect at t=$t\")\nend\nvectoraffect = ComponentAffect([:u], [:p]) do u, p, event_idx, ctx\n    if event_idx == 1\n        u[:u] = 0 # change state\n    else\n        u[:p] = 0 # change parameter\n    end\nend\n\nNotably, the syms (here :u) can exclusively refer to \"ordinary\" states, since they are now writable. However the affect gets passed a ctx \"context\" object, which is a named tuple which holds additional context like the integrator object, the component model, the index of the component model, the current time and so on. Please refer to the ComponentAffect docstring for a detailed list.\n\nLastly we need to define the actual callback object using ContinuousComponentCallback/VectorContinuousComponentCallback:\n\nccb  = ContinuousComponentCallback(condition, affect; kwargs...)\nvccb = VectorContinuousComponentCallback(condition, affect; kwargs...)\n\nwhere the kwargs are passed to the underlying SciMLBase.VectorContinuousCallback to finetune the zerocrossing-detection.","category":"section"},{"location":"callbacks/#Registering-the-Callback","page":"Callbacks and Events","title":"Registering the Callback","text":"Once the callback is defined, we need to \"attach\" it to the component, for that you can use the methods add_callback! and set_callback!:\n\nvert = VertexModel(...)\nadd_callback!(vert, ccb)\nadd_callback!(vert, vccb)","category":"section"},{"location":"callbacks/#Extracting-the-Callback","page":"Callbacks and Events","title":"Extracting the Callback","text":"Component-level callbacks are automatically extracted and combined when constructing an ODEProblem:\n\nu0 = NWState(nw)\nprob = ODEProblem(nw, u0, (0, 10))\nsol = solve(prob, ...)\n\nFor more control over callback handling—such as adding network/system-level callbacks (e.g., PeriodicCallback), temporary component callbacks, or overriding the default callbacks, the ODEProblem constructor provides keyword arguments add_comp_cb, add_nw_cb, and override_cb. See the ODEProblem(nw::Network,...) documentation for details.\n\nWhen executing component callbacks, NetworkDynamics automatically checks whether states or parameters changed during the affect and calls SciMLBase.auto_dt_reset! and save_parameters! if necessary.","category":"section"},{"location":"callbacks/#Normal-DiffEq-Callbacks","page":"Callbacks and Events","title":"Normal DiffEq Callbacks","text":"Besides component based callbacks, it is also possible to use \"normal\" DiffEq callbacks together with NetworkDynamics.jl. It is far more powerful but also more cumbersome compared to the component based callback functions. To access states and parameters of specific components, we heavily rely on the Symbolic Indexing features.\n\nusing SymbolicIndexingInterface as SII\nnw = Network(#= some network =#)\n\ncondition = let getvalue = SII.getsym(nw, VIndex(1:5, :some_state))\n    function(out, u, t, integrator)\n        s = NWState(integrator, u, integrator.p, t)\n        some_state = getvalue(s)\n        out .= some_condition(some_state)\n    end\nend\n\nPlease note a few important things here:\n\nSymbolic indexing can be costly, and the condition function gets called very often. By using SII.getsym we did some of the work before the callback by creating the accessor function. When handling with \"normal states\" and parameters consider using SII.variable_index and SII.parameter_index for even better access patterns.\nt refers to the current time of the zerocrossing-detection-algorithm. This is different from integrator.t which refers to the current timestep in which the zerocross-detectio takes place..\n\nfunction affect!(integrator, vidx)\n    p = NWParameter(integrator) # get symbolically indexable parameter object\n    p.v[vidx, :some_vertex_parameter] = 0 # change some parameter\n    auto_dt_reset!(integrator)\n    save_parameters!(integrator)\nend\n\nThe affect function is much more straight forward, as it (typically) is called far less frequent and thus less perfomance critical.\n\nOnce the condition and affect! is defined, you can use the SciMLBase.ContinuousCallback and SciMLBase.VectorContinuousCallback constructors to create the callback.\n\nnote: Introducing discontinuities with adaptive timestepping\nSince changes to u and p mostly introduce discontinuities in the solution, it is recommend to call auto_dt_reset! within the affect to restart integration with small steps afterwards.\n\nnote: Changing Parameters and Observables\nAn \"observable\" is kind of a \"virtual\" state, which can be reconstructed for a given time t, a given state u and a given set of parameters po = f(u(t) p(t) t)To extract or plot timeseries of observed states under time variant parameters (i.e. parameters that are changed in a callback), those changes need to be recorded using the save_parameters! function whenever p is changed. When using ComponentCallback, NetworkDynamics will automatically check for changes in p and save them if necessary.","category":"section"},{"location":"generated/gas_network/#gas-example","page":"Gas Network","title":"Dynamic Flow in Simple Gas Network","text":"This example is based on the paper\n\nAlbertus J. Malan, Lukas Rausche, Felix Strehle, Sören Hohmann, Port-Hamiltonian Modelling for Analysis and Control of Gas Networks, IFAC-PapersOnLine, Volume 56, Issue 2, 2023, https://doi.org/10.1016/j.ifacol.2023.10.193.\n\nand tries to replicate a simple simulation of flow in a 3-node gas network.\n\nThis example can be dowloaded as a normal Julia script here.\n\nWe start by importing the necessary packages:\n\nusing NetworkDynamics\nusing ModelingToolkit\nusing DynamicQuantities\nusing ModelingToolkit: D as Dt, t as t\nusing Test\nusing StaticArrays\nusing DataInterpolations\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\nCairoMakie.activate!(type=\"svg\") #hide","category":"section"},{"location":"generated/gas_network/#Node-Models","page":"Gas Network","title":"Node Models","text":"In this example, we use equation-based modeling using ModelingToolkit.jl. To verify the equations on a basic level, we also provide units to everything to perform dimensionality checks.\n\nThere are 2 node models used in the paper. The first node type has a constant pressure. Additionally, we add some \"internal\" state q̃_inj which we want to plot later (see also Observables).\n\n@mtkmodel ConstantPressureNode begin\n    @parameters begin\n        p_set, [description=\"Constant pressure setpoint\", unit=u\"Pa\"]\n    end\n    @variables begin\n        p(t) = p_set, [description=\"Pressure\", unit=u\"Pa\", output=true]\n        q̃_nw(t), [description=\"aggregated flow from pipes into node\", unit=u\"m^3/s\", input=true]\n        q̃_inj(t), [description=\"internal state for introspection\", unit=u\"m^3/s\"]\n    end\n    @equations begin\n        p ~ p_set\n        q̃_inj ~ -q̃_nw\n    end\nend\nnothing #hide\n\nThe second node model is a variable pressure node. It has one output state (the pressure) and one input state, the aggregated flows from the connected pipes. As an internal state we have the injected flow from our source/load. The source/load behavior itself is provided via a time-dependent function.\n\n@mtkmodel VariablePressureNode begin\n    @structural_parameters begin\n        load_profile # time dependent load profile\n    end\n    @constants begin\n        load_unit = 1, [description=\"unit of the load profile\", unit=u\"m^3/s\"]\n    end\n    @parameters begin\n        C, [description=\"Lumped capacitance of connected pipes\", unit=u\"m^4 * s^2 / kg\"]\n    end\n    @variables begin\n        p(t)=5e6, [description=\"Pressure\", unit=u\"Pa\", output=true]\n        q̃_inj(t), [description=\"external injection into node\", unit=u\"m^3/s\"]\n        q̃_nw(t), [description=\"aggregated flow from pipes into node\", unit=u\"m^3/s\", input=true]\n    end\n    @equations begin\n        q̃_inj ~ load_profile(t) * load_unit\n        C * Dt(p) ~ q̃_inj + q̃_nw # (30)\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/gas_network/#Pipe-Model","page":"Gas Network","title":"Pipe Model","text":"The pipe is modeled as a first-order ODE for the volumetric flow at the dst end. It has two inputs: the pressure at the source and the pressure at the destination end. Later on, we'll specify the model to be antisymmetric, thus the flow is calculated explicitly for the destination end, but the source end will just receive that times (-1).\n\n@mtkmodel Pipe begin\n    @parameters begin\n        L, [description=\"Length of pipe\", unit=u\"m\"]\n        D, [description=\"Diameter of pipe\", unit=u\"m\"]\n        A, [description=\"Cross-sectional area of pipe\", unit=u\"m^2\"]\n        sinθ, [description=\"Angle of inclination\" ]\n        γ, [description=\"Friction efficiency factor\"]\n        η, [description=\"Dynamic viscosity\", unit=u\"kg/(m*s)\"]\n        r, [description=\"Pipe roughness\", unit=u\"m\"]\n        g, [description=\"Gravitational acceleration\", unit=u\"m/s^2\"]\n        T, [description=\"simulation temperature\", unit=u\"K\"]\n        Tc, [description=\"crictical temperature\", unit=u\"K\"]\n        pc, [description=\"critical pressure\", unit=us\"Pa\"]\n        Rs, [description=\"Specific gas constant for natural gas\", unit=us\"J/(kg*K)\"]\n        c̃, [description=\"Speed of sound in fluid at standard conditions\", unit=u\"m/s\"]\n        ρ̃, [description=\"standard density\", unit=u\"kg/m^3\"]\n        p̃, [description=\"standard pressure\", unit=us\"Pa\"]\n    end\n    @variables begin\n        p_src(t), [description=\"Pressure at source end\", unit=us\"Pa\", input=true]\n        p_dst(t), [description=\"Pressure at destination end\", unit=us\"Pa\", input=true]\n        q̃(t)=1, [description=\"Flow through pipe\", unit=u\"m^3/s\", output=true]\n        Re(t), [description=\"Reynolds number\"]\n        λ(t), [description=\"Friction factor\"]\n        λe(t), [description=\"Effective friction factor\"]\n        pM(t), [description=\"mean pressure\", unit=us\"Pa\"]\n        Z(t), [description=\"compressibility factor\"]\n        ρ(t), [description=\"density\", unit=u\"kg/m^3\"]\n        c(t), [description=\"speed of sound\", unit=u\"m/s\"]\n    end\n    @equations begin\n        Z ~ 1 - 3.52 * pM/pc * exp(-2.26*(T/Tc)) + 0.274 * (pM/pc)^2 * exp(-1.878*(T/Tc)) # (5)\n        ρ ~ pM / (Rs * T * Z) # (4)\n\n        # TODO: Whats the correct speed of sound?\n        c ~ sqrt(T * Rs * Z) # (4) # pressure/temp dependent\n        # c ~ c̃                   # \"standard\" speed of sound based on standard conditions\n\n        # TODO: Whats the correct Reynolds number?\n        Re ~ (ρ * abs(q̃*p̃/pM) * D) / (η * A) # (6) # based \"actual\" conditions\n        # Re ~ (ρ̃ * abs(q̃) * D) / (η * A) # (6)   # based on standard conditions\n\n        λ ~ ifelse(Re < 2300,\n            64/Re, # laminar (7)\n            (2*log10(4.518/Re * log10(Re/7) + r/(3.71*D)))^(-2) # turbulent (8)\n        )\n        λe ~ λ/γ^2 # (10)\n        pM ~ 2/3*(p_src + p_dst - (p_src*p_dst)/(p_src + p_dst)) # (20)\n\n        Dt(q̃) ~ A/(L*ρ̃)*(-(λe * ρ̃^2 * c^2 * L * abs(q̃))/(2 * D * A^2 * pM) * q̃ - (g * L * sinθ)/(c^2) * pM + (p_src - p_dst)) # (31)\n    end\nend\nnothing #hide","category":"section"},{"location":"generated/gas_network/#Parametrization","page":"Gas Network","title":"Parametrization","text":"The parameterization turned out to be a bit tricky. There might be errors in there.\n\nSome of them are quite cleare and explicitly given.\n\ng = 9.81u\"m/s^2\"       # that we just know\nRs = 518.28u\"J/(kg*K)\" # Specific gas constant for natural gas\nη  = 1e-5u\"kg/(m*s)\"   # Dynamic viscosity\npc = 46.5u\"bar\"        # Critical pressure\np̃  = 1.01325u\"bar\"     # standard pressure\nTc = 190.55u\"K\"        # critical temperature\nT̃  = 273.15u\"K\"        # standard temperature\nT  = 278u\"K\"           # simulation temperature\nγ  = 0.98              # friction efficiency factor\nr  = 0.012u\"mm\"        # pipe roughness\nD  = 0.6u\"m\"           # pipe diameter\n\nL₁₂ = 90u\"km\"\nL₁₃ = 80u\"km\"\nL₂₃ = 100u\"km\"\nΔh₁ = 0u\"km\"           # this value is different for different sims in the paper\np₁_set = 50u\"bar\"\nnothing # hide\n\nThe geometric parameters for the pipes can be directly derived.\n\nA = π/4 * D^2\nsinθ₁₂ = ustrip(Δh₁ / L₁₂)\nsinθ₁₃ = ustrip(Δh₁ / L₁₃)\nsinθ₂₃ = 0.0\nnothing # hide\n\nLastly, we need to calculate the compressibility factor, the speed of sound, and the density at standard conditions:\n\nZ̃ = 1 - 3.52 * p̃/pc * exp(-2.26*(T̃/Tc)) + 0.274 * (p̃/pc)^2 * exp(-1.878*(T̃/Tc)) # (5)\nc̃ = sqrt(T̃ * Rs * Z̃) # (4) at standard conditions\nρ̃ = p̃ / (Rs * T̃ * Z̃) # (4) at standard conditions\n\nnothing # hide\n\nThe equivalent \"pressure capacity\" at the nodes is calculated as a sum of the connected pipe parameters according to (28).\n\nHere we use definitions based on the speed and \"standard\" conditions.\n\nC₂ = L₁₂*A/(2*ρ̃*c̃^2) + L₂₃*A/(2*ρ̃*c̃^2) # (28)\nC₃ = L₁₃*A/(2*ρ̃*c̃^2) + L₂₃*A/(2*ρ̃*c̃^2) # (28)\nnothing #hide\n\nAlternatively, we could calculate Z2 and Z3 based on the actual pressure and simulation temperature. Then we could calculate the speed of sound for the \"correct\" conditions at the node. It seems to have very little effect on the actual results, so I kept it simple.\n\nnothing #hide","category":"section"},{"location":"generated/gas_network/#Load-Profile","page":"Gas Network","title":"Load Profile","text":"The paper specifies the load profile at two nodes. We use the package DataInterpolations.jl to get a callable object which represents this piecewise linear interpolation.\n\nCurrently, the linear interpolation does not support any units yet. To satisfy the static unit check, we multipy the interpolation output by a constant 1 of that unit.\n\nNote however, that the unit check is only performed at the construction of the model. Later on, when the numeric code will be generated from the symbolic representation, all units will be stripped.\n\nnote: Discontinuities in RHS\nThe piecewise linear interpolated function creates discontinuities in the RHS of the system. However, since we know the times exactly, we can handle this by simply giving a list of explicit tstops to the solve command, to make sure those are hit exactly.\n\nload2 = LinearInterpolation(-1*Float64[20, 30, 10, 30, 20], [0, 4, 12, 20, 24]*3600.0; extrapolation=ExtrapolationType.Constant)\nload3 = LinearInterpolation(-1*Float64[40, 50, 30, 50, 40], [0, 4, 12, 20, 24]*3600.0; extrapolation=ExtrapolationType.Constant)\nModelingToolkit.get_unit(::LinearInterpolation, _ ) = 1.0 # type piracy!\nnothing #hide\n\nAs a workaround we had to explicitly define LinearInterpolations as unitless, which is type piracy! Don't to this in any package code!","category":"section"},{"location":"generated/gas_network/#Building-the-Network","page":"Gas Network","title":"Building the Network","text":"To build the network, we first need to define the components. This is a two-step process:\n\nfirst create the symbolic System using ModelingToolkit\nsecondly build a NetworkDynamics component model (VertexModel/EdgeModel) based on the symbolic system.\n\nIn the first step we can use the keyword arguments to pass \"default\" values for our parameters and states. Those values will be automatically transferred to the metadata of the component model in the second step.\n\nThe second step requires to define the interface variables, i.e. what are the \"input\" states of your component model and what are the \"output\" states. For VertexModel the input state is the aggregated flow of all connected pipes. The output state is the pressure of the node.\n\n@named v1_mtk = ConstantPressureNode(p_set=p₁_set)\nv1 = VertexModel(v1_mtk, [:q̃_nw], [:p]; name=:v1, vidx=1)\n\n@named v2_mtk = VariablePressureNode(C=C₂, load_profile=load2)\nv2 = VertexModel(v2_mtk, [:q̃_nw], [:p]; name=:v2, vidx=2)\n\n@named v3_mtk = VariablePressureNode(C=C₃, load_profile=load3)\nv3 = VertexModel(v3_mtk, [:q̃_nw], [:p]; name=:v3, vidx=3)\n\nFor the edge model we have two inputs: the pressure on both source and destination end. There is a single output state: the volumetric flow. However, we also need to tell NetworkDynamics about the coupling type. In this case we use AntiSymmetric, which means that the source end will receive the same flow, just with inverted sign.\n\n@named e12_mtk = Pipe(; L=L₁₂, sinθ=sinθ₁₂, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)\n@named e13_mtk = Pipe(; L=L₁₃, sinθ=sinθ₁₃, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)\n@named e23_mtk = Pipe(; L=L₂₃, sinθ=sinθ₂₃, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)\n\ne12 = EdgeModel(e12_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e12, src=1, dst=2)\ne13 = EdgeModel(e13_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e13, src=1, dst=3)\ne23 = EdgeModel(e23_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e23, src=2, dst=3)\n\nTo build the network object we just need to pass the vertices and edges to the constructor.\n\nNote that we've used the vidx and src/dst keywords in the constructors to define for each component to which \"part\" of the network it belongs.\n\nThis means the constructor can automatically construct a graph based on that information and we don't need to pass it explicitly.\n\nnw = Network([v1, v2, v3], [e12, e13, e23])\n\nAs a result, we recive a network with 3 unique types (v2 and v3 are similar but structurally different, because both functions capure a unique loadprofile function).","category":"section"},{"location":"generated/gas_network/#Finding-a-Steady-State","page":"Gas Network","title":"Finding a Steady State","text":"To simulate the system, we first need to find a steady state. As a \"guess\" for that, we create a NWState object from the network. This will allocate flat arrays for states u and parameters p and fill them with the default values.\n\nuguess = NWState(nw)\n\nThis is not a steady state of the system however. To find a true steady state, we want to ensure that the LHS of the system is zero.\n\nWe can use the find_fixpoint from NetworkDynamics.jl to initialize the system. Internally, this uses a numerical solve for the rootfind problem 0 = rhs. The result is automaticially wrapped as a NWState object.\n\nu0 = find_fixpoint(nw, uguess, t=0)","category":"section"},{"location":"generated/gas_network/#Solving-the-ODE","page":"Gas Network","title":"Solving the ODE","text":"Using this as our initial state we can create the actual ODEProblem.\n\nprob = ODEProblem(nw, u0, (0.0,24*3600))\nsol = solve(prob, Tsit5(), tstops=[0,4,12,20,24]*3600)\nnothing #hide","category":"section"},{"location":"generated/gas_network/#Inspect-the-Solution","page":"Gas Network","title":"Inspect the Solution","text":"Inspecting the solution is all which is left to do.\n\nxticks = ((0:4:24)*3600, string.(0:4:24)) # its nice to display hours\nfig = begin\n    _fig = Figure()\n    row = 1\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"pressure [Pa]\", title=\"Pressure at nodes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    ylims!(ax, 47.9e5, 49.9e5)\n    for i in 1:3\n        lines!(ax, sol, idxs=vidxs(nw, i, :p); label=\"v$i\", color=Cycled(i))\n    end\n    axislegend(ax)\n    row += 1\n\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"flow [m³/s]\", title=\"Flow through pipes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    ylims!(ax, 16, 44)\n    for i in 1:2\n        lines!(ax, sol, idxs=eidxs(nw, i, :q̃); label=\"e$i flow\", color=Cycled(i))\n    end\n    axislegend(ax, position=:rb)\n    row += 1\n    _fig\nend\n\nNotably, the \"internal\" states defined in the symbolic models are not \"states\" in the sense of the ODE. For example, we captured the load profile in the q̃_inj state of the VariablePressureNode. The only dynamic state of the model however is p. Using the \"observables\" mechanism from SciML, which is implemented by NetworkDynamics, we can reconstruct those \"optimized\" states which have been removed symbolically. Here we plot the reconstructed load profile of nodes 2 and 3. Also, we know that node 1 is infinitely stiff, acting as an infinite source of volumetric flow. We can reconstruct this flow too.\n\nfig = begin\n    _fig = Figure()\n    row = 1\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"flow [m³/s]\", title=\"Flow at nodes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    lines!(ax, sol, idxs=vidxs(nw, 1, :q̃_inj); label=\"v1 compensation\", color=Cycled(1))\n    for i in 2:3\n        lines!(ax, sol, idxs=vidxs(nw, i, :q̃_inj); label=\"v$i load profile\", color=Cycled(i))\n    end\n    axislegend(ax, position=:rc)\n    _fig\nend\n\nLastly we want to observe two internal states of the pipes: the Reynolds number and the mean pressure. We see, that we're purely in the turbulent flow regime.\n\nfig = begin\n    _fig = Figure()\n    row = 1\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"Reynolds number\", title=\"Reynolds number\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    for i in 1:3\n        lines!(ax, sol, idxs=eidxs(nw, i, :Re); label=\"e $i\", color=Cycled(i))\n    end\n    hlines!(ax, 2300, color=:black, linestyle=:dash, label=\"L/T transition\")\n    axislegend(ax, position=:rb)\n    row += 1\n\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"Mean pressure [Pa]\", title=\"Mean pressure in pipes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    for i in 1:3\n        lines!(ax, sol, idxs=eidxs(nw, i, :pM); label=\"e $i\", color=Cycled(i))\n    end\n    axislegend(ax, position=:rb)\n    _fig\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#NetworkDynamics","page":"General","title":"NetworkDynamics","text":"The NetworkDynamics.jl package simulates the dynamics of complex networks. It provides an interface  between the Graphs.jl and the  DifferentialEquations.jl packages and facilitates the simulation of  highly efficient dynamic networks by describing the local dynamics of the edges and vertices of the network.\n\nThe core idea of this package is to define the global dynamics of a complex network in terms of local dynamics: each node and each edge exhibits some local dynamics defined as an input-output system. The graph topology describes, how the local dynamical systems are interconnected. To learn more check out the docs on the Mathematical Model behind NetworkDynamics.jl. For basic terminology see the Wikipedia article on Graph Theory.\n\nMain features:\n\nClear separation of local dynamics and topology: you can easily change the topology of your system or switch out dynamic components.\nHigh performance when working with heterogeneous models: you can have different local dynamics in different parts of your network.\nSymbolic Indexing into solutions and states: NetworkDynamics keeps track of the states of each individual subsystem.\nDiverse execution schemes: NetworkDynamics exploits the known interdependencies between components to auto parallelize execution, even on GPUs!\nEquation based models: you can model local dynamics using  ModelingToolkit.jl and then combine them into larger networks using NetworkDynamics.jl!","category":"section"},{"location":"#Where-to-begin?","page":"General","title":"Where to begin?","text":"To learn how to implement your own models and understand the underlying modeling ideas of NetworkDynamics you should  first read the Mathematical Model section, followed by the Network Construction section.\n\nIf you prefer to look at some concrete code first check out the Getting Started tutorial!","category":"section"},{"location":"#Installation","page":"General","title":"Installation","text":"Install Julia:\n\nJulia Installation\nFind your OS and follow the instructions for the installation\n\nInstall NetworkDynamics.jl with Julia's package manager:\n\n(v1.11) pkg> add NetworkDynamics\n\nTo learn more about how to use Julia you can visit: Modern Julia Workflows","category":"section"},{"location":"#Reproducibility","page":"General","title":"Reproducibility","text":"<details><summary>Direct dependencies used for this documentation:</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>Julia Version:</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>Full Manifest:</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>","category":"section"},{"location":"#Funding","page":"General","title":"Funding","text":"Development of this project was in part funded by the German Federal Ministry for Economic Affairs and Climate Action  as part of the OpPoDyn-Project (Project ID 01258425/1, 2024-2027).\n\n<img src=\"assets/bmwk_logo_en.svg\" width=\"300\"/>","category":"section"},{"location":"network_construction/#Network-Construction","page":"Network Construction","title":"Network Construction","text":"","category":"section"},{"location":"network_construction/#Building-a-Network","page":"Network Construction","title":"Building a Network","text":"The main type of NetworkDynamics.jl is a Network. A network bundles various component models (edge and vertex models) together with a graph to form a callable object which represents the right hand side (RHS) of the overall dynamical system, see Mathematical Model.\n\nA Network is build by passing a graph g, vertex models vertexm and edge models edgem to the Network constructor:.\n\nnw = Network(g, vertexm, edgem; kwargs...)\n\nTwo important keywords for the Network constructor are:\n\nexecution:   Defines the ExecutionStyle of the coreloop, e.g. SequentialExecution{true}().   A execution style is a special Julia object, which tells the backend how to parallelize (e.g. ThreadedExecution{true}() will use native Julia threads to parallelize the RHS call).   A list of available executions styles can be found under Execution Types in the API.\naggregator:   Instructs the backend how to perform the aggregation and which aggregation function to use.   Aggregation is the process of creating a single vertex input by reducing over the outputs of adjecent edges of said vertex. The aggregator contains both the function and the algorithm. E.g. SequentialAggregator(+) is a sequential aggregation by summation. A list of availabe Aggregators can be found under Aggregators in the API.","category":"section"},{"location":"network_construction/#Graphless-Constructor","page":"Network Construction","title":"Graphless Constructor","text":"If each of the network components has a \"graphelement\" metadata, we may omit the explicit graph.\n\nnw = Network(vertexm, edgem)\n\nThe graphelement metadata can be set using the following syntax:\n\nVertexModel(; ..., vidx=1)         # places vertex at position 1\nEdgeModel(; ..., src=1, dst=2)     # places edge between 1 and 2\nEdgeModel(; ..., src=:v1, dst=:v2) # places edge between vertices with names `:v1` and `:v2`","category":"section"},{"location":"network_construction/#Building-VertexModels","page":"Network Construction","title":"Building VertexModels","text":"This chapter will walk you through the most important aspects of defining a custom vertex model. For a list of all keyword arguments please check out the docstring of VertexModel.\n\nAs an example, we'll construct an second order kuramoto model.\n\nusing NetworkDynamics #hide\nfunction kuramoto_f!(dv, v, esum, p, t)\n    M, P, D = p\n    dv[1] = v[2]\n    dv[2] = (P - D*v[2] + esum[1])/M\n    nothing\nend\nfunction kuramoto_g!(y, v, esum, p, t)\n    y[1] = v[1]\n    nothing\nend\nVertexModel(; f=kuramoto_f!, g=kuramoto_g!, dim=2, pdim=3, outdim=1)\n\nThose keywords are the minimum metadata we need to provide.\n\nHowever there is a problem: the vertex is classified as a FeedForward vertex, which is unnecessary. We can improve the implementation of g according to the Feed Forward Behavior section.\n\nfunction kuramoto_g_noff!(y, v, p, t)\n    y[1] = v[1]\n    nothing\nend\nVertexModel(; f=kuramoto_f!, g=kuramoto_g_noff!, dim=2, pdim=3, outdim=1)\n\nTo simplify your programming and avoid explicitly writing the above trivial output function you can use StateMask. By writing\n\nVertexModel(; f=kuramoto_f!, g=StateMask(1:1), dim=2, pdim=3)\n\nwe are instructing the vertex model, that the output is part of the states x[1:1]. This results in the following changes:\n\noutdim is removed because it can be inferred from StateMask\noutsym is not a generic :o any more but inferred from the state symbols.\n\nWe can be even less verbose by writing g=1:1 or just g=1.\n\nLastly, we define improved names for our states and parameters as well as assigning a position in the graph to enable the graphless network construction. Whenever you provide a sym keyword the corresponding dim keyword stops being neccessary. So, we end up with a relatively short definition\n\nVertexModel(; f=kuramoto_f!, g=1,\n              sym=[:θ, :ω], psym=[:M=>1, :P=>0.1, :D=>0],\n              insym=[:P_nw], name=:swing, vidx=1)","category":"section"},{"location":"network_construction/#Building-EdgeModels","page":"Network Construction","title":"Building EdgeModels","text":"This chapter walks you through the most important aspects when defining custom edge models. For a list of all keyword arguments please check the docstring of EdgeModel.\n\nAs an example edge model we define a standard sinusoidal coupling between the vertices in our network. The full definition is:\n\nfunction edge_f!(de, e, vsrc, vdst, p, t)\n    nothing\nend\nfunction edge_g!(ysrc, ydst, e, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\n    ysrc[1] = -ydst[1]\nend\nEdgeModel(; f=edge_f!, g=edge_g!, dim=0, pdim=1, outdim=1)\n\nThis is a purely \"static\" edge without internal states. This means we can omit f and dim entirely. Also, we can define a variant of g without the e input\n\nfunction edge_g_ff!(ysrc, ydst, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\n    ysrc[1] = -ydst[1]\nend\nEdgeModel(;g=edge_g_ff!, pdim=1, outdim=1)\n\nwhich classifies as a PureFeedForward edge. In cases like this, where the edge is actually anti-symmetrical we can define a single sided output function and wrap it in an AntiSymmetric object:\n\nfunction edge_g_s!(ydst, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\nend\nEdgeModel(;g=AntiSymmetric(edge_g_ff!), pdim=1, outdim=1)\n\nThis can also lead to briefer output naming. Available single sided wrappers are:\n\nDirected (no coupling at src),\nAntiSymmetric (same coupling at src and dst),\nSymmetric (inverse coupling at dst) and\nFiducial (define separate g for both ends).\n\nOnce again we can add additonal data like defining a src and dst index\n\nfunction edge_g_s!(ydst, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\nend\nEdgeModel(;g=AntiSymmetric(edge_g_ff!), psym=:K=>1, outsym=:P, insym=:θ, src=1, dst=4)","category":"section"}]
}
