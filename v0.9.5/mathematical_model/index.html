<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Model · NetworkDynamics</title><meta name="title" content="Mathematical Model · NetworkDynamics"/><meta property="og:title" content="Mathematical Model · NetworkDynamics"/><meta property="twitter:title" content="Mathematical Model · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li class="is-active"><a class="tocitem" href>Mathematical Model</a><ul class="internal"><li><a class="tocitem" href="#Vertex-Models"><span>Vertex Models</span></a></li><li><a class="tocitem" href="#Edge-Models"><span>Edge Models</span></a></li><li><a class="tocitem" href="#Feed-Forward-Behavior"><span>Feed Forward Behavior</span></a></li></ul></li><li><a class="tocitem" href="../network_construction/">Network Construction</a></li><li><span class="tocitem">Features</span><ul><li><a class="tocitem" href="../symbolic_indexing/">Symbolic Indexing</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../external_inputs/">External Inputs</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../generated/directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li><li><a class="tocitem" href="../generated/heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../generated/cascading_failure/">Cascading Failure</a></li><li><a class="tocitem" href="../generated/stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../generated/gas_network/">Gas Network</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Mathematical Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/src/mathematical_model.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-Model"><a class="docs-heading-anchor" href="#Mathematical-Model">Mathematical Model</a><a id="Mathematical-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Model" title="Permalink"></a></h1><p>The basic mathematical model of <code>NetworkDynamics.jl</code> splits up the system it two parts: vertex and edge components.</p><p>The main goal of <code>NetworkDynamics.jl</code> is, to express the overall network dynamics as a Differential-Algebraic-Equation (DAE)</p><p class="math-container">\[M\,\frac{\mathrm{d}}{\mathrm{d}t}u = f^{\mathrm{nw}}(u, p, t)\]</p><p>where M is a (possibly singular) mass matrix, <span>$u$</span> is the internal state vector of the system, <span>$p$</span> are the parameters and <span>$t$</span> is the time. To make this compatible with the solvers for <code>OrdinaryDiffEq.jl</code>, the created <a href="../API/#NetworkDynamics.Network"><code>Network</code></a> object is a callable object</p><pre><code class="nohighlight hljs">nw(du, u, p, t) # mutates du</code></pre><p>with stored mass matrix information to build an <code>ODEProblem</code> based on the <code>Network</code>.</p><p>Instead of defining <span>$f^{\mathrm{nw}}$</span> by hand, <code>ND.jl</code> helps you to build it automatically based on a list of decentralized nodal and edge dynamics, so-called <code>VertexModel</code> and <code>EdgeModel</code> objects. Each component model <span>$\mathrm c$</span> is modeled as general input-output-system</p><p class="math-container">\[\begin{aligned}
M_{\mathrm c}\,\frac{\mathrm{d}}{\mathrm{d}t}x_{\mathrm c} &amp;= f^{\mathrm c}(x^{\mathrm c}, i_{\mathrm c}, p_{\mathrm c}, t)\\
y^{\mathrm c} &amp;= g^{\mathrm c}(x^\mathrm{c}, i_{\mathrm c}, p_{\mathrm c}, t)
\end{aligned}\]</p><p>where <span>$M_{\mathrm{c}}$</span> is the component mass matrix, <span>$x^{\mathrm c}$</span> are the component states, <span>$i^{\mathrm c}$</span> are the <em>inputs</em> of the component and <span>$y^{\mathrm c}$</span> is the <em>output</em> of the component. It is possible to have <span>$\mathrm{dim}(x^{\mathrm{c}}) = 0$</span> and thus no internal states.</p><p>In the network context, the <strong>output of the edges are flow variables</strong>. The <strong>outputs of vertices are potential variables</strong>. In interconnection, the <em>flow</em> on the edges depends on the <em>potentials</em> at both ends as inputs. The <em>potentials</em> of the nodes depend on the incoming <em>flows</em> from all connected edges as an input. (Here, flow and potentials are meant in a conceptional and not necessarily physical way.)</p><img src="../assets/mathmodel.svg" width="100%"/><h2 id="Vertex-Models"><a class="docs-heading-anchor" href="#Vertex-Models">Vertex Models</a><a id="Vertex-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-Models" title="Permalink"></a></h2><p>Specifically, a (single-layer) vertex model has one input, and one output. The input is an aggregation/reduction over all <em>incident edge outputs</em>,</p><p class="math-container">\[i^{\mathrm v} = \mathop{\mathrm{agg}}\limits_k^{\text{incident}} y^{\mathrm e}_k \qquad\text{often}\qquad
i^{\mathrm v} = \sum_k^{\text{incident}} y^{\mathrm e}_k\]</p><p>The full vertex model</p><p class="math-container">\[\begin{aligned}
M^{\mathrm v}\,\frac{\mathrm{d}}{\mathrm{d}t}x^{\mathrm v} &amp;= f^{\mathrm v}(u^{\mathrm v}, i^{\mathrm v}, p^{\mathrm v}, t)\\
y^{\mathrm v} &amp;= g^{\mathrm v}(u^{\mathrm v}, i^{\mathrm v}, p^{\mathrm v}, t)
\end{aligned}\]</p><p>corresponds to the Julia functions</p><pre><code class="language-julia hljs">function fᵥ(dxᵥ, xᵥ, e_aggr, pᵥ, t)
    # mutate dxᵥ
    nothing
end
function gᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)
    # mutate yᵥ
    nothing
end
vertf = VertexModel(; f=fᵥ, g=gᵥ, mass_matrix=Mᵥ, ...)</code></pre><h2 id="Edge-Models"><a class="docs-heading-anchor" href="#Edge-Models">Edge Models</a><a id="Edge-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-Models" title="Permalink"></a></h2><p>In contrast to vertex models, edge models in general have <em>two</em> inputs and <em>two</em> outputs, both for source and destination end of the edge. We commonly use <code>src</code> and <code>dst</code> to describe the source and destination end of an edge respectively. </p><div class="admonition is-info"><header class="admonition-header">On the directionality of edges</header><div class="admonition-body"><p>Mathematically, in a system defined on an undirected graph there is no difference between the edge <span>$(1,2)$</span> and <span>$(2,1)$</span>, the edge has no direction. However, from an implementation point of view we always need to have some kind of ordering for function arguments, state order and so on. For undirected graphs, <code>Graphs.jl</code> chooses the direction of an edge <code>v1-&gt;v2</code> such that <code>v1 &lt; v2</code>.</p></div></div><p>The <em>inputs</em> of the edge are just the outputs of the two nodes at both ends. The output is split into two: the <code>dst</code> output goes to the input of the vertex at the destination end, the <code>src</code> output goes to the input of the vertex at the <code>src</code> end.</p><p>The full model of an edge</p><p class="math-container">\[\begin{aligned}
M^{\mathrm e}\,\frac{\mathrm{d}}{\mathrm{d}t}x^{\mathrm e} &amp;= f^{\mathrm e}(u^{\mathrm e}, y^{\mathrm v}_{\mathrm{src}}, y^{\mathrm v}_{\mathrm{dst}}, p^{\mathrm e}, t)\\
y^{\mathrm e}_{\mathrm{dst}} &amp;= g_\mathrm{dst}^{\mathrm e}(u^{\mathrm e}, y^{\mathrm v}_{\mathrm{src}}, y^{\mathrm v}_{\mathrm{dst}}, p^{\mathrm e}, t)\\
y^{\mathrm e}_{\mathrm{src}} &amp;= g_\mathrm{src}^{\mathrm e}(u^{\mathrm e}, y^{\mathrm v}_{\mathrm{src}}, y^{\mathrm v}_{\mathrm{dst}}, p^{\mathrm e}, t)
\end{aligned}\]</p><p>corresponds to the Julia functions</p><pre><code class="language-julia hljs">function fₑ(dxₑ, xₑ, v_src, v_dst, pₑ, t)
    # mutate dxᵥ
    nothing
end
function gₑ(y_src, y_dst, xᵥ, v_src, v_dst, pₑ, t)
    # mutate y_src and y_dst
    nothing
end
vertf = EdgeModel(; f=fₑ, g=gₑ, mass_matrix=Mₑ, ...)</code></pre><p>The sign convention for both outputs of an edge must be identical,  typically, a positive flow represents a flow <em>into</em> the connected vertex. This is important, because the vertex only receives the flows, it does not know whether the flow was produce by the source or destination end of an edge.</p><pre><code class="nohighlight hljs">          y_src     y_dst 
  V_src o───←─────────→───o V_dst
</code></pre><h3 id="Single-Sided-Edge-Outputs"><a class="docs-heading-anchor" href="#Single-Sided-Edge-Outputs">Single Sided Edge Outputs</a><a id="Single-Sided-Edge-Outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Sided-Edge-Outputs" title="Permalink"></a></h3><p>Often, edge outputs will possess some symmetry which makes it more convenient to define &quot;single sided&quot; edge output functions</p><pre><code class="language-julia hljs">function g_single(y, xᵥ, v_src, v_dst, pₑ, t)
    # mutate y
    nothing
end</code></pre><p>There are multiple wrappers available to automaticially convert them into double-sided edge output functions:</p><ul><li><code>Directed(g_single)</code> builds a double-sided function <em>which only couples</em> to the destination side.</li><li><code>Symmetric(g_single)</code> builds a double-sided function in which both ends receive <code>y</code>.</li><li><code>AntiSymmetric(g_single)</code> builds a double-sided function where the destination receives <code>y</code> and the source receives <code>-y</code>.</li><li><code>Fiducial(g_single_src, g_singl_dst)</code> builds a double-sided edge output function based on two single sided functions.</li></ul><h2 id="Feed-Forward-Behavior"><a class="docs-heading-anchor" href="#Feed-Forward-Behavior">Feed Forward Behavior</a><a id="Feed-Forward-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Feed-Forward-Behavior" title="Permalink"></a></h2><p>The most general version of the component models can contain direct feed forwards from the input, i.e. the edge output might depend directly on the connected vertices or the vertex output might depend directly on the aggregated edge input.</p><p>Whenever possible, you should define output functions without feed forwards, i.e.</p><pre><code class="language-julia hljs">gᵥ_noff(yᵥ, xᵥ, pᵥ, t)
gₑ_noff([y_src,] y_dst, xᵥ, pₑ, t)</code></pre><p>instead of the more general</p><pre><code class="language-julia hljs">gᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)
gₑ([y_src], y_dst, xᵥ, v_src, v_dst, pₑ, t)</code></pre><p>NetworkDynamics cannot couple two components with feed forward to each other. It is always possible to transform feed forward behavior to an internal state <code>x</code> with mass matrix entry zero to circumvent this problem. This transformation can be performed automatically by using <a href="../API/#NetworkDynamics.ff_to_constraint"><code>ff_to_constraint</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Feed Forward Vertices</header><div class="admonition-body"><p>As of 11/2024, vertices with feed forward are not supported at all. Use <a href="../API/#NetworkDynamics.ff_to_constraint"><code>ff_to_constraint</code></a> to transform them into vertex model without FF.</p></div></div><p>Concretely, NetworkDynamics distinguishes between 4 types of feed forward behaviors of <code>g</code> functions based on the <a href="../API/#NetworkDynamics.FeedForwardType"><code>FeedForwardType</code></a> trait. The different types the signature of provided function <code>g</code>. Based on the signatures avaialable, ND.jl will try to find the correct type automaticially. Using the <code>ff</code> keyword in the constructors, the user can enforce a specific type.</p><p><strong><a href="../API/#NetworkDynamics.PureFeedForward"><code>PureFeedForward()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          ins...,       p, t) # abstractly
g!(out_dst,          v_src, v_dst, p, t) # single-sided edge
g!(out_src, out_dst, v_src, v_dst, p, t) # double-sided edge
g!(v_out,            e_aggr,       p, t) # single layer vertex</code></pre><p><strong><a href="../API/#NetworkDynamics.FeedForward"><code>FeedForward()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          x, ins...,       p, t) # abstractly
g!(out_dst,          x, v_src, v_dst, p, t) # single-sided edge
g!(out_src, out_dst, x, v_src, v_dst, p, t) # double-sided edge
g!(v_out,            x, e_aggr,       p, t) # single layer vertex</code></pre><p><strong><a href="../API/#NetworkDynamics.NoFeedForward"><code>NoFeedForward()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          x, p, t) # abstractly
g!(out_dst,          x, p, t) # single-sided edge
g!(out_src, out_dst, x, p, t) # double-sided edge
g!(v_out,            x, p, t) # single layer vertex</code></pre><p><strong><a href="../API/#NetworkDynamics.PureStateMap"><code>PureStateMap()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          x) # abstractly
g!(out_dst,          x) # single-sided edge
g!(out_src, out_dst, x) # double-sided edge
g!(v_out,            x) # single layer vertex</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« General</a><a class="docs-footer-nextpage" href="../network_construction/">Network Construction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 17 January 2025 12:25">Friday 17 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
