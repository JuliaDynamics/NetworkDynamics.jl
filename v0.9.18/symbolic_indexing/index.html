<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Indexing · NetworkDynamics</title><meta name="title" content="Symbolic Indexing · NetworkDynamics"/><meta property="og:title" content="Symbolic Indexing · NetworkDynamics"/><meta property="twitter:title" content="Symbolic Indexing · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><a class="tocitem" href="../mathematical_model/">Mathematical Model</a></li><li><a class="tocitem" href="../network_construction/">Network Construction</a></li><li><a class="tocitem" href="../data_structure/">Data Structure</a></li><li><span class="tocitem">Features</span><ul><li class="is-active"><a class="tocitem" href>Symbolic Indexing</a><ul class="internal"><li><a class="tocitem" href="#Provide-Symbol-Names"><span>Provide Symbol Names</span></a></li><li><a class="tocitem" href="#Fundamental-Symbolic-Indices"><span>Fundamental Symbolic Indices</span></a></li><li><a class="tocitem" href="#Generate-Symbolic-Indices"><span>Generate Symbolic Indices</span></a></li><li><a class="tocitem" href="#NWState-and-NWParameter-Objects"><span><code>NWState</code> and <code>NWParameter</code> Objects</span></a></li><li><a class="tocitem" href="#Observables"><span>Observables</span></a></li><li><a class="tocitem" href="#Derived-ObservableExpressions-using-@obsex"><span>Derived <code>ObservableExpressions</code> using <code>@obsex</code></span></a></li><li><a class="tocitem" href="#Low-level-accessors-for-flat-array-indices"><span>Low-level accessors for flat array indices</span></a></li></ul></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../callbacks/">Callbacks and Events</a></li><li><a class="tocitem" href="../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../external_inputs/">External Inputs</a></li><li><a class="tocitem" href="../inspector/">Interactive Solution Inspection</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../generated/heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../generated/init_tutorial/">Initialization</a></li><li><a class="tocitem" href="../generated/cascading_failure/">Cascading Failure</a></li><li><a class="tocitem" href="../generated/gas_network/">Gas Network</a></li><li><a class="tocitem" href="../generated/stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../generated/directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Features</a></li><li class="is-active"><a href>Symbolic Indexing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Indexing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/src/symbolic_indexing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Indexing"><a class="docs-heading-anchor" href="#Symbolic-Indexing">Symbolic Indexing</a><a id="Symbolic-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Indexing" title="Permalink"></a></h1><p>Using SciML&#39;s <a href="https://github.com/SciML/SymbolicIndexingInterface.jl"><code>SymbolicIndexingInterface.jl</code></a>, <code>ND.jl</code> provides numerous methods to access and change variables and parameters.</p><details class="admonition is-details"><summary class="admonition-header">Setup code to make following examples work</summary><div class="admonition-body"><pre><code class="language-julia hljs">using NetworkDynamics
using Graphs
using OrdinaryDiffEqTsit5
using Plots</code></pre></div></details><h2 id="Provide-Symbol-Names"><a class="docs-heading-anchor" href="#Provide-Symbol-Names">Provide Symbol Names</a><a id="Provide-Symbol-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Provide-Symbol-Names" title="Permalink"></a></h2><p>When constructing component models, you can pass symbolic names using the <code>sym</code> and <code>psym</code> keywords.</p><pre><code class="language-julia hljs">function _edgef!(e, v_s, v_d, (K,), t)
    e .= K * (v_s[1] .- v_d[1])
end
edgef = EdgeModel(;g=AntiSymmetric(_edgef!), outsym=[:flow], psym=[:K=&gt;1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EdgeModel <span class="sgr1">:StaticEdgeM</span> <span class="sgr94">PureFeedForward()</span>
 ├─   0 states:  []  
 ├─ 1/1 outputs: src=[₋flow] dst=[flow]
 └─   1 param:   [K=1]</code></pre><p>Here we created a static diffusion edge with suitable variable and parameter names. Similarly, we define the diffusion vertex with symbolic names.</p><pre><code class="language-julia hljs">function _vertexf!(dv, v, esum, p, t)
    dv[1] = esum[1]
end
vertexf = VertexModel(f=_vertexf!, g=1, sym=[:storage])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:VertexM</span> <span class="sgr94">PureStateMap()</span>
 ├─ 1 state:  [storage]
 └─ 1 output: [storage]</code></pre><h2 id="Fundamental-Symbolic-Indices"><a class="docs-heading-anchor" href="#Fundamental-Symbolic-Indices">Fundamental Symbolic Indices</a><a id="Fundamental-Symbolic-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Fundamental-Symbolic-Indices" title="Permalink"></a></h2><p>The default types for this access are the types <a href="../API/#NetworkDynamics.VIndex"><code>VIndex</code></a>, <a href="../API/#NetworkDynamics.EIndex"><code>EIndex</code></a>, <a href="../API/#NetworkDynamics.VPIndex"><code>VPIndex</code></a> and <a href="../API/#NetworkDynamics.EPIndex"><code>EPIndex</code></a>. Each of those symbolic indices consists of 2 elements: a reference to the network component and a reference to the symbol within that component. As such, <code>VIndex(2, :x)</code> refers to variable with symbolic name <code>:x</code> in vertex number 2. <code>EPIndex(4, 2)</code> would refer to the <em>second</em> parameter of the edge component for the 4th edge.</p><details class="admonition is-details"><summary class="admonition-header">Setup code to make following examples work</summary><div class="admonition-body"><pre><code class="language-julia hljs">g = wheel_graph(5)
nw = Network(g, vertexf, edgef)
s = NWState(nw)
s.v[:,:storage] .= randn(5)
prob = ODEProblem(nw, uflat(s), (0,2), pflat(s))
sol = solve(prob, Tsit5())</code></pre></div></details><p>Those fundamental indices can be used in a lot of scenarios. Most importantly you can use them to</p><pre><code class="language-julia hljs">sol(sol.t; idxs=VIndex(1, :storage))   # extract timeseries out ouf solution object
plot(sol; idxs=[VIndex(1, :storage), VIndex(5,:storage)]) # plot storage of two nodes</code></pre><img src="c73db6c2.svg" alt="Example block output"/><h2 id="Generate-Symbolic-Indices"><a class="docs-heading-anchor" href="#Generate-Symbolic-Indices">Generate Symbolic Indices</a><a id="Generate-Symbolic-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-Symbolic-Indices" title="Permalink"></a></h2><p>Often, you need many individual symbolic indices. For that there are the helper methods <a href="../API/#NetworkDynamics.vidxs"><code>vidxs</code></a>, <a href="../API/#NetworkDynamics.eidxs"><code>eidxs</code></a>, <a href="../API/#NetworkDynamics.vpidxs"><code>vpidxs</code></a> and <a href="../API/#NetworkDynamics.epidxs"><code>epidxs</code></a>. With the help of those methods you can generate arrays of symbolic indices:</p><pre><code class="language-julia hljs">vidxs(nw, :, :storage) # get variable &quot;storage&quot; for all vertices</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{VIndex}:
 VIndex(1, :storage)
 VIndex(2, :storage)
 VIndex(3, :storage)
 VIndex(4, :storage)
 VIndex(5, :storage)</code></pre><pre><code class="language-julia hljs">plot(sol; idxs=vidxs(nw, :, :storage))</code></pre><img src="4b62d784.svg" alt="Example block output"/><h2 id="NWState-and-NWParameter-Objects"><a class="docs-heading-anchor" href="#NWState-and-NWParameter-Objects"><code>NWState</code> and <code>NWParameter</code> Objects</a><a id="NWState-and-NWParameter-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#NWState-and-NWParameter-Objects" title="Permalink"></a></h2><p>Internally, both state and parameters of a <code>Network</code> are represented using flat arrays. To access the state or parameters of a network, you can use the <a href="../API/#NetworkDynamics.NWState"><code>NWState</code></a> and <a href="../API/#NetworkDynamics.NWParameter"><code>NWParameter</code></a> objects.</p><pre><code class="language-julia hljs">p = NWParameter(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Parameter{Vector{Float64}} of Network (5 vertices, 8 edges)
  ├─ EPIndex(1, :K) =&gt; 1.0
  ├─ EPIndex(2, :K) =&gt; 1.0
  ├─ EPIndex(3, :K) =&gt; 1.0
  ├─ EPIndex(4, :K) =&gt; 1.0
  ├─ EPIndex(5, :K) =&gt; 1.0
  ├─ EPIndex(6, :K) =&gt; 1.0
  ├─ EPIndex(7, :K) =&gt; 1.0
  └─ EPIndex(8, :K) =&gt; 1.0</code></pre><p>creates a <code>NWParameter</code> object for the network <code>nw</code>. It essentially creates a new flat parameter array and fills it with the default parameter values define in the component. The parameters in the <code>NWParameter</code> object can be accessed using symbolic indices.</p><pre><code class="language-julia hljs">p[EPIndex(5, :K)] = 2.0 # change the parameter K of the 5th edge</code></pre><p>Similarly, you can create a <code>NWState</code> object for the network <code>nw</code> using</p><pre><code class="language-julia hljs">s = NWState(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (5 vertices, 8 edges)
  ├─ VIndex(1, :storage) =&gt; NaN
  ├─ VIndex(2, :storage) =&gt; NaN
  ├─ VIndex(3, :storage) =&gt; NaN
  ├─ VIndex(4, :storage) =&gt; NaN
  └─ VIndex(5, :storage) =&gt; NaN
 p = NWParameter([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
 t = nothing</code></pre><p>No default values were provided in the network components, so the state array is filled with <code>NaN</code> values.</p><pre><code class="language-julia hljs">s[VIndex(:, :storage)] .= randn(5) # set the (initial) storage for all vertices</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (5 vertices, 8 edges)
  ├─ VIndex(1, :storage) =&gt; 2.0675087263779477
  ├─ VIndex(2, :storage) =&gt; -0.16435261935193918
  ├─ VIndex(3, :storage) =&gt; -0.07981684069015944
  ├─ VIndex(4, :storage) =&gt; 1.547209898061456
  └─ VIndex(5, :storage) =&gt; 0.2922757551786361
 p = NWParameter([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
 t = nothing</code></pre><p>For both <code>NWState</code> and <code>NWParameter</code> objects, there is a more convenient way to access the variables and parameters.</p><pre><code class="language-julia hljs">@assert s.v[1, :storage] == s[VIndex(1, :storage)] # s.v -&gt; access vertex states
@assert s.e[1, :flow]    == s[EIndex(1, :flow)]    # s.e -&gt; access edge states
@assert s.p.e[1,:K]      == p[EPIndex(1, :K)]      # s.p -&gt; access parameters</code></pre><p>The <code>NWState</code> and <code>NWParameter</code> objects are mutable, thus changing them will also change the underlying wrapped flat arrays. You can always access the flat representations by calling <a href="../API/#NetworkDynamics.uflat"><code>uflat</code></a> and <a href="../API/#NetworkDynamics.pflat"><code>pflat</code></a>. The ordering of elements  in these flat arrays corresponds exactly to the order returned by <a href="../API/#SymbolicIndexingInterface.variable_symbols"><code>variable_symbols</code></a> and  <a href="../API/#SymbolicIndexingInterface.parameter_symbols"><code>parameter_symbols</code></a> respectively.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>NWState</code> and <code>NWParameter</code> wrappers can be constructed from various objects. Fore example, within a callback you might construct <code>p = NWParameter(integrator)</code> to then change the parameters of the network within the callback.</p></div></div><h2 id="Observables"><a class="docs-heading-anchor" href="#Observables">Observables</a><a id="Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Observables" title="Permalink"></a></h2><p>Sometimes, the &quot;states&quot; you&#39;re interested in aren&#39;t really states in the DAE sense but rather algebraic derivations from DAE states, parameters, and time – in accordance with the naming in  the <code>SciML</code> ecosystem, these values are called Observables.</p><p>A prime example of Observables are edge/vertex-outputs, such as the <code>flow</code> in the edge model defined above. It is also possible to define additional Observables manually by using the <code>obssym</code> and <code>obsf</code> keyword on the <code>EdgeModel</code>/<code>VertexModel</code> constructors. When building models using ModelingToolkit, the reduced algebraic states will be preserved as observables automatically.</p><p>Observables can be accessed like any other state, for example, the flows in the network don&#39;t show up in the state array but can be accessed in all the ways discussed above, for example</p><pre><code class="language-julia hljs">plot(sol; idxs=eidxs(nw, :, :flow))</code></pre><img src="f027f2ba.svg" alt="Example block output"/><h2 id="Derived-ObservableExpressions-using-@obsex"><a class="docs-heading-anchor" href="#Derived-ObservableExpressions-using-@obsex">Derived <code>ObservableExpressions</code> using <code>@obsex</code></a><a id="Derived-ObservableExpressions-using-@obsex-1"></a><a class="docs-heading-anchor-permalink" href="#Derived-ObservableExpressions-using-@obsex" title="Permalink"></a></h2><p>Sometimes it is useful to plot or observe simple derived quantities. For that, one can use the <a href="../API/#NetworkDynamics.@obsex"><code>@obsex</code></a> macro to define simple derived quantities.</p><p>For example, we can directly plot the storage difference with respect to storage of node 1.</p><pre><code class="language-julia hljs">plot(sol; idxs=@obsex(vidxs(nw,:,:storage) .- VIndex(1,:storage)))</code></pre><img src="edce70ed.svg" alt="Example block output"/><p>Other examples include calculating the magnitude and argument of complex values that are modeled using real and imaginary parts.</p><pre><code class="nohighlight hljs">@obsex mag = sqrt(VIndex(1, :u_r)^2 + VIndex(2, :u_i)^2)</code></pre><h2 id="Low-level-accessors-for-flat-array-indices"><a class="docs-heading-anchor" href="#Low-level-accessors-for-flat-array-indices">Low-level accessors for flat array indices</a><a id="Low-level-accessors-for-flat-array-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-accessors-for-flat-array-indices" title="Permalink"></a></h2><p>Sometimes, you want to know the indices of your states in the flat arrays. For that, you can use the low-level methods defined in <code>SymbolicIndexingInterface.jl</code>:</p><pre><code class="language-julia hljs">using NetworkDynamics: SII # SII = SymbolicIndexingInterface
idxs = SII.variable_index(nw, vidxs(1:2, :storage))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 1
 2</code></pre><pre><code class="language-julia hljs">uflat(s)[idxs] == s.v[1:2, :storage]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Analogous with parmeters:</p><pre><code class="language-julia hljs">idxs = SII.parameter_index(nw, eidxs(1:2, :K))
pflat(s)[idxs] == s.p.e[1:2, :K]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>If you need the symbols of all the states/parameters in order, you can use</p><pre><code class="language-julia hljs">SII.variable_symbols(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{NetworkDynamics.SymbolicStateIndex{Int64, Symbol}}:
 VIndex(1, :storage)
 VIndex(2, :storage)
 VIndex(3, :storage)
 VIndex(4, :storage)
 VIndex(5, :storage)</code></pre><p>and</p><pre><code class="language-julia hljs">SII.parameter_symbols(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{NetworkDynamics.SymbolicParameterIndex{Int64, Symbol}}:
 EPIndex(1, :K)
 EPIndex(2, :K)
 EPIndex(3, :K)
 EPIndex(4, :K)
 EPIndex(5, :K)
 EPIndex(6, :K)
 EPIndex(7, :K)
 EPIndex(8, :K)</code></pre><p>These functions return the symbolic indices in the exact order they appear in the flat arrays returned by <a href="../API/#NetworkDynamics.uflat"><code>uflat</code></a> and <a href="../API/#NetworkDynamics.pflat"><code>pflat</code></a>, making them essential when you need to map between flat array indices and symbolic representations.</p><p>All above examples also work on other &quot;symbolic containers&quot;, e.g. <code>SII.variable_symbols(::NWState)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structure/">« Data Structure</a><a class="docs-footer-nextpage" href="../metadata/">Metadata »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 15 April 2025 15:29">Tuesday 15 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
