var documenterSearchIndex = {"docs":
[{"location":"parameters/#parameters","page":"Parameter handling","title":"Parameter handling","text":"","category":"section"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"Let nd! be an ODEFunction returned by network_dynamics, e.g.","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"nd! = network_dynamics(vertices!, edges!, graph)","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"then the behaviour of nd! has the signature (dx, x, t, p) and its behaviour changes with the type of parameters p being passed.","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"When p is an Array, a Dict, a struct... then the entire object is passed to each VertexFunction and EdgeFunction.\nWhen p = (p_v, p_e) is a Tuple of two values, then the first value will be passed to all vertices and the second to all edges.\nIf p = (p_v_arr, p_e_arr) is a Tuple of two Arrays with lengths corresponding to the number of nodes and number of edges respectively, then the edges or nodes receive only the parameter with the corresponding index.\nIf all nodes and/or edges have no internal parameters the value nothing may be passed. Using nothing instead of dummy parameters is usually faster, since then less data are copied.\nIf you are working with delay differential equations the parameter tuple should have a third entry that specifies the delay time, p = (p_v, p_e, delay_time).","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"Another option for specifying heterogeneous parameters is to make each VertexFunction a callable struct with the parameters hardcoded as fields. This approach is used in PowerDynamics.jl. However it provides considerably less flexibility and interoperability with other packages.","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"For its greater speed and flexibility in modeling we recommend to use the tuple syntax.","category":"page"},{"location":"parameters/#Compatability-with-DiffEqFlux","page":"Parameter handling","title":"Compatability with DiffEqFlux","text":"","category":"section"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"Most of the sensitivity algorithms that DiffEqFlux makes use of assume that the parameters p are a subtype of AbstractArray. Therefore they are not compatible with the tuple syntax.TrackerAdjoint does not have these limitations but works best on out-of-place problems. Unfortunately, network_dynamics returns an ODEProblem that is in-place (mutating its inputs) leading to slow performance with Tracker.","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"However, wrapping the function in such a way that it accepts arrays of parameters that are later pasted into the tuple syntax sidesteps these issues and enables the use of adjoint methods. Depending on the use case such a wrapper might look like this:","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"function nd_wrapper!(dx, x, p, t)\n  nd!(dx, x, (p, nothing), t)\nend","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"nd_wrapper! should now work with BacksolveAdjoint and InterpolatingAdjoint. At the moment we recommend this way for combining NetworDynamics and DiffEqFlux.","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"Forward mode (ForwardDiff.jl) and source-to-source (Zygote.jl)  automatic differentiation  is not fully-supported yet. For more detailed discussion see this issue.","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"Further resources:","category":"page"},{"location":"parameters/","page":"Parameter handling","title":"Parameter handling","text":"DiffEqSensitivity algorithms","category":"page"},{"location":"accessing_edge_variables/#Accessing-internal-edge-values","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"","category":"section"},{"location":"accessing_edge_variables/","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"In the following, we will present two different ways how the edge values of an ODEFunction with StaticEdges  can be retrieved. A more extensive demonstration is available in the examples folder.","category":"page"},{"location":"accessing_edge_variables/#Accessing-edge-values-via-GetGD","page":"Accessing internal edge values","title":"Accessing edge values via GetGD","text":"","category":"section"},{"location":"accessing_edge_variables/","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"NetworkDynamics.jl includes the types GetGD and GetGS, which can be used to access to the underlying GraphData and GraphStruct objects by multiple dispatching of the generated ODEFunction. Let nd be the ODEFunction that has been formed by calling network_dynamics. To get access to the edge values at any time t, nd can be called as follows:","category":"page"},{"location":"accessing_edge_variables/","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"gd_nd = nd(x, p, t, GetGD) # exposes underlying graph data struct\ne_values = gd_nd.gdb.e_array\nnothing # hide","category":"page"},{"location":"accessing_edge_variables/","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"By adding GetGD as an argument to the call of nd, a GraphData instance at the given time, parameters and states will be returned. gdb is the internal GraphDataBuffer struct. The argument x has to be the precomputed state of the system at time t, e.g. from a solution object.","category":"page"},{"location":"accessing_edge_variables/#Accessing-edge-values-using-SavingCallback","page":"Accessing internal edge values","title":"Accessing edge values using SavingCallback","text":"","category":"section"},{"location":"accessing_edge_variables/","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"Instead of recomputing the values of the edge variables they can be saved in parallel to an integration with DiffEqCallbacks.","category":"page"},{"location":"accessing_edge_variables/","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"using DiffEqCallbacks: SavingCallback, SavedValues\n\nsaved_values = SavedValues(Float64, Vector{Float64})\nfunction saving_func(u, t, integrator)\n    edgevals = Float64[]\n    for i in 1:integrator.f.f.graph_structure.num_e\n        push!(edgevals, integrator.f.f.graph_data.gdb.e[i]...)\n    end\n    edgevals\nend\ncb = SavingCallback(saving_func, saved_values)\nsol = solve(prob, Tsit5(); callback=cb)","category":"page"},{"location":"accessing_edge_variables/","page":"Accessing internal edge values","title":"Accessing internal edge values","text":"The variables saved_values will contain the stored edge values. At the moment this method requires detailed knowledge of the internal data structures. Our plan is to simplify this in a future release.","category":"page"},{"location":"getting_started_with_DDEs/#Time-delayed-network-dynamics","page":"Delay differential equations","title":"Time-delayed network dynamics","text":"","category":"section"},{"location":"getting_started_with_DDEs/#Topics-covered-in-this-tutorial-include:","page":"Delay differential equations","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"modeling time-delays with Delay Differential Equations (DDEs)\nhandling parameters for DDEs\ntime-delayed vertex variables\ntime-delayed coupling","category":"page"},{"location":"getting_started_with_DDEs/#Delayed-network-diffusion","page":"Delay differential equations","title":"Delayed network diffusion","text":"","category":"section"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"We revisit the introductory example on Network diffusion, this time with time-delayed vertex dynamics. In this section our goal is not to model real physical phenomena but rather to learn how time-delays can be modeled in NetworkDynamics.jl.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"Let g be a graph with N nodes and adjacency matrix A. Let v = (v_1 dots v_n) be a vector of (abstract) temperatures or concentrations at each node i = 1 dots N. The dynamics of state v_i at time t are determined by its past value v_i(t-tau), where tau is a constant time lag and its difference with its neighbors with coupling strength sigma.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"beginaligned\ndot v_i(t) = - v_i(t-tau) - sigma * sum_i=1^N A_ij (v_i(t) - v_j(t))\nendaligned","category":"page"},{"location":"getting_started_with_DDEs/#Modeling-diffusion-with-NetworkDynamics.jl","page":"Delay differential equations","title":"Modeling diffusion with NetworkDynamics.jl","text":"","category":"section"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j, it will decrease along that edge.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"The coupling function is the same as in the previous example","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"function diffusionedge!(e, v_s, v_d, p, t)\n    e .= 0.1 * (v_s .- v_d)\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"However, the internal vertex dynamics are now determined by the time-delayed equation dot v_i(t) = - v_i(t-tau) and are described in the vertex function with help of the history array h_v containing the past values of the vertex variables.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"function delaydiffusionvertex!(dv, v, edges, h_v, p, t)\n    dv .= -h_v\n    sum_coupling!(dv, edges)\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"The Watts-Strogatz algorithm constructs a regular ring network with N nodes connected to k neighbors and a probability p of rewiring links.  Since p=0 no rewiring happens and g is a simple ring network.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"using Graphs\n\n### Defining a graph\n\nN = 10 # number of nodes\nk = 4  # average degree\ng = watts_strogatz(N, k, 0.0) # ring-network\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"While the EdgeFunction is constructed via StaticEdge just as before, the vertex functions is wrapped in DDEVertex to account for the time-lag in the internal dynamics. network_dynamics then returns a DDEFunction compatible with the solvers of DifferentialEquations.jl. Combining those into a DDEFunction via network_dynamics is then straightforward.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"using NetworkDynamics\n\nnd_diffusion_vertex = DDEVertex(; f=delaydiffusionvertex!, dim=1)\nnd_diffusion_edge = StaticEdge(; f=diffusionedge!, dim=1)\n\nnd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/#Simulation","page":"Delay differential equations","title":"Simulation","text":"","category":"section"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"When simulating a time-delayed system the initial conditions have to be specified on the whole interval -tau 0 . This is usually done by specifying initial conditions at t=0 and a history function h for extrapolating these values to time t= - tau. For simplicity h is often chosen constant. When solving a DDE with DifferentialEquations.jl h is later overloaded to interpolate between time-steps, for details see the docs.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"\nconst x0 = randn(N) # random initial conditions\ntspan = (0.0, 10.0) # time interval\n\n# history function keeps the initial conditions constant and is in-place to save allocations\nh(out, p, t) = (out .= x0)\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"We still have to specify the constant time-lag tau. At the moment this is only possible by using the ND-specific tuple syntax. For DDEs these tuples have to contain a third argument specifying the delay time.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"# parameters p = (vertex parameters, edge parameters, delay time)\np = (nothing, nothing, 1.0)\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"We solve the problem on the time interval 0 10 with the Tsit5() algorithm, recommended for solving non-stiff problems. The MethodOfSteps(..) translates an OrdinaryDiffEq.jl  solver into an efficient method for delay differential equations. DDEProblem addtional accepts the keyword constant_lags that can be useful in some situation, see their docs for details.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"using DelayDiffEq, Plots\n\ndde_prob = DDEProblem(nd, x0, h, tspan, p)\nsol = solve(dde_prob, MethodOfSteps(Tsit5()))\nplot(sol; vars=syms_containing(nd, \"v\"), fmt=:png)","category":"page"},{"location":"getting_started_with_DDEs/#Bonus:-Two-independent-diffusions","page":"Delay differential equations","title":"Bonus: Two independent diffusions","text":"","category":"section"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"In this extension of the first example, there are two independent diffusions on the same network with variables x and phi - hence the dimension is set to dim=2.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"nd_diffusion_vertex_2 = DDEVertex(; f=delaydiffusionvertex!, dim=2, sym=[:x, :ϕ])\nnd_diffusion_edge_2 = StaticEdge(; f=diffusionedge!, dim=2)\nnd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"The initial conditions are sampled from (squared) normal distributinos such that the first N values correspond to variable x and the values with indices from N+1 to 2N belong to variable ϕ, where x sim mathcalN(01); ϕ sim mathcalN(01)^2.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"const x0_2 = Vector{Float64}(vec([randn(N) .- 10 randn(N) .^ 2]')) # x ~ \\mathcal{N}(0,1); ϕ ~ \\mathcal{N}(0,1)^2\n\nh_2(out, p, t) = (out .= x0_2)\n\np = (nothing, nothing, 1.0) # p = (vertexparameters, edgeparameters, delaytime)\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"Now we can define the DDEProblem and solve it.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"dde_prob_2 = DDEProblem(nd_2, x0_2, h_2, tspan, p)\nsol_2 = solve(dde_prob_2, MethodOfSteps(Tsit5()));\nplot(sol_2; legend=false, fmt=:png)","category":"page"},{"location":"getting_started_with_DDEs/#Kuramoto-model-with-delay","page":"Delay differential equations","title":"Kuramoto model with delay","text":"","category":"section"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"A common modification of the Kuramoto model is to include a time-lag in the coupling function. In neuroscience such a coupling is used to account for transmission delays along synapses connecting different neurons.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"Unlike in the diffusion example, the edges depend on past values of the vertex variables . For this reason the edgefunction has the history arrays of the destination and source vertices as arguments.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"function kuramoto_delay_edge!(e, v_s, v_d, h_v_s, h_v_d, p, t)\n    e[1] = p * sin(v_s[1] - h_v_d[1])\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"The dynamics of vertices in the Kuramoto model are determined by a constant rotation frequency p. Contributions of the edges are summed up according to their destinations.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"function kuramoto_vertex!(dv, v, edges, p, t)\n    dv[1] = p\n    for e in edges\n        dv .+= e\n    end\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"In this case the vertex function does not depend on any past values and is simply constructed as an ODEVertex. Since the edges depend on the history of the vertex variables their calling signature has changed and they are handed to the delay-aware constructor StaticDelayEdge. They are called Static since don't have internal dynamical variables.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"kdedge! = StaticDelayEdge(; f=kuramoto_delay_edge!, dim=1)\nkdvertex! = ODEVertex(; f=kuramoto_vertex!, dim=1)\n\nnd! = network_dynamics(kdvertex!, kdedge!, g)\nnothing # hide","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"The remaining steps for simulating the system are the same as above.","category":"page"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"const x0_3 = randn(N) # random initial conditions\nh_3(out, p, t) = (out .= x0_3)\n# p = (vertexparameters, edgeparameters, delaytime)\nω = randn(N)\nω .-= sum(ω) / N # center at 0\np = (ω, 2.0, 1.0)\ntspan = (0.0, 10.0)\n\ndde_prob = DDEProblem(nd!, x0_3, h_3, tspan, p)\n\nsol = solve(dde_prob, MethodOfSteps(Tsit5()));\n\n### Plotting\n\nplot(sol; vars=syms_containing(nd, \"v\"), legend=false, fmt=:png)\n","category":"page"},{"location":"getting_started_with_DDEs/#Delay-differential-equations-with-algebraic-constraints","page":"Delay differential equations","title":"Delay differential equations with algebraic constraints","text":"","category":"section"},{"location":"getting_started_with_DDEs/","page":"Delay differential equations","title":"Delay differential equations","text":"The vertex dynamics may in principle contain algebraic equations in mass matrix form. For an experimental test case have a look at the last section of this example on github.","category":"page"},{"location":"Library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"Library/#Public-Interface","page":"Library","title":"Public Interface","text":"","category":"section"},{"location":"Library/","page":"Library","title":"Library","text":"The following functions are designed for public use","category":"page"},{"location":"Library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"Library/","page":"Library","title":"Library","text":"network_dynamics\nStaticVertex\nODEVertex\nDDEVertex\nStaticEdge\nODEEdge\nStaticDelayEdge\nsyms_containing\nidx_containing\nsum_coupling!","category":"page"},{"location":"Library/#NetworkDynamics.network_dynamics","page":"Library","title":"NetworkDynamics.network_dynamics","text":"network_dynamics(vertices!, edges!, g; parallel = false)\n\nAssembles the the dynamical equations of the network problem into an ODEFunction compatible with the DifferentialEquations.jl solvers. Takes as arguments an array of VertexFunctions vertices!, an array of EdgeFunctions edges! and a Graphs.jl object g. The optional argument parallel is a boolean value that denotes if the central loop should be executed in parallel with the number of threads set by the environment variable JULIA_NUM_THREADS.\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.StaticVertex","page":"Library","title":"NetworkDynamics.StaticVertex","text":"StaticVertex(; f, dim, sym)\n\nWrapper for ODEVertex with 0 mass matrix, i.e. static behaviour / algebraic constraint in mass matrix form.\n\nf  describes the local behaviour at a static node and has to respect the following calling syntax\n\nf(v, edges, p, t) -> nothing\n\nHere  v, p and t are the usual arguments, while edges is an arrays containing the edges for which the described vertex is the destination (in-edges for directed graphs).\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.ODEVertex","page":"Library","title":"NetworkDynamics.ODEVertex","text":"ODEVertex(; f, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f with the key constructor network_dynamics.\n\nf  describes the local behaviour at a dynamic node and has to respect the following calling syntax\n\nf(dv, v, edges, p, t) -> nothing\n\nHere dv, v, p and t are the usual ODE arguments, while edges is an Array containing the edges for which the vertex is the destination (in-edges for directed graphs).\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * dv = f will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.DDEVertex","page":"Library","title":"NetworkDynamics.DDEVertex","text":"DDEVertex(; f, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f with the key constructor network_dynamics.\n\nf  describes the local behaviour at a dynamic node and has to respect the following calling syntax\n\nf(dv, v, edges, h, p, t) -> nothing\n\nHere dv, v, p and t are the usual ODE arguments, while edges is an Arry of incoming edges. h is the history array for v.\n\ndim is the number of independent variables in the edge equations and\nsym is an array of symbols for these variables.\ncoupling is a Symbol describing if the EdgeFunction is intended for a directed graph (:directed) or for an undirected graph ({:undirected, :fiducial}). :directed is intended for directed graphs. :undirected is the default option and is only compatible with SimpleGraph. in this case f! should specify the coupling from a source vertex to a destination vertex.  :fiducial lets the user specify both the coupling from src to dst, as well as the coupling from dst to src and is intended for advanced users.\nmass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * de = f will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.StaticEdge","page":"Library","title":"NetworkDynamics.StaticEdge","text":"StaticEdge(; f, dim, coupling, sym)\n\nWrapper that ensures compatibility of a mutating function f with the key constructor network_dynamics.\n\nf  describes the local behaviour at a static edge and has to respect the following calling syntax\n\nf(e, v_s, v_t, p, t) -> nothing\n\nHere  e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and\nsym is an array of symbols for these variables.\ncoupling is a Symbol describing if the EdgeFunction is intended for a directed graph (:directed) or for an undirected graph ({:undirected, :symmetric, :antisymmetric, :fiducial}). :directed is intended for directed graphs. :undirected is the default option and is only compatible with SimpleGraph. in this case f! should specify the coupling from a source vertex to a destination vertex. :symmetric and :antisymmetric trigger performance optimizations, if f! has that symmetry property. :fiducial lets the user specify both the coupling from src to dst, as well as the coupling from dst to src and is intended for advanced users.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.ODEEdge","page":"Library","title":"NetworkDynamics.ODEEdge","text":"ODEEdge(; f, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f with the key constructor network_dynamics.\n\nf  describes the local behaviour at a dynamic edge and has to respect the following calling syntax\n\nf(de, e, v_s, v_t, p, t) -> nothing\n\nHere  de, e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and sym is an array of symbols for these variables. For more details see the documentation. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * de = f will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.StaticDelayEdge","page":"Library","title":"NetworkDynamics.StaticDelayEdge","text":"StaticDilayEdge(; f, dim, coupling, sym)\n\nLike a static edge but with extra arguments for the history of the source and destination vertices. This is NOT a DDEEdge.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.syms_containing","page":"Library","title":"NetworkDynamics.syms_containing","text":"syms_containing(nd, expr)\n\nFind all symbols present in a network_dynamics that contain the string, regex or symbol expr.\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.idx_containing","page":"Library","title":"NetworkDynamics.idx_containing","text":"idx_containing(nd, expr)\n\nFind all indices of variables with symbols containing the string, regex or symbol expr\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.sum_coupling!","page":"Library","title":"NetworkDynamics.sum_coupling!","text":"sum_coupling!(e_sum, dst_edges)\n\nA small utility function for writing diffusion dynamics. It provides the sum of all incoming edges.\n\n\n\n\n\n","category":"function"},{"location":"SDEVertex/#SDE-Tutorial","page":"Stochastic differential equations","title":"SDE Tutorial","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"An IJulia notebook corresponding to this tutorial will be available on GitHub soon.","category":"page"},{"location":"SDEVertex/#Topics-covered-in-this-tutorial-include:","page":"Stochastic differential equations","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"the swing equation\nfixpoint search of ODE systems\nconstructing an SDE problem with NetworkDynamics.jl","category":"page"},{"location":"SDEVertex/#Example:-Fluctuations-in-Power-Grids","page":"Stochastic differential equations","title":"Example: Fluctuations in Power Grids","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"This tutorial explains the use of stochastic differential equations (SDE's) in NetworkDynamics.jl. As an example system we will simulate fluctuations in a simple power grid model.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"The phase and frequency dynamics in power grids can be modeled by the swing equation. In the complex systems community this is also known as the Kuramoto model with inertia.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"beginaligned\ndot theta_i = omega_i \nM_i dot omega_i = P_i(t) - D_i omega_i - sum_i=1^N K_ij sin(theta_i - theta_j)\nendaligned","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Here, M_i and D_i are inertia and damping parameters, K_ij is the power capacitiy of the line and P_i(t) is the power infeed at the node. We assume that this power can be separated into a constant power setpoint P^circ_i and a stochastic fluctuation.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"beginaligned\nP_i(t) = P^circ_i + sigma_i cdot xi_i(t)\nendaligned","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"In this tutorial we assume the fluctuations xi_i(t) to be white Gaussian noise. Separating the deterministic and stochastic part, we can write this problem as a stochastic differential equation.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"beginaligned\ndomega_i = leftP_i - D_i omega_i - sum_i=1^N K_ij sin(theta_i - theta_j)right dt + sigma_i dW_i\nendaligned","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Here, dW_i = xi_i dt is the infinitesimal increment of the Wiener process. Problems of this type can be numerically solved in Julia as described in the SDE Tutorial of DifferentialEquations.","category":"page"},{"location":"SDEVertex/#Implementing-the-Swing-Equation","page":"Stochastic differential equations","title":"Implementing the Swing Equation","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"First we will implement the node and edge functions for the deterministic case without the fluctuations. We assume the inertia and damping parameters to be M_i = 10 and D_i = 01.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"function swing_equation!(dv, v, edges, P, t)\n    dv[1] = v[2]\n    dv[2] = P - 0.1 * v[2]\n    for e in edges\n        dv[2] += e[1]\n    end\nend\n\nfunction powerflow!(e, v_s, v_d, K, t)\n    e[1] = K * sin(v_s[1] - v_d[1])\nend\nnothing # hide","category":"page"},{"location":"SDEVertex/#Contructing-the-Deterministic-Dynamics","page":"Stochastic differential equations","title":"Contructing the Deterministic Dynamics","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"For the graph structure we will use a simple 4 node ring network.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"using Graphs\ng = watts_strogatz(4, 2, 0.0)\nnothing # hide","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Then we can construct the ODEFunction of the deterministic system by using network_dynamics().","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"using NetworkDynamics\n\nswing_vertex = ODEVertex(; f=swing_equation!, dim=2, sym=[:θ, :ω])\npowerflow_edge = StaticEdge(; f=powerflow!, dim=1)\n\nnd = network_dynamics(swing_vertex, powerflow_edge, g)\nnothing # hide","category":"page"},{"location":"SDEVertex/#Fixpoint-Search","page":"Stochastic differential equations","title":"Fixpoint Search","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Now we need to define the dynamic parameters of vertices and edges. For simplicity we assume homogeneous capacities on the lines. For the nodes we assume half of them to be net producers (P = 10) and half of them to be net consumers (P = -10) of power.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"K = 6.0\nP = [1.0, -1.0, 1.0, -1.0]\np = (P, K)\nnothing # hide","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"We want to simulate fluctuations around an equilibrium state of our model system. Therefore, we need to find a fixpoint of the determinitic system which can be done by using the utility function find_fixpoint(). As an initial guess we take all variables equal to zero.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"u0 = find_fixpoint(nd, p, zeros(8))\n\nusing StochasticDiffEq, OrdinaryDiffEq\node_prob = ODEProblem(nd, u0, (0.0, 500.0), p)\node_sol = solve(ode_prob, Tsit5())\n\nusing Plots, LaTeXStrings\nplot(ode_sol; vars=syms_containing(nd, \"ω\"), ylims=(-1.0, 1.0), ylabel=L\"\\omega\", legend=false, fmt=:png)","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"We see that this is in fact a fixpoint solution. We will later use this as an initial condition for the numerical integration of the SDE system.","category":"page"},{"location":"SDEVertex/#Adding-a-Stochastic-Layer","page":"Stochastic differential equations","title":"Adding a Stochastic Layer","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"For adding the stochastic part of the dynamics we have to define a second graph layer. In our example, the fluctuations at different nodes are independent of each other. Therefore, we define a second graph with the same number of vertices but without any edges.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"h = SimpleGraph(4, 0)\nnothing # hide","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"The dynamics at the nodes has to have the same dimension as in the deterministic case. In our example we only have fluctuations in the second variable.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"function fluctuation!(dx, x, edges, p, t)\n    dx[1] = 0.0\n    dx[2] = 0.05\nend\nnothing # hide","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Now we can construct the dynamics of the second layer by using network_dynamics(). Since the graph structure of the stochastic layer has no edges we can take the edge function of the deterministic case as a placeholder.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"fluctuation_vertex = ODEVertex(; f=fluctuation!, dim=2)\nnd_noise = network_dynamics(fluctuation_vertex, powerflow_edge, h)\nnothing # hide","category":"page"},{"location":"SDEVertex/#Simulating-the-SDE","page":"Stochastic differential equations","title":"Simulating the SDE","text":"","category":"section"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"Finally, we can create an SDEProblem and solve it with DifferentialEquations.","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"sde_prob = SDEProblem(nd, nd_noise, u0, (0.0, 500.0), p)\nsde_sol = solve(sde_prob, SOSRA())\nplot(sde_sol; vars=syms_containing(nd, \"ω\"), ylims=(-1.0, 1.0), ylabel=L\"\\omega\", legend=false, fmt=:png)","category":"page"},{"location":"SDEVertex/","page":"Stochastic differential equations","title":"Stochastic differential equations","text":"More details on SDE problems, e.g. how to include correlations or how to define an EnsembleProblem, can be found in the documentation of DifferentialEquations.","category":"page"},{"location":"getting_started_with_network_dynamics/#getting_started","page":"Getting started","title":"Network diffusion","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"This introductory example explains the use of the basic types and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network. A corresponding IJulia notebook is available on GitHub.","category":"page"},{"location":"getting_started_with_network_dynamics/#Theoretical-background","page":"Getting started","title":"Theoretical background","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Diffusion processes are relevant for phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed heat, charge or concentration. In such system the local temperature (or concentration) changes according to its difference with its neighborhood, i.e. the temperature gradient.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Let g be a graph with N nodes and adjacency matrix A. Let v = (v_1 dots v_n) be a vector of (abstract) temperatures or concentrations at each node i = 1 dots N. Then the rate of change of state v_i is described by its difference with its neighbors and we obtain the following ordinary differential equation","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v_i = sum_j=1^N A_ji (v_j - v_i)","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.","category":"page"},{"location":"getting_started_with_network_dynamics/#Modeling-diffusion-in-NetworkDynamics.jl","page":"Getting started","title":"Modeling diffusion in NetworkDynamics.jl","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"From the above considerations we see that in this model the nodes do not have any internal dynamics - if a node was disconnected from the rest of the network its state would never change, since then A_ji = 0  forall j and hence dot v_i = 0. This means that the evolution of a node depends only on the interaction with its neighbors. In NetworkDynamics.jl, interactions with neighbors are described by equations for the edges.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"function diffusionedge!(e, v_s, v_d, p, t)\n    # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .\n    e .= v_s - v_d\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The function diffusionedge! takes as inputs the current state of the edge e, its source vertex v_s, its destination vertex v_d, a vector of parameters p and the time t. In order to comply with the syntax of NetworkDynamics.jl we always have to define functions for static edges with exactly these arguments, even though we do not need p and t for the diffusion example.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"diffusionedge! is called a mutating function, since it modifies (or mutates) one of its inputs, namely the edge state e. As a convention in Julia names of mutating functions end with an !. The use of mutating functions reduces allocations and thereby speeds up computations. After the function call the edge's value e equals the difference between its source and its destination vertex (i.e. the discrete gradient along that edge).","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The contributions of the different edges are then summed up in each vertex.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"function diffusionvertex!(dv, v, edges, p, t)\n    # usually v, edges are arrays, hence we use the broadcasting operator .\n    dv .= 0.0\n    for e in edges\n        dv .+= e\n    end\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"Just like above the input arguments v, edges, p, t are mandatory for the syntax of vertex functions. The additional input dv corresponding to the derivative of the vertex' state is mandatory for vertices described by ordinary differential equations.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"For undirected graphs, the edgefunction! specifies the coupling from a source- to a destination vertex. The contributions of the connected edges are added to the destination of each edge, as defined in the diffusionvertex! function in the for loop.","category":"page"},{"location":"getting_started_with_network_dynamics/#Constructing-the-network","page":"Getting started","title":"Constructing the network","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"With the preliminaries out of the way, it only takes a few steps to assemble the network dynamics.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"using Graphs\n\nN = 20 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The Barabási–Albert model generates a scale-free random graph.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"using NetworkDynamics\n\nnd_diffusion_vertex = ODEVertex(; f=diffusionvertex!, dim=1)\nnd_diffusion_edge = StaticEdge(; f=diffusionedge!, dim=1)\n\nnd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)\n\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"ODEVertex and StaticEdge are functions wrappers that equip the functions we defined above with additional information like dim and return objects of type VertexFunction and EdgeFunction. Then the key constructor network_dynamics combines them with the topological information contained in the graph g and returns an ODEFunction compatible with the solvers of DifferentialEquations.jl. The keyword dim specifies the number of variables at each edge or node.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"using OrdinaryDiffEq\n\nx0 = randn(N) # random initial conditions\node_prob = ODEProblem(nd, x0, (0.0, 4.0))\nsol = solve(ode_prob, Tsit5());\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"We are solving the diffusion problem on the time interval 0 4 with the Tsit5() algorithm, which is recommended  by the authors of DifferentialEquations.jl for most non-stiff problems.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"using Plots\nplot(sol; vars=syms_containing(nd, \"v\"), fmt=:png)","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The plotting is straightforward. The vars keyword allows us to pass a list of indices or symbols specifiying the variables we want to plot. Symbols can be thought of as names given to the interal variables of an ODEFunction, much like the variables x or phi in mathematical notation. The default symbol for vertex variables is v, however we are free to specify other symbols by passing them to the ODEVertex constructor.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"syms_containing is a helper function that returns all symbols of an ODEProblem containg a specific string (or symbol).","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"To illustrate a very simple multi-dimensional case, in the following we simulate two independent diffusions on an identical network. The first uses the symbol x and is started with initial conditions drawn from the standard normal distribution N(01), the second uses the symbol ϕ with squared standard normal inital conditions.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The symbols have to be passed with the keyword sym to ODEVertex.","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"N = 10 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\n# We will have two independent diffusions on the network, hence dim = 2\nnd_diffusion_vertex_2 = ODEVertex(; f=diffusionvertex!, dim=2, sym=[:x, :ϕ])\nnd_diffusion_edge_2 = StaticEdge(; f=diffusionedge!, dim=2)\nnd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)\n\nx0_2 = vec(transpose([randn(N) .^ 2 randn(N)])) # x ~ N(0,1)^2; ϕ ~ N(0,1)\node_prob_2 = ODEProblem(nd_2, x0_2, (0.0, 3.0))\nsol_2 = solve(ode_prob_2, Tsit5());\n\n\n# Try plotting the variables ϕ_i yourself. [To write ϕ type \\phi and press TAB]\nplot(sol_2; vars=syms_containing(nd_2, \"x\"), fmt=:png)","category":"page"},{"location":"getting_started_with_network_dynamics/#Appendix:-The-network-Laplacian-L","page":"Getting started","title":"Appendix: The network Laplacian L","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"The diffusion equation on a network can be rewritten as","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v_i  = sum_j=1^N A_ji v_j - d_i v_i =  e_i^T A v - d_i v_i      ","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"where d_i is the degree of node i and e_i^T is the i-th standard basis vector. Introducing the diagonal matrix D that has the degree of node i in its i-th row and the Laplacian matrix L = D - A we arrive at","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v = e_i^T(A - D) v","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"and finally","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"dot v = - L v","category":"page"},{"location":"getting_started_with_network_dynamics/","page":"Getting started","title":"Getting started","text":"This is a linear system of ODEs and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of L. For this reason L is an important construction in network science.","category":"page"},{"location":"Multithreading/#Multi-Threading","page":"Multi-Threading","title":"Multi-Threading","text":"","category":"section"},{"location":"Multithreading/","page":"Multi-Threading","title":"Multi-Threading","text":"Since version 0.3.0 multi-threading via the Threads.@threads macro is possible. This allows julia to integrate different nodes and edges in different threads, and can lead to significant performance gains on parallel architectures. To enable multi-threading call network_dynamics with the keyword argument parallel=true.","category":"page"},{"location":"Multithreading/","page":"Multi-Threading","title":"Multi-Threading","text":"network_dynamics(vertices!, edges!, graph; parallel=true)","category":"page"},{"location":"Multithreading/","page":"Multi-Threading","title":"Multi-Threading","text":"In order for this to take effect, multiple threads have to be available. This is achieved by setting the environment variable JULIA_NUM_THREADS before starting Julia.  To start Julia from a bash shell and with 4 threads use:","category":"page"},{"location":"Multithreading/","page":"Multi-Threading","title":"Multi-Threading","text":"$ env JULIA_NUM_THREADS=4 julia","category":"page"},{"location":"Multithreading/","page":"Multi-Threading","title":"Multi-Threading","text":"If you are using Juno for the Atom text editor JULIA_NUM_THREADS is set to the number of physical cores of your processor by default. This is also the number of threads we recommend to use.","category":"page"},{"location":"Multithreading/","page":"Multi-Threading","title":"Multi-Threading","text":"note: Note\nThe thread handling causes an overhead in the order of 20 μs per call to the ODE function which might impair performance on small networks (<100 nodes) or on single core machines. In theses cases network_dynamics can be called without any additional arguments, since parallel defaults to false.","category":"page"},{"location":"Multithreading/","page":"Multi-Threading","title":"Multi-Threading","text":"For more information on setting environment varibales see the Julia documentation.","category":"page"},{"location":"heterogeneous_system/#Modeling-a-heterogeneous-system","page":"Heterogeneous systems","title":"Modeling a heterogeneous system","text":"","category":"section"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"One of the main purposes of NetworkDynamics.jl is to facilitate modeling coupled systems with heterogenities. This means that components can differ in their parameters as well as in their dynamics.","category":"page"},{"location":"heterogeneous_system/#Heterogenous-parameters","page":"Heterogeneous systems","title":"Heterogenous parameters","text":"","category":"section"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"We start by setting up a simple system of Kuramoto oscillators.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"using NetworkDynamics, OrdinaryDiffEq, Plots, Graphs\n\n\nN = 8\ng = watts_strogatz(N, 2, 0) # ring network\n\nfunction kuramoto_edge!(e, θ_s, θ_d, K, t)\n    e[1] = K * sin(θ_s[1] - θ_d[1])\nend\n\nfunction kuramoto_vertex!(dθ, θ, edges, ω, t)\n    dθ[1] = ω\n    sum_coupling!(dθ, edges)\nend\n\nvertex! = ODEVertex(; f=kuramoto_vertex!, dim=1, sym=[:θ])\nedge!   = StaticEdge(; f=kuramoto_edge!, dim=1)\nnd! = network_dynamics(vertex!, edge!, g);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Introducing heterogeneous parameters is as easy as defining an array. Here the vertex parameters are heterogeneous, while the edges share the same coupling parameter K.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"ω = collect(1:N) ./ N\nω .-= sum(ω) / N\nK = 3.0\np = (ω, K); # p[1] vertex parameters, p[2] edge parameters\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Integrate and plot","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"x0 = collect(1:N) ./ N\nx0 .-= sum(x0) ./ N\ntspan = (0.0, 10.0)\nprob = ODEProblem(nd!, x0, tspan, p)\nsol = solve(prob, Tsit5())\nplot(sol; ylabel=\"θ\", fmt=:png)","category":"page"},{"location":"heterogeneous_system/#Heterogeneous-dynamics","page":"Heterogeneous systems","title":"Heterogeneous dynamics","text":"","category":"section"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Two paradigmatic modifications of the node model above are static nodes and nodes with inertia. A static node has no internal dynamics and instead fixes the variable at a constant value. A Kuramoto model with inertia consists of two internal variables leading to more complicated (and for many applications more realistic) local dynamics.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"static! = StaticVertex(; f=(θ, edges, c, t) -> θ .= c, dim=1, sym=[:θ])\n\n\nfunction kuramoto_inertia!(dv, v, edges, P, t)\n    dv[1] = v[2]\n    dv[2] = P - 1.0 * v[2]\n    for e in edges\n        dv[2] += e[1]\n    end\nend\n\ninertia! = ODEVertex(; f=kuramoto_inertia!, dim=2, sym=[:θ, :ω]);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Since now we model a system with heterogeneous node dynamics we can no longer straightforwardly pass a single VertexFunction to network_dynamics but instead have to hand over an Array.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"vertex_array    = Array{VertexFunction}([vertex! for i in 1:N])\nvertex_array[1] = static!\nvertex_array[5] = inertia! # index should correspond to the node's index in the graph\nnd_hetero! = network_dynamics(vertex_array, edge!, g);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Now we have to take a bit more care with defining initial conditions and parameters. For the static! node the initial condition has to match its parameter. For simplicity we use the same parameters as above.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"x0[1] = ω[1];\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"The node with inertia is two-dimensional, hence we need to specify two initial conditions. For the first dimension we keep the initial conditions from above and insert! another one into x0 at the correct index.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"inertia_ic_2 = 5\ninsert!(x0, 6, inertia_ic_2);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"x0[1:4] holds ic for nodes 1 to 4, x0[5:6] holds the two initial conditions for node 5, x0[7:9] holds initial conditions for nodes 6 to 8.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"prob_hetero = ODEProblem(nd_hetero!, x0, tspan, p)\nsol_hetero = solve(prob_hetero, Rodas4());\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"For clarity we plot only the variables referring to the oscillator's angle θ and color them according to their type.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"membership = ones(Int64, N)\nmembership[1] = 2\nmembership[5] = 3\nnodecolor = [colorant\"lightseagreen\", colorant\"orange\", colorant\"darkred\"];\nnodefillc = reshape(nodecolor[membership], 1, N);\n\nvars = syms_containing(nd_hetero!, :θ);\nplot(sol_hetero; ylabel=\"θ\", vars=vars, lc=nodefillc, fmt=:png)","category":"page"},{"location":"heterogeneous_system/#Components-with-algebraic-constraints","page":"Heterogeneous systems","title":"Components with algebraic constraints","text":"","category":"section"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"If one of the network components contains an algebraic as well as dynamical component, then there is the option to supply a mass matrix for the given component. In general this will look as follows:","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"function edgeA!(de, e, v_s, v_d, p, t)\n    de[1] = f(e, v_s, v_d, p, t) # dynamic variable\n    e[2]  = g(e, v_s, v_d, p, t) # static variable\nend\n\nM = zeros(2, 2)\nM[1, 1] = 1\n\nnd_edgeA! = ODEEdge(; f=edgeA!, dim=2, coupling=:undirected, mass_matrix=M);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"This handles the second equations as 0 = M[2,2] * de[2] = g(e, v_s, v_d, p, t) - e[2].","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"See the example kuramoto_plasticity.jl and the discussion on github for more details.","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"","category":"page"},{"location":"heterogeneous_system/","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"directed_and_weighted_graphs/#Neurodynamic-model-of-synchronization-in-the-human-brain","page":"Directed and weighted graphs","title":"Neurodynamic model of synchronization in the human brain","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#Topics-covered-in-this-tutorial-include:","page":"Directed and weighted graphs","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"constructing a directed, weighted graph from data\nsome useful macros\nparameter handling\nstiff equations","category":"page"},{"location":"directed_and_weighted_graphs/#The-FitzHugh-Nagumo-model","page":"Directed and weighted graphs","title":"The FitzHugh-Nagumo model","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Dynamics of spiking neurons have been described in a simplified manner by the FitzHugh-Nagumo model.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u   =  u - fracu^33 - v \ndot v  =  u + a\nendaligned","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Here u is a fast, excitatory variable corresponding to the membrane potential and v is a slower, inhibitory varibale. varepsilon is a parameter separating these time-scales, and a is a control parameter.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In simplified models of the brain, such relaxation oscillators may be used to model individual neurons, clusters of neurons or even larger areas in the brain. The FitzHugh-Nagumo model has been widely used for studying synchronization in neuronal activity, which in turn has been connected to physiological phenomena such as epileptic seizures.","category":"page"},{"location":"directed_and_weighted_graphs/#Coupling-relaxation-oscillators","page":"Directed and weighted graphs","title":"Coupling relaxation oscillators","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"While different coupling schemes for FitzHugh-Nagumo oscillators have been proposed, in this tutorial we focus on coupling of the excitatory variables via electrical gap junctions, as described by the following system of equations.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u_i  =  u_i - fracu_i^33 - v_i - sigma sum_j=1^N G_ij(u_i - u_j) \ndot v_i  =   u_i + a\nendaligned","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"This is a simple diffusive coupling mediated by the difference between activation potentials in pairs of neurons. A similar coupling term was introduced in the \"getting started\" tutorial.","category":"page"},{"location":"directed_and_weighted_graphs/#The-network-topology-a-brain-atlas","page":"Directed and weighted graphs","title":"The network topology - a brain atlas","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In the following we will use a directed and weigthed network encoding the strength and directionality of coupling between 90 different areas of the brain [Nathalie Tzourio-Mazoyer et al., 2002, Neuroimage].","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The network weight matrix is given as a text file containing 90 lines with 90 numbers representing the coupling strength and separated by commas ,. The data can be conveniently read into a matrix with the DelimitedFiles module.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using DelimitedFiles\n# adjust the load path for your filesystem!\nG = readdlm(joinpath(@__DIR__, \"../../examples/Norm_G_DTI.txt\"), ',', Float64, '\\n')\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The data structure for directed, weighted graphs is provided by the package SimpleWeightedGraphs.jl which is based on Graphs.jl.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using SimpleWeightedGraphs, Graphs\n\n# First we construct a weighted, directed graph\ng_weighted = SimpleWeightedDiGraph(G)\n\n# For later use we extract the edge.weight attributes\n# . is the broadcasting operator and gets the attribute :weight for every edge\nedge_weights = getfield.(collect(edges(g_weighted)), :weight)\n\n# we promote the g_weighted graph as a directed graph (weights of the edges are included in parameters)\ng_directed = SimpleDiGraph(g_weighted)\n\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#Setting-up-the-ODEProblem","page":"Directed and weighted graphs","title":"Setting up the ODEProblem","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Defining VertexFunction and EdgeFunction is similar to the example before. The macro Base.@propagate_inbounds tells the compiler to inline the function and propagate the inbounds context. For more details see the julia documentation.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using NetworkDynamics\n\nBase.@propagate_inbounds function fhn_electrical_vertex!(dv, v, edges, p, t)\n    dv[1] = v[1] - v[1]^3 / 3 - v[2]\n    dv[2] = (v[1] - a) * ϵ\n    for e in edges\n        dv[1] += e[1]\n    end\n    nothing\nend\n\nBase.@propagate_inbounds function electrical_edge!(e, v_s, v_d, p, t)\n    e[1] = p * (v_s[1] - v_d[1]) # * σ\n    nothing\nend\n\nodeelevertex = ODEVertex(; f=fhn_electrical_vertex!, dim=2, sym=[:u, :v]);\nelectricaledge = StaticEdge(; f=electrical_edge!, dim=1, coupling=:directed)\n\nfhn_network! = network_dynamics(odeelevertex, electricaledge, g_directed)\n\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Since this system is a directed one with thus directed edges, the keyword argument coupling is used to set the coupling of the edges to :directed.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Note that the multiplication with the coupling strength sigma has been commented out. Since sigma is the same for every edge we can absorb this multiplication into the edge weight parameter p. Since our network has almost 8000 edges, this saves 8000 multiplications at every function call and leads to an 8-fold increase in performance.","category":"page"},{"location":"directed_and_weighted_graphs/#Parameter-handling","page":"Directed and weighted graphs","title":"Parameter handling","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"# Defining global parameters\n\nN = 90         # number of nodes\nconst ϵ = 0.05 # global variables that are accessed several times should be declared `const`\nconst a = 0.5\nconst σ = 0.5\n\n# Tuple of parameters for nodes and edges\n\np = (nothing, σ * edge_weights)\n\n# Initial conditions\n\nx0 = randn(2N) * 5\n\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The behaviour of network_dynamics changes with the type of parameters p being passed. When p is an Array, the entire Array will be passed to each VertexFunction and EdgeFunction. When p is a tuple of two Arrays with lengths corresponding to the number of nodes and number of edges respectively, then network_dynamics passes only the edge or node parameters with the index of the edge or node. When there are no parameters for either edges or nodes the value nothing may be used.","category":"page"},{"location":"directed_and_weighted_graphs/#Solving-the-system","page":"Directed and weighted graphs","title":"Solving the system","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Now we are ready to create an ODEProblem. Since for some choices of parameters the FitzHugh-Nagumo model is stiff (i.e. numerically unstable), we use a solver with automated stiffness detection. Such a solver switches to a more stable solver only when the solution enters a region of phase space where the problem is numerically unstable. In this case we use Tsit5 and switch to TRBDF2 when necessary. AutoTsit5 is the switching version of the Tsit5 algorithm.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using OrdinaryDiffEq\n\ntspan = (0.0, 200.0)\nprob  = ODEProblem(fhn_network!, x0, tspan, p)\nsol = solve(prob, AutoTsit5(TRBDF2()));\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#Plotting","page":"Directed and weighted graphs","title":"Plotting","text":"","category":"section"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The plot of the excitatory variables shows that they synchronize for this choice of parameters.","category":"page"},{"location":"directed_and_weighted_graphs/","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using Plots\n\nplot(sol; vars=idx_containing(fhn_network!, :u), legend=false, ylim=(-5, 5), fmt=:png)","category":"page"},{"location":"#NetworkDynamics","page":"General","title":"NetworkDynamics","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"A package for working with dynamical systems on complex networks. NetworkDynamics.jl provides an interface between Graphs.jl and DifferentialEquations.jl. It allows to define several types of dynamic and static nodes and edges and to link them up in order to create complex network dynamics.","category":"page"},{"location":"","page":"General","title":"General","text":"The behavior of a node or an edge can be described by algebraic equations, by differential algebraic equation (DAEs) in mass matrix form, by ordinary differential equations (ODE) or by delay differential equations(DDE). Stochastic ordinary differential equations (SDE) can e.g. be implemented as a two-layer network. For detail see the tutorials section.","category":"page"},{"location":"#Installation","page":"General","title":"Installation","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Installation is straightforward with Julia's package manager.","category":"page"},{"location":"","page":"General","title":"General","text":"(v1.5) pkg> add NetworkDynamics","category":"page"},{"location":"#PowerDynamics","page":"General","title":"PowerDynamics","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"PowerDynamics.jl is an open-source framework for dynamic power grid modeling and analysis build on top of NetworkDynamics.jl.","category":"page"},{"location":"#Overview","page":"General","title":"Overview","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"The central construction is the function network_dynamics that receives functions describing the local dynamics on the edges and nodes of a graph g as inputs, and returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"","page":"General","title":"General","text":"nd = network_dynamics(vertices!,  edges!, g)\nnd(dx, x, p, t)","category":"page"},{"location":"BasicConstructors/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The key  network_dynamics assembles the dynamics of the whole network from functions for the single vertices and edges of the graph g. These functions have to be wrapped in types VertexFunction and EdgeFunction which store additional information on dimension and coupling type. Both have several subtypes that account for the different classes of equations that may represent the local dynamics. At the moment, algebraic (static) equations, ordinary differential equations (ODEs) and delay differential equations (DDEs) are supported:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"# VertexFunctions\nStaticVertex(vertexfunction!, dimension, symbol)\nODEVertex(vertexfunction!, dimension, mass_matrix, symbol)\nDDEVertex(vertexfunction!, dimension, mass_matrix, symbol)\n\n# EdgeFunctions\nStaticEdge(edgefunction!, dimension, coupling, symbol)\nODEEdge(edgefunction!, dimension, mass_matrix, coupling, symbol)\nStaticDelayEdge(edgefunction!, dimension, mass_matrix, coupling, symbol)","category":"page"},{"location":"BasicConstructors/#VertexFunctions","page":"Functions","title":"VertexFunctions","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Given a set of (algebraic or differential) equations describing a node or an edge the first step is to turn them into a mutating function vertexfunction!. Depending on the class of the function vertexfunction!, the constructors StaticVertex, ODEVertex or DDEVertex are called in order to turn vertexfunction! into a VertexFunction object compatible with network_dynamics.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Since in general the state of a vertex depends on the vertex value itself as well as on the in- and outgoing edges, the function vertexfunction! has to respect one of the following calling syntaxes.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"# For static nodes\nfunction vertexfunction!(v, edges, p, t) end\n# For dynamic nodes\nfunction vertexfunction!(dv, v, edges, p, t) end\n# For delay nodes\nfunction vertexfunction!(dv, v, edges, h_v, p, t) end","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Here dv, v, p, and t are the usual ODE arguments, while edges is an array containing the edges for which the vertex is the destination (corresponding to incoming edges for directed graphs). In the delay case, the array h_v denotes the vertex history. The typical case of diffusive coupling on a directed graph could be described as","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"function vertex!(dv, v, edges, p, t)\n    dv .= 0.0\n    for e in edges\n        dv .+= e\n    end\n    nothing\nend","category":"page"},{"location":"BasicConstructors/#[StaticVertex](@ref)","page":"Functions","title":"StaticVertex","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"If a vertex is described by an algebraic equation  vertexfunction!(v, edges, p, t), i.e. dv = 0 the VertexFunction is constructed as","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"StaticVertex(vertexfunction!, dim, sym)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Here, dim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. For example, if a node models a constant input I = p, then dim = 1 and sym = [:I]. For more details on the use of symbols, check out the Getting started tutorial and the Julia documentation. The use of symbols makes it easier to select variables of interest from the solution object.","category":"page"},{"location":"BasicConstructors/#[ODEVertex](@ref)","page":"Functions","title":"ODEVertex","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"If a vertex has local dynamics vertexfunction!(dv, v, edges, p, t) described by an ODE, the VertexFunction is contructed as","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"ODEVertex(vertexfunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"As above, dim is the number of independent variables in the vertex equations and sym corresponds to the symbols of these variables.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given, the local system M * dv = vertexfunction! will be solved. network_dynamics assembles all local mass matrices into one global mass matrix that can be passed to a differential equation solver like Rodas4.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"One may also call ODEVertex with keyword arguments, omitting optional arguments:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"ODEVertex(; f=vertexfunction!, dim=dim)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The function then defaults to using the identity as mass matrix and [:v for i in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#[DDEVertex](@ref)","page":"Functions","title":"DDEVertex","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"If a vertex has local dynamics described by a delay differential equation (DDE) the local dynamics need to have the signature vertexfunction!(dv, v, edges, h_v, p, t), where h_v are the history values of v. Then the VertexFunction is constructed as","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"DDEVertex(vertexfunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"As before, dim is the number of independent variables in the vertex function and sym describes the symbols of the variables. The mass matrix is optional and defaults to the identity matrix I.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"As above, the DDEVertex function can also be called without the optional arguments:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"DDEVertex(; f=vertexfunction!, dim=dim)","category":"page"},{"location":"BasicConstructors/#EdgeFunctions","page":"Functions","title":"EdgeFunctions","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Similar to the case of vertices, an edge is described by mutating function edgefunction!. At the moment the constructors StaticEdge, ODEEdge, and StaticDelayEdge are available. edgefunction! has to respect one of the following syntaxes:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"# For static edges\nfunction edgefunction!(e, v_s, v_d, p, t) end\n# For dynamics edges\nfunction edgefunction!(de, e, v_s, v_d, p, t) end\n# For static delay edges\nfunction edgefunction!(e, v_s, v_d, h_v_s, h_v_d, p, t) end","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Just like above, de, e, p and t are the usual ODE arguments, while v_s and v_d are the source and destination vertices respectively and h_v_s and h_v_d the corresponding history arrays.","category":"page"},{"location":"BasicConstructors/#[StaticEdge](@ref)","page":"Functions","title":"StaticEdge","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Static here means, that the edge value described by edgefunction! only depends on the values of the vertices the edge connects to and that no derivative of the edge's internal state is involved. One very simple and natural example is a diffusive edge:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"edgefunction! = (e, v_s, v_d, p, t) -> e .= v_s .- v_d","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"In this case the EdgeFunction is constructed by","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"StaticEdge(edgefunction!, dim, coupling, sym)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The keywords are the same as for the vertices, except from the additional keyword coupling, which describes if the EdgeFunction is intended for a (:directed) or for an undirected graph ({:undirected, :symmetric, :antisymmetric, :fiducial}). :directed is intended for directed graphs. :undirected is the default option and is only compatible with SimpleGraph. In this case the edgefunction! should specify the coupling from a source vertex to a destination vertex. :symmetric and :antisymmetric trigger performance optimizations, if edgefunction! has that symmetry property. :fiducial lets the user specify both the coupling from source to destination, as well as the coupling from destination to source and is intended for advanced users.","category":"page"},{"location":"BasicConstructors/#[ODEEdge](@ref)","page":"Functions","title":"ODEEdge","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"For problems where edgefunction! describes the differential of an edge value, we use the ODEEdge function. An example for such a system is given by:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"edgefunction! = (de, e, v_s, v_d, p, t) -> de .= 1000 * (v_s .- v_d .- e)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The EdgeFunction object is constructed as","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"ODEEdge(edgefunction!, dim, coupling, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The keywords are the same as above for the StaticEdge. For ODEEdge the same simplified construction rules apply when keyword arguments are used, except that the coupling type has to be specified explicitly to avoid ambiguities. The available coupling tyes are only :directed, :undirected, :fiducial. For :undirected coupling the internal dimension of the EdgeFunction is doubled in order to resolve both directions in an undirected network. Remember to specify 2 initial conditiosn for every edge in that case.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"ODEEdge(; f=edgefunction!, dim=n, coupling=:undirected)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"In this case the function defaults to using the identity matrix as mass matrix and [:e for in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#[StaticDelayEdge](@ref)","page":"Functions","title":"StaticDelayEdge","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"This constructor is used when edge variables depend on past values of the vertex variables. In this case the edgefunction! has to accept two additional arguments h_v_s and h_v_d that hold the history of v_s and v_d. Static means that the edge depends only on the dynamics of the vertices the edge is connected to and not on an internal derivative of the edge variables itself.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"As an example for such system, we show a diffusive coupling with delay:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"edgefunction! = (e, v_s, v_d, h_v_s, h_v_d, p, t) -> e .= 0.1 * (h_v_s .- v_d)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The EdgeFunction object is constructed as","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"StaticDelayEdge(edgefunction!, dim, coupling, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Like for a StaticEdge, we can also leave out the optional keywords coupling, sym and mass_matrix. Available coupling types are :unspecified, :directed, :undirected, :fiducial.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"StaticDelayEdge(; f=edgefunction!, dim=n)","category":"page"},{"location":"BasicConstructors/#Constructor","page":"Functions","title":"Constructor","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The central constructor is the function network_dynamics that takes in two arrays of EdgeFunctions and VertexFunctions describing the local dynamics on the edges and nodes of a graph g, given as a Graphs.jl object. It returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertices!::Array{VertexFunction},\n                      edges!::Array{EdgeFunction}, g)\nnd(dx, x, p, t)","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"If all vertices, respectively edges share the same VertexFunction or EdgeFunction, than network_dynamics can be conveniently called with these functions as arguments.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertexfunction!::VertexFunction,\n                      edgefunction!::EdgeFunction, g)\n","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"The optional keyword argument parallel is false by default and can be set to true if a multi-threaded ODEFunction should be used. This may significantly improve performance on multi-core machines, for more details see section Multi-Threading.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertexfunction!::VertexFunction,\n                      edgefunction!::EdgeFunction, g; parallel=true)\n","category":"page"},{"location":"BasicConstructors/#Example","page":"Functions","title":"Example","text":"","category":"section"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Let's look at an example. First, we define our graph as well as the differential systems connected to its vertices and edges:","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"using NetworkDynamics, Graphs\n\ng = erdos_renyi(10, 25) # random graph with 10 vertices and 25 edges\n\nfunction vertexfunction!(dv, v, edges, p, t)\n    dv .= 0\n    for e in edges\n        dv .+= e\n    end\nend\n\nfunction edgefunction!(de, e, v_s, v_d, p, t)\n    de .= 1000 .* (v_s .- v_d .- e)\n    nothing\nend\n\nvertex = ODEVertex(; f=vertexfunction!, dim=1)\nvertexarr = [vertex for v in vertices(g)]\n\nedge = ODEEdge(; f=edgefunction!, dim=1, coupling=:undirected)\nedgearr = [edge for e in edges(g)]\n\nnd = network_dynamics(vertexarr, edgearr, g)\n\nnothing # hide","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"Now we have an ODEFunction nd that can be solved with the tools provided by DifferentialEquations.jl.","category":"page"},{"location":"BasicConstructors/","page":"Functions","title":"Functions","text":"For more details check out the Tutorials section.","category":"page"}]
}
