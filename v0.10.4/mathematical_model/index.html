<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Model · NetworkDynamics</title><meta name="title" content="Mathematical Model · NetworkDynamics"/><meta property="og:title" content="Mathematical Model · NetworkDynamics"/><meta property="twitter:title" content="Mathematical Model · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li class="is-active"><a class="tocitem" href>Mathematical Model</a><ul class="internal"><li><a class="tocitem" href="#Modeling-the-Dynamics-of-the-System"><span>Modeling the Dynamics of the System</span></a></li><li><a class="tocitem" href="#Feed-Forward-Behavior"><span>Feed Forward Behavior</span></a></li></ul></li><li><a class="tocitem" href="../network_construction/">Network Construction</a></li><li><a class="tocitem" href="../data_structure/">Data Structure</a></li><li><span class="tocitem">Features</span><ul><li><a class="tocitem" href="../symbolic_indexing/">Symbolic Indexing</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../callbacks/">Callbacks and Events</a></li><li><a class="tocitem" href="../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../sparsity_detection/">Sparsity Detection</a></li><li><a class="tocitem" href="../external_inputs/">External Inputs</a></li><li><a class="tocitem" href="../inspector/">Interactive Solution Inspection</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../generated/heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../generated/init_tutorial/">Initialization</a></li><li><a class="tocitem" href="../generated/cascading_failure/">Cascading Failure</a></li><li><a class="tocitem" href="../generated/gas_network/">Gas Network</a></li><li><a class="tocitem" href="../generated/stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../generated/directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Mathematical Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/src/mathematical_model.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-Model"><a class="docs-heading-anchor" href="#Mathematical-Model">Mathematical Model</a><a id="Mathematical-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Model" title="Permalink"></a></h1><p>The core of the <code>NetworkDynamics.jl</code> package is the <a href="../API/#NetworkDynamics.Network"><code>Network</code></a> function. It accepts functions describing the local dynamics on the edges and nodes of the graph <code>g</code> as inputs, and returns a composite function compatible with the DifferentialEquations.jl syntax as output.</p><pre><code class="language-julia hljs">nd = Network(g, vertex_dynamics,  edge_dynamics)
nd(dx, x, p, t)</code></pre><p>In general, the local dynamics on the edges and nodes of a graph can be described through the use of (a) algebraic equations, (b) differential algebraic equations (DAEs) in mass matrix form, or (c) ordinary differential equations (ODEs). The <code>NetworkDynamics.jl</code> package uses <a href="https://mathworld.wolfram.com/Differential-AlgebraicEquation.html">Differential-Algebraic-Equations (DAE)</a> to express the overall network dynamics:</p><p class="math-container">\[M\,\frac{\mathrm{d}}{\mathrm{d}t}u = f^{\mathrm{nw}}(u, p, t)\]</p><p>where <span>$M$</span> is a (possibly singular) mass matrix, <span>$u$</span> is the internal state vector of the system, <span>$p$</span> are the parameters, and <span>$t$</span> is the time. To make this compatible with the solvers used in <code>OrdinaryDiffEq.jl</code>, the generated <a href="../API/#NetworkDynamics.Network"><code>Network</code></a> object is callable</p><pre><code class="nohighlight hljs">nw(du, u, p, t) # mutates du as an &quot;output&quot;</code></pre><p>and represents the right-hand-side (RHS) of the equation above. The mass-matrix <span>$M$</span> is stored in the <code>Network</code> object as well.</p><h2 id="Modeling-the-Dynamics-of-the-System"><a class="docs-heading-anchor" href="#Modeling-the-Dynamics-of-the-System">Modeling the Dynamics of the System</a><a id="Modeling-the-Dynamics-of-the-System-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-the-Dynamics-of-the-System" title="Permalink"></a></h2><p>Each component model <span>$\mathrm c$</span> is modeled as a general input-output system:</p><p class="math-container">\[\begin{aligned}
M_{\mathrm c}\,\frac{\mathrm{d}}{\mathrm{d}t}x_{\mathrm c} &amp;= f^{\mathrm c}(x^{\mathrm c}, i_{\mathrm c}, p_{\mathrm c}, t)\\
y^{\mathrm c} &amp;= g^{\mathrm c}(x^\mathrm{c}, i_{\mathrm c}, p_{\mathrm c}, t)
\end{aligned}\]</p><p>where <span>$M_{\mathrm{c}}$</span> is the component mass matrix, <span>$x^{\mathrm c}$</span> are the component states, <span>$i^{\mathrm c}$</span> are the inputs of the component, and <span>$y^{\mathrm c}$</span> is the output of the component. If <span>$\mathrm{dim}(x^{\mathrm{c}}) = 0$</span>, the number of internal states is 0.</p><p>The mathematical model of <code>NetworkDynamics.jl</code> splits the network system into two parts: the vertex and the edge components (the nodes and edges, respectively). Instead of defining the <span>$f^{\mathrm{nw}}$</span> by hand, <code>ND.jl</code> builds it automatically based on a list of decentralized nodal and edge dynamics that the user provides (the <code>VertexModel</code> and <code>EdgeModel</code> objects).</p><p>In the context of the network, the <strong>output of the edges are flow variables</strong> and the <strong>outputs of vertices are potential variables</strong>. When the node and edge models are placed on a graph, the inputs and outputs are connected: the nodes receive the output of the adjacent edges as inputs and the edges receive the output of the adjacent nodes as inputs. Thus, the <em>flow</em> on the edges depends on the <em>potentials</em> at both ends as inputs. The <em>potentials</em> of the nodes depend on the incoming <em>flows</em> from all connected edges as an input. (Here, flow and potentials are meant in a conceptual and not necessarily physical way.)</p><picture>
  <source srcset="../assets/mathmodel-dark.svg" media="(prefers-color-scheme: dark)">
  <img src="../assets/mathmodel.svg" width="100%" height="100%"/>
</picture><p>In this graphical representation of a partial network graph, three nodes are visible (node 1, node 2, and node 3) as well as the edges connecting node 1 and node 2 (<span>$e_{\mathrm{12}}$</span>). Above the network, you can see the dynamical systems for both nodes 1 and 2 as well as the connecting edge. The figure shows how the outputs of the edge appear as inputs to the nodes and the outputs of the nodes appear as inputs to the edge models.</p><h3 id="Vertex-Models"><a class="docs-heading-anchor" href="#Vertex-Models">Vertex Models</a><a id="Vertex-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-Models" title="Permalink"></a></h3><p>The equations of a (single-layer) full vertex model are:</p><p class="math-container">\[\begin{aligned}
M^{\mathrm v}\,\frac{\mathrm{d}}{\mathrm{d}t}x^{\mathrm v} &amp;= f^{\mathrm v}(x^{\mathrm v}, i^{\mathrm v}, p^{\mathrm v}, t)\\
y^{\mathrm v} &amp;= g^{\mathrm v}(x^{\mathrm v}, i^{\mathrm v}, p^{\mathrm v}, t)
\end{aligned}\]</p><p>and they correspond to the Julia functions:</p><pre><code class="language-julia hljs">function fᵥ(dxᵥ, xᵥ, e_aggr, pᵥ, t)
    # mutate dxᵥ
    nothing
end
function gᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)
    # mutate yᵥ
    nothing
end
vertf = VertexModel(; f=fᵥ, g=gᵥ, mass_matrix=Mᵥ, ...)</code></pre><p>A (single-layer) full vertex model has one input, and one output. Its input is an aggregation/reduction over all the <em>incident edge outputs</em> which is calculated using:</p><p class="math-container">\[i^{\mathrm v} = \mathop{\mathrm{agg}}\limits_k^{\text{incident}} y^{\mathrm e}_k \qquad\text{often}\qquad
i^{\mathrm v} = \sum_k^{\text{incident}} y^{\mathrm e}_k\]</p><p>The graphical representation of such a model is:</p><picture>
  <source srcset="../assets/nodemodel-dark.svg" media="(prefers-color-scheme: dark)">
  <img src="../assets/nodemodel.svg" width="70%" height="70%"/>
</picture><p>where <span>$y^e_i$</span> and <span>$y^e_j$</span> are two of the <span>$n$</span> incident edge outputs that are aggregated to produce the model input <span>$i^v$</span> and the model output <span>$y^v$</span> (the vertex model output).</p><h3 id="Edge-Models"><a class="docs-heading-anchor" href="#Edge-Models">Edge Models</a><a id="Edge-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-Models" title="Permalink"></a></h3><p>In contrast to vertex models, edge models in general have <em>two</em> inputs and <em>two</em> outputs, for both the source and the destination end of the edge. We commonly use <code>src</code> and <code>dst</code> to describe the source and destination ends of an edge, respectively.</p><div class="admonition is-info" id="On-the-directionality-of-edges-c8d9a83b039e6d05"><header class="admonition-header">On the directionality of edges<a class="admonition-anchor" href="#On-the-directionality-of-edges-c8d9a83b039e6d05" title="Permalink"></a></header><div class="admonition-body"><p>Mathematically, in a system defined on an undirected graph, there is no difference between edge <span>$(1,2)$</span> and edge <span>$(2,1)$</span>, because the edge has no direction. However, from an implementation point of view, we always need to have some kind of ordering. For undirected graphs, the edges are always defined from <code>src -&gt; dst</code> where <code>src &lt; dst</code> (this convention matches the behavior of the <code>edges</code> iterator from <code>Graphs.jl</code>). I.e., the undirected edge between nodes 1 and 2 will always be referenced as <code>1 -&gt; 2</code>, never <code>2 -&gt; 1</code>. The <strong>source</strong> and <strong>destination</strong> naming is related to this notion of directionality; it is not related to the actual flows, i.e., a system might exist where there is a net flow from destination to source.</p></div></div><p>The full edge model equations are:</p><p class="math-container">\[\begin{aligned}
M^{\mathrm e}\,\frac{\mathrm{d}}{\mathrm{d}t}x^{\mathrm e} &amp;= f^{\mathrm e}(u^{\mathrm e}, y^{\mathrm v}_{\mathrm{src}}, y^{\mathrm v}_{\mathrm{dst}}, p^{\mathrm e}, t)\\
y^{\mathrm e}_{\mathrm{dst}} &amp;= g_\mathrm{dst}^{\mathrm e}(u^{\mathrm e}, y^{\mathrm v}_{\mathrm{src}}, y^{\mathrm v}_{\mathrm{dst}}, p^{\mathrm e}, t)\\
y^{\mathrm e}_{\mathrm{src}} &amp;= g_\mathrm{src}^{\mathrm e}(u^{\mathrm e}, y^{\mathrm v}_{\mathrm{src}}, y^{\mathrm v}_{\mathrm{dst}}, p^{\mathrm e}, t)
\end{aligned}\]</p><p>and they correspond to the Julia functions:</p><pre><code class="language-julia hljs">function fₑ(dxₑ, xₑ, v_src, v_dst, pₑ, t)
    # mutate dxₑ
    nothing
end
function gₑ(y_src, y_dst, xₑ, v_src, v_dst, pₑ, t)
    # mutate y_src and y_dst
    nothing
end
edgef = EdgeModel(; f=fₑ, g=gₑ, mass_matrix=Mₑ, ...)</code></pre><p>Each edge has:</p><ol><li>two inputs:<ol><li>the node outputs of the source</li><li>the node outputs of the destination end of the edge</li></ol></li><li>two outputs:<ol><li>the <code>dst</code> output (which is used as input for the vertex at the destination end)</li><li>the <code>src</code> output (which is used as input for the vertex at the source end)</li></ol></li></ol><p>In general, the two edge outputs <span>$y_{\mathrm{src}}$</span> and <span>$y_{\mathrm{dst}}$</span> are <strong>completely independent</strong> because there is no implicit conservation law dictating that their values should be identical. An example of such unbalanced systems is power lines in an energy grid with losses, where the power flowing into a line does not match the power flowing out of it, because some of the energy transported is lost in the form of heat. Another example would be a gas pipeline with some internal pressure: it is entirely possible to push in gas from both ends simultaneously. It would simply result in increased pressure within the pipe. For the (important) special cases where there is a strong correlation between source and destination output, see the section on <a href="#Single-Sided-Edge-Outputs">Single Sided Edge Outputs</a> below.</p><p>The vertex models connected to the edge do not know whether they are at the &#39;src&#39; or the &#39;dst&#39; end of the edge. Therefore, the sign convention for both outputs of an edge must be identical. Typically, a positive flow represents a flow <em>into</em> the connected vertex, whereas a negative flow represents a flow <em>out of</em> the connected vertex.</p><pre><code class="nohighlight hljs">          y_src ┌───────────────────┐ y_dst
  V_src o───←───┤ internal dynamics ├───→───o V_dst
                └───────────────────┘</code></pre><h3 id="Single-Sided-Edge-Outputs"><a class="docs-heading-anchor" href="#Single-Sided-Edge-Outputs">Single Sided Edge Outputs</a><a id="Single-Sided-Edge-Outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Sided-Edge-Outputs" title="Permalink"></a></h3><p>Often, the edge output functions <span>$g_\mathrm{src}$</span> and <span>$g_\mathrm{dst}$</span> are not independent, but rather one of them is a function of the other. For example, in an edge model with flow conservation without internal storage, the flow magnitude at the source end is equal to the flow magnitude at the destination end (what flows in must come out). Since the sign convention on both ends must be identical (e.g., positive flow is a flow towards the vertex), we get antisymmetric behavior: <span>$y_\mathrm{src} = -y_\mathrm{dst}$</span>.</p><p>To accommodate such cases, we can use the concept of <strong>single-sided edge output functions</strong>. A single-sided output function only defines a function for one of the outputs:</p><pre><code class="language-julia hljs">function g_single(y, xᵥ, v_src, v_dst, pₑ, t)
    # mutate y
    nothing
end</code></pre><p>There are multiple wrappers available to automatically convert them into double-sided edge output functions:</p><ul><li><code>Directed(g_single)</code> builds a double-sided function <em>which only couples</em> to the destination side (i.e., <span>$y_{dst}=y$</span> and <span>$y_{src} = 0$</span>).</li><li><code>Symmetric(g_single)</code> builds a double-sided function in which both ends receive <code>y</code> (i.e., <span>$y = y_{src} = y_{dst}$</span>).</li><li><code>AntiSymmetric(g_single)</code> builds a double-sided function where the destination receives <code>y</code> and the source receives <code>-y</code> (i.e., <span>$y=y_{dst}=-y_{src}$</span>).</li><li><code>Fiducial(g_single_src, g_single_dst)</code> builds a double-sided edge output function based on two single-sided functions.</li></ul><h2 id="Feed-Forward-Behavior"><a class="docs-heading-anchor" href="#Feed-Forward-Behavior">Feed Forward Behavior</a><a id="Feed-Forward-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Feed-Forward-Behavior" title="Permalink"></a></h2><div class="admonition is-warning" id="Feed-Forward-Vertices-2b72f0f7ce03e244"><header class="admonition-header">Feed Forward Vertices<a class="admonition-anchor" href="#Feed-Forward-Vertices-2b72f0f7ce03e244" title="Permalink"></a></header><div class="admonition-body"><p>As of 11/2024, vertices with feed forward behavior (FF) are not supported at all. Use <a href="../API/#NetworkDynamics.ff_to_constraint"><code>ff_to_constraint</code></a> to transform them into vertex models without FF.</p></div></div><p>Component models can have a so-called feed forward behavior, which provides a direct link between the input and the output.</p><p>The most generic version of the component models can contain direct FFs from the input to the output. This means that the output function <span>$g$</span> depends directly on the component inputs <span>$i$</span> rather than just on the component state <span>$x$</span>.</p><p>Whenever possible, you should define output functions without FFs in the following way:</p><pre><code class="language-julia hljs">gᵥ_noff(yᵥ, xᵥ, pᵥ, t)
gₑ_noff([y_src,] y_dst, xₑ, pₑ, t)</code></pre><p>instead of the more general</p><pre><code class="language-julia hljs">gᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)
gₑ([y_src,] y_dst, xₑ, v_src, v_dst, pₑ, t)</code></pre><p>NetworkDynamics cannot couple two components with FFs to each other. However, it is always possible to transform feed forward behavior to an internal state <code>x</code> with mass matrix entry zero to circumvent this problem. This transformation can be performed automatically using <a href="../API/#NetworkDynamics.ff_to_constraint"><code>ff_to_constraint</code></a>.</p><p>Concretely, NetworkDynamics distinguishes between 4 types of feed forward behaviors of <code>g</code> functions based on the <a href="../API/#NetworkDynamics.FeedForwardType"><code>FeedForwardType</code></a> trait. The feed forward type is inferred automatically based on the provided function <code>g</code> (this is done by inspecting the available method signatures for <code>g</code>, i.e., NetworkDynamics checks how many arguments your <code>g</code> function takes). If the automatic inference of feed forward type fails, the user may specify it explicitly using the <code>ff</code> keyword argument of the Edge/VertexModel constructor.</p><p>The code block below presents the different <code>g</code> signatures for the different feed forward types:</p><p><strong><a href="../API/#NetworkDynamics.PureFeedForward"><code>PureFeedForward()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          ins...,       p, t) # abstractly
g!(out_dst,          v_src, v_dst, p, t) # single-sided edge
g!(out_src, out_dst, v_src, v_dst, p, t) # double-sided edge
g!(v_out,            e_aggr,       p, t) # single layer vertex</code></pre><p><strong><a href="../API/#NetworkDynamics.FeedForward"><code>FeedForward()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          x, ins...,       p, t) # abstractly
g!(out_dst,          x, v_src, v_dst, p, t) # single-sided edge
g!(out_src, out_dst, x, v_src, v_dst, p, t) # double-sided edge
g!(v_out,            x, e_aggr,       p, t) # single layer vertex</code></pre><p><strong><a href="../API/#NetworkDynamics.NoFeedForward"><code>NoFeedForward()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          x, p, t) # abstractly
g!(out_dst,          x, p, t) # single-sided edge
g!(out_src, out_dst, x, p, t) # double-sided edge
g!(v_out,            x, p, t) # single layer vertex</code></pre><p><strong><a href="../API/#NetworkDynamics.PureStateMap"><code>PureStateMap()</code></a></strong></p><pre><code class="language-julia hljs">g!(outs...,          x) # abstractly
g!(out_dst,          x) # single-sided edge
g!(out_src, out_dst, x) # double-sided edge
g!(v_out,            x) # single layer vertex</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« General</a><a class="docs-footer-nextpage" href="../network_construction/">Network Construction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 14 August 2025 17:21">Thursday 14 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
