var documenterSearchIndex = {"docs":
[{"location":"mtk_integration/#ModelingToolkit-Integration","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"","category":"section"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"NetworkDynamics.jl is compatible with ModelingToolkit.jl (MTK). The general idea is to use MTK to define component models (i.e. edge and vertex dynamics) which are then connected on network scale using NetworkDynamics.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"The main entry point for this interop are the constructors","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"VertexModel(::System, inputs, outputs)\nEdgeModel(::System, srcin, dstin, [srscout], dstout)","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"whose docstrings can be found in the Component Models with MTK section in the API.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"These constructors will:","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"transform the states marked as input to parameters and mtkcompileing the system,\ngenerate the f and g functions,\ngenerate code for observables,\nport all supported Metadata from MTK symbols to component symbols and\noutput a Vertex-/EdgeModel function compatible with NetworkDynamics.jl.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"The main usecase for this feature is when you want to build relatively complex component models but interconnect them in a very homogeneous way (i.e. having the same output/input pairings in the whole system).","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"In theory, you can achieve everything you want to do with plain MTK. The idea of combining the two is, that NetworkDynamics offers far less flexibility when in comes to interconnection of subsystems on the network level. This might allow ND to exploit more knowledge of the structure without very expensive operations such as tearing of thousands of equations.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"warning: Warning\nModelingToolkit is a fast paced library with lots of functionality and ever growing complexity. As such the provided interface is kinda experimental. Some features of MTK are straight up unsupported, for example events within models or delay differential equations.","category":"page"},{"location":"mtk_integration/#RC-Circuit-Example","page":"ModelingToolkit Integration","title":"RC-Circuit Example","text":"","category":"section"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"In good MTK tradition, this feature will be explained along a simple RC circuit example. The Gas Network Example or Initialization Tutorial also showcase the MTK constructors.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"The system to model is 2 node, 1 edge network. The node output states are the voltage (to ground), the edge output sates are the currents at both ends.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"\nideal v source      Resistor     Capacitor\n            v1 o─←────MMM────→─o v2\n               │               ┴\n              (↗)              ┬\n               │               │\n               ⏚               ⏚","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Obviously there is no need in modeling such a small system using NetworkDynamics, however the method extends quite easily to construct large electrical networks reusing the same fundamental building blocks.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"using NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEqTsit5\nusing CairoMakie","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"All our components have \"terminals\", which have a voltage and current. We don't use the @connector from MTK here because our pins mark the interface towards the network and do not follow the MTK connector semantics.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"@mtkmodel NWTerminal begin\n    @variables begin\n        v(t), [description=\"Voltage at node\"]\n        i(t), [description=\"Current flowing into node\"]\n    end\nend\nnothing #hide","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"An ideal voltage source is just a model which pins its output voltage to a fixed parameter. The source ejects whatever current is necessary. We introduce another variable i(t) to \"capture\" this current. This variable will be removed during structural simplify, but will be available for plotting through the Observables mechanism. The VertexModel can be generated from an System by providing names of the input and output states:","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"@mtkmodel VoltageSource begin\n    @components begin\n       p = NWTerminal()\n    end\n    @parameters begin\n        V = 1.0\n    end\n    @variables begin\n        i(t), [description=\"produced current by ideal voltage source (observable)\"]\n    end\n    @equations begin\n        i ~ -p.i\n        p.v ~ V\n    end\nend\n@named vs = VoltageSource()\nvs_vertex = VertexModel(vs, [:p₊i], [:p₊v]; vidx=1)","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"A capacitor is a slightly more complicated model. Its voltage is defined as an differential equation based on the inflowing current.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"@mtkmodel Capacitor begin\n    @components begin\n        p = NWTerminal(;v=0)\n    end\n    @parameters begin\n        C = 1.0\n    end\n    @equations begin\n        D(p.v) ~ p.i / C\n    end\nend\n@named cap = Capacitor()\ncap_vertex = VertexModel(cap, [:p₊i], [:p₊v], vidx=2)","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"For the resistor we need two pins, one for the src and one for the dst side. The equations are straight forward.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"@mtkmodel Resistor begin\n    @components begin\n        src = NWTerminal()\n        dst = NWTerminal()\n    end\n    @parameters begin\n        R = 1.0\n    end\n    @equations begin\n        dst.i ~ (src.v - dst.v)/R\n        src.i ~ -dst.i\n    end\nend\n@named resistor = Resistor()\nresistor_edge = EdgeModel(resistor, [:src₊v], [:dst₊v], [:src₊i], [:dst₊i]; src=:vs, dst=:cap)","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Having all those components defined, we can build the network. We don't need to provide a graph object here because we specified the placement in the graph on a per component basis.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"nw = Network([vs_vertex, cap_vertex], [resistor_edge])","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"We can see, that NetworkDynamics internally is able to reduce all of the \"output\" states. We end up with a plain ODE of a single state.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Now we can simulate the system. For that we generate the u0 object. Since the metadata (such as default values) was automatically transferred, we can straight away construct the ODEProblem and solve the system.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"u0 = NWState(nw) # generate state based on default values\nprob = ODEProblem(nw, uflat(u0), (0, 10.0), pflat(u0))\nsol = solve(prob, Tsit5())\n\n# plot the solution\nfig, ax1, p = plot(sol; idxs=VIndex(:cap, :p₊v), label=\"Capacitor Voltage\");\naxislegend(ax1)\nax2 = Axis(fig[2,1])\nplot!(ax2, sol; idxs=VIndex(:vs, :i), label=\"Current produced by ideal v source\")\naxislegend(ax2)\nfig # hide","category":"page"},{"location":"mtk_integration/#Fully-Implicit-Outputs","page":"ModelingToolkit Integration","title":"Fully Implicit Outputs","text":"","category":"section"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"When working with MTK systems in NetworkDynamics, you may encounter situations where your desired output variables don't explicitly appear in the equations. This creates fully implicit outputs - variables that are determined by the system's constraints but aren't directly computed.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"tip: tl;dr\nIntroduce \"fake\" dependencies to your input-forcing equations 0 ~ in + implicit_output(y). Which is mathematically equivalent to 0 ~ in but helps MTK to reason about dependencies.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Consider a system with a fully implicit output:","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"   u┌───────┐y\n  ─→┤ 0 ~ u ├→─\n    └───────┘","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Here, y does not appear in the equations at all. In general, that doesn't make too much sense. During simplification, MTK will potentially get rid of the equation as it does not contribute to the system's state.","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"However, in NetworkDynamics, we're always dealing with open loop models on the equation level, which is not exactly what MTK was made for. If you build a closed loop between a subsystem A which has input forcing and a subsystem B which has input feed forward, the resulting system can be solved:","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"    (system with input forcing)\n          ua┌─────────┐ya\n        ┌──→┤  0 ~ ua ├→──┐\n        │   └─────────┘   │\n        │ yb┌─────────┐ub │\n        └──←┤ yb ~ ub ├←──┘\n            └─────────┘\n(system with input feed forward)","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Since MTK does not know about the closed loop (which is only introduced on the NetworkDynamics level once we leave the equation based domain) we need to help MTK to figure out those dependencies. We can do so by introducing \"fake\" dependencies using implicit_output. This function is defined as","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"implicit_output(x) = 0\nModelingToolkit.@register_symbolic implicit_output(x)","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"which makes it numerically equivalent to zero (no effect on the simulation) but is opaque to the Symbolic Simplification.","category":"page"},{"location":"mtk_integration/#Example","page":"ModelingToolkit Integration","title":"Example","text":"","category":"section"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"Consider a \"Kirchhoff Node\" between multiple resistors:","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"the currents through the resistors directly depend on the voltage output of the node (input feed forward) and\nthe Kirchhoff node requires the sum of all inflowing currents to be zero (input forcing).","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"We can model this type of node like this:","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"@mtkmodel KirchhoffNode begin\n    @variables begin\n        v(t), [description=\"Node voltage\", output=true]\n        i_sum(t), [description=\"Sum of incoming currents\", input=true]\n    end\n    @equations begin\n        0 ~ i_sum + implicit_output(v)  # Kirchhoff's current law\n    end\nend\n@named kirchhoff = KirchhoffNode()\nVertexModel(kirchhoff, [:i_sum], [:v])","category":"page"},{"location":"mtk_integration/","page":"ModelingToolkit Integration","title":"ModelingToolkit Integration","text":"where we \"trick\" MTK into believing that the input forcing equation depends on the output too.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Getting-Started","page":"Getting Started","title":"Network Diffusion","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"This example explains the use of the basic functions and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"This page will:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"walk you through the theoretical background of a simple diffusion propagating in an undirected network\nexplain the network dynamics of the system\nexplain how to program them","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"note: Note\nAn Undirected Network is a network where all the connections between the nodes are bidirectional.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"This example can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Theoretical-background","page":"Getting Started","title":"Theoretical background","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Diffusion processes appear in phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed entropy (the entropy being in the form of e.g. heat, charge or concentration). If we assume a thermal system, the temperature of a specific spot changes depending on the temperature gradient between the temperature of the spot itself and that of its neighborhood.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We will build a graph g with N nodes and an adjacency matrix A, where v = (v_1 dots v_n) is the vector of the (abstract) temperatures at each node i = 1 dots N. The rate of change of state v_i will be described by the difference between the temperature of the node and that of its neighbours. From the above we obtain the following ordinary differential equation:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"dot v_i = sum_j=1^N A_ji (v_j - v_i)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"If a node were to be disconnected from the rest of the network its state would never change, because its adjacency matrix would be A_ji = 0  forall j and hence dot v_i = 0. So because its state would remain unchanged the model will be comprised of nodes that have no internal dynamics. This means that the evolution of a node will depend only on its interaction with its neighbors. In NetworkDynamics.jl, interactions between a node and its neighbors are described using edge equations.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"In order to bring this equation into the form required by NetworkDynamics.jl we need to split the dynamics into edge dynamics and vertex dynamics and bring them into the correct input-output formulation.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Vertex-Dynamics:","page":"Getting Started","title":"Vertex Dynamics:","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"All vertices have one internal state v, which is also the vertex output. It is the sum over all incoming edge flows connected to the vertex. This directly corresponds to the component model definition outlined in Mathematical Model:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"beginaligned\ndot x^mathrmv = f^mathrm v(u^mathrm v sum_k^textincident y^mathrm e_k p^mathrm v t) = sum_k^mathrmincident y^mathrme_k \ny^mathrmv = g^mathrm v(u^mathrm v sum_k^textincident y^mathrm e_k p^mathrm v t) = x^mathrmv\nendaligned","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Edge-Dynamics:","page":"Getting Started","title":"Edge Dynamics:","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"The edge dynamics on the other hand do not have any internal states. Thus we can define the edge output as the difference between the source and destination vertices:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"beginaligned\ny^mathrm e_mathrmdst = g_mathrmdst^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t) = y^mathrm v_mathrmsrc - y^mathrm v_mathrmdst\ny^mathrm e_mathrmsrc = g_mathrmsrc^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t) = y^mathrm v_mathrmdst - y^mathrm v_mathrmsrc\nendaligned","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Modelling-dynamics-in-NetworkDynamics.jl","page":"Getting Started","title":"Modelling dynamics in NetworkDynamics.jl","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"To model the vertex and edge dynamics we need to create a VertexModel and an EdgeModel, respectively.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"As a first step we need to install Julia and the necessary packages (Graphs, NetworkDynamics, OrdinaryDiffEqTsit5, StableRNGs and Plots). Then we need to load them:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"using Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing StableRNGs\nusing Plots\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Defining-the-EdgeModel","page":"Getting Started","title":"Defining the EdgeModel","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Then we must define the EdgeModel. To define it we use the function diffusionedge_g! which takes as inputs the current state of the edge e, its source vertex v_src, its destination vertex v_dst, a vector of parameters p and the time t. In order to comply with the syntax of NetworkDynamics.jl we must always define functions for edges with exactly these arguments. (In the case of this example, the values for p and t are not used since there are no parameters and there is no explicit time dependency in the system).","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"After the function call the edge's output value e equals the difference between its source and its destination vertex     (i.e. the discrete gradient along that edge).","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"note: Note\ndiffusionedge_g! is called a mutating function, because it mutates (modifies) the edge state e (which is the first of its inputs). (In Julia, names of mutating functions end with an !.) We use mutating functions because they reduce the computational resource allocations and therefore, speed up the computations.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"function diffusionedge_g!(e_dst, v_src, v_dst, p, t)\n    # e_dst, v_src, v_dst are arrays, so we use the broadcasting operator .\n    e_dst .= v_src .- v_dst\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Notably, this function only models g_mathrmdst. However we can wrap this single-sided output function in an AntiSymmetric output wrapper to construct the EdgeModel:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"nd_diffusion_edge = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow])","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Defining-the-VertexModel","page":"Getting Started","title":"Defining the VertexModel","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Next we need to define the VertexModel. For undirected graphs, the edgefunction! specifies the coupling from a source to a destination vertex. The contributions of the connected edges to a single vertex are \"aggregated\". By default, the aggregation is the summation of all incident edge states. The aggregated edge state is made available via the esum argument of the vertex function.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"function diffusionvertex_f!(dv, v, esum, p, t)\n    # dv, v and esum are arrays, so we use the broadcasting operator .\n    dv .= esum\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Just like above, the input arguments v, esum, p, t are mandatory for the syntax of vertex functions. The additional     input dv corresponding to the derivative of the vertex' state is mandatory for vertices described by ordinary     differential equations. The outputs of the vertex function are just a subset of the internal states. Therefore, we     can use the StateMask helper function g = StateMask(1:1) to access them.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"nd_diffusion_vertex = VertexModel(; f=diffusionvertex_f!, g=StateMask(1:1), dim=1)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Constructing-the-network","page":"Getting Started","title":"Constructing the network","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"With the components defined, we can now define the topology and assemble the network dynamics.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"The first step is to define the number of nodes the network is comprised of:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"N = 20 # number of nodes\nk = 4  # average degree distribution\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Then we define the network model. We will use the Barabási–Albert model which generates a scale-free random graph.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"g = barabasi_albert(N, k)\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We then create the network of nodes and edges by using the constructor Network. It combines the component model with the topological information contained in the graph g and returns an Network compatible with the solvers of DifferentialEquations.jl.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"nd = Network(g, nd_diffusion_vertex, nd_diffusion_edge)\nrng = StableRNG(1)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We then generate random initial conditions","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"x0 = randn(rng, N)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We then solve the diffusion problem on the time interval 0 2 with the Tsit5() algorithm, which is recommended by the authors of DifferentialEquations.jl for most non-stiff problems. We first create an ODEProblem:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"ode_prob = ODEProblem(nd, x0, (0.0, 2.0))","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"And then solve the network using solve:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"sol = solve(ode_prob, Tsit5());\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We plot the results using the plot command, which takes two parameters as input sol and idxs. The first parameter is the solved network sol. The second parameter is idxs, which provides a set of indices. We can use \"symbolic\" indices, which specify specific components and their symbols directly (see Symbolic Indexing for more details). In order to collect multiple indices we can use the helper function vidxs and eidxs, which help us collect all symbolic indices matching specific criteria. Here, we want to plot all vertex states from the network.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"plot(sol; idxs=vidxs(nd, :, :))","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"In the plot we see, how the individual vertex states evolve over time. We start at a random configuration, and then develop towards an equilibrium where all nodes have the same state, which is to be expected for a simple diffusion process.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Two-Dimensional-Extension","page":"Getting Started","title":"Two Dimensional Extension","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"To illustrate a very simple multi-dimensional case, we simulate two independent diffusions on an identical graph. The first diffusion uses the symbol x and is initiated with initial conditions drawn from the standard normal distribution N(01), while the second diffusion uses the symbol ϕ with squared standard normal initial conditions.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"The symbols have to be passed with the keyword sym to VertexModel.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Once again we define the number of nodes and the type of network we want to generate:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"N = 10 # number of nodes\nk = 4  # average degrees distribution\ng = barabasi_albert(N, k)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We have two independent diffusions on the network, hence dim = 2. We now define the VertexModel and the EdgeModel","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"nd_diffusion_vertex_2 = VertexModel(; f=diffusionvertex_f!, g=1:2, dim=2, sym=[:x, :ϕ])\nnd_diffusion_edge_2 = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow_x, :flow_ϕ])\nnd_2 = Network(g, nd_diffusion_vertex_2, nd_diffusion_edge_2)","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We define the first diffusion as x ~ N(01)^mathrm2 and the second diffusion as ϕ ~ N(01). So the propagation of the diffusion from node 0 to node 2 is given by creating a vector:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"x0_2 = vec(transpose([randn(rng, N) .^ 2 randn(rng, N)]))","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"We then define the ODEProblem:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"ode_prob_2 = ODEProblem(nd_2, x0_2, (0.0, 3.0))","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Then solve the network using:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"sol_2 = solve(ode_prob_2, Tsit5());\nnothing #hide","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"To plot the evolution of variables ϕ_i over time we use the command:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"plot(sol_2; idxs=vidxs(nd_2, :, :x))","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"[To write ϕ in the terminal type \\phi and press TAB]","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"Using the eidxs helper function we can also plot the evolution of the flow variables over time:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"plot(sol_2; idxs=eidxs(nd_2, :, :flow_x))","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"As expected, the flows are nonzero first and go towards zero as we reach the equilibrium point.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Putting-it-all-together","page":"Getting Started","title":"Putting it all together","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"using Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing StableRNGs\nusing Plots\nnothing #hide\n\nfunction diffusionedge_g!(e_dst, v_src, v_dst, p, t)\n    # e_dst, v_src, v_dst are arrays, so we use the broadcasting operator .\n    e_dst .= v_src .- v_dst\n    nothing\nend\nnothing #hide\n\nnd_diffusion_edge = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow])\n\nfunction diffusionvertex_f!(dv, v, esum, p, t)\n    # dv, v and esum are arrays, so we use the broadcasting operator .\n    dv .= esum\n    nothing\nend\nnothing #hide\n\nnd_diffusion_vertex = VertexModel(; f=diffusionvertex_f!, g=StateMask(1:1), dim=1)\n\nN = 20\nk = 4\ng = barabasi_albert(N, k)\nnothing #hide\n\nnd = Network(g, nd_diffusion_vertex, nd_diffusion_edge)\nrng = StableRNG(1)\nx0 = randn(rng, N)\node_prob = ODEProblem(nd, x0, (0.0, 2.0))\nsol = solve(ode_prob, Tsit5());\nnothing #hide\nplot(sol; idxs=vidxs(nd, :, :), fmt=:png)\nN = 10 #\nk = 4  #\ng = barabasi_albert(N, k)\nnd_diffusion_vertex_2 = VertexModel(; f=diffusionvertex_f!, g=1:2, dim=2, sym=[:x, :ϕ])\nnd_diffusion_edge_2 = EdgeModel(; g=AntiSymmetric(diffusionedge_g!), outsym=[:flow_x, :flow_ϕ])\nnd_2 = Network(g, nd_diffusion_vertex_2, nd_diffusion_edge_2)\nx0_2 = vec(transpose([randn(rng, N) .^ 2 randn(rng, N)]))\node_prob_2 = ODEProblem(nd_2, x0_2, (0.0, 3.0))\nsol_2 = solve(ode_prob_2, Tsit5());\nplot(sol_2; idxs=vidxs(nd_2, :, :x), xlabel = \"x\", ylabel = \"nd_2\",)\nplot(sol_2; idxs=eidxs(nd_2, :, :flow_x))","category":"page"},{"location":"generated/getting_started_with_network_dynamics/#Appendix:-The-network-Laplacian-L","page":"Getting Started","title":"Appendix: The network Laplacian L","text":"","category":"section"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"The diffusion equation on a network can be rewritten as:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"dot v_i  = sum_j=1^N A_ji v_j - d_i v_i =  e_i^T A v - d_i v_i","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"where d_i is the degree distribution of node i and e_i^T is the i-th standard basis vector.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"By introducing the diagonal matrix D, that has the degree of node i in its i-th row and the Laplacian matrix L = D - A we arrive at:","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"dot v = e_i^T(A - D) v","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"and finally","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"dot v = - L v","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"This is a linear system of ordinary differential equations (ODEs) and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of L.  For this reason L is an important construction in network science.","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"generated/getting_started_with_network_dynamics/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"external_inputs/#External-Inputs","page":"External Inputs","title":"External Inputs","text":"","category":"section"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"External inputs for components are way to pass signals between components outside of the network structure. The most common usecase for that are control systems: make your vertex i depend on some state of vertex j.","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"If used, this will essentially wides the number of received inputs of a component function. I.e. the baseline mathematical models for vertex models","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"beginaligned\nM^mathrm vfracmathrmdmathrmdtx^mathrm v = f^mathrm v(u^mathrm v i^mathrm v i^mathrmext p^mathrm v t)\ny^mathrm v = g^mathrm v(u^mathrm v i^mathrm v i^mathrmext p^mathrm v t)\nendaligned","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"fᵥ(dxᵥ, xᵥ, e_aggr, ext, pᵥ, t)\ngᵥ(yᵥ, xᵥ, [e_aggr, ext,] pᵥ, t)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"and edge models","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"beginaligned\nM^mathrm efracmathrmdmathrmdtx^mathrm e = f^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst i^mathrmext p^mathrm e t)\ny^mathrm e_mathrmdst = g_mathrmdst^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst i^mathrmext p^mathrm e t)\ny^mathrm e_mathrmsrc = g_mathrmsrc^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst i^mathrmext p^mathrm e t)\nendaligned","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"fₑ(dxₑ, xₑ, v_src, v_dst, ext, pₑ, t)\ngₑ(y_src, y_dst, xᵥ, [v_src, v_dst, ext,] pₑ, t)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"change. You may still oomit the input section from g according to the different Feed Forward Behaviors. However you either have to use all inputs (including ext) or none.","category":"page"},{"location":"external_inputs/#Usage","page":"External Inputs","title":"Usage","text":"","category":"section"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Vertex and Edge models with external inputs can be created using the extin keyword of the EdgeModel and VertexModel constructors.","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"You need to pass a vector of SymbolicIndices (VIndex and EIndex), e.g. ","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"VertexModel(... , extin=[VIndex(12,:x), VIndex(9, :x)], ...)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"means your vertex receives a 2 dimensional external input vector with the states x of vertices 12 and 9. See below for hands on example.","category":"page"},{"location":"external_inputs/#Limitations","page":"External Inputs","title":"Limitations","text":"","category":"section"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"There are some limitations in place. You can only reference states (i.e. things that appear in xᵥ or xₑ of some component model) or outputs of non-feed-forward components, i.e. states yᵥ or yₑ of some component model which does not have feed forward behavior in their g function.","category":"page"},{"location":"external_inputs/#Example","page":"External Inputs","title":"Example","text":"","category":"section"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"As an example system, we'll consider two capacitors with a resistor between them. Vertex 1 v1 has a controllable current source.  Using a PI controller for the current source, it tries to keep the voltage at the  second vertex stable under the disturbance of some time periodic current sind at v2.","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"\n                  v1    Resistor   v2\nPI controlled   ─→─o─←────MMM────→─o─→─ time dependent \ncurrent source     ┴               ┴    current sink\n                   ┬               ┬\n                   ⏚               ⏚","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"The example will be implemented 2 times: in plain NetworkDynamcics and using MTK.","category":"page"},{"location":"external_inputs/#Plain-NetworkDynamics","page":"External Inputs","title":"Plain NetworkDynamics","text":"","category":"section"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"First we define the resistor:","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"using NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\n\nfunction resistor_g(idst, vsrc, vdst, (R,), t)\n    idst[1] = (vsrc[1] - vdst[1])/R\nend\nresistor = EdgeModel(g=AntiSymmetric(resistor_g), \n                     outsym=:i, insym=:v, psym=:R=>0.1, \n                     src=:source, dst=:load, name=:resistor)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Then we define the \"load\" vertex with sinusoidial load profile:","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"function f_load(dv, v, iin, (C,), t)\n    dv[1] = 1/C*(iin[1] - (1 + 0.1*sin(t)))\nend\nload = VertexModel(f=f_load, g=1, \n                   sym=:V=>0.5, insym=:i, psym=:C=>1,\n                   vidx=2, name=:load)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Lastly, we define the \"source\" vertex","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"function f_source(dv, v, iin, extin, (C,Vref,Ki,Kp), t)\n    Δ = Vref - extin[1]      # tracking error\n    dv[2] = Δ                # integrator state of PI\n    i_inj = Kp*Δ + Ki*v[2]   # controller output\n    dv[1] = 1/C*(iin[1] + i_inj)\nend\nsource = VertexModel(f=f_source, g=1, \n                     sym=[:V=>0.5,:ξ=>0], insym=:i, \n                     psym=[:C=>1, :Vref=>1, :Ki=>0.5, :Kp=>10],\n                     extin=[VIndex(:load, :V)], \n                     vidx=1, name=:source)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Then we can create the network and simulate:","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"nw = Network([source, load], [resistor])\nu0 = NWState(nw) # everything has default values\nprob = ODEProblem(nw, uflat(u0), (0,100), pflat(u0))\nsol = solve(prob, Tsit5())\n\nfig, ax, p = lines(sol, idxs=VIndex(:load, :V), label=\"Voltage @ load\");\nlines!(ax, sol, idxs=VPIndex(:source, :Vref), label=\"Reference\", color=Cycled(2));\naxislegend(ax; position=:rb);\nfig # hide","category":"page"},{"location":"external_inputs/#MTK-Models","page":"External Inputs","title":"MTK Models","text":"","category":"section"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"First we define the resistor:","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"using NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\nusing CairoMakie\n\n@mtkmodel Resistor begin\n    @variables begin\n        i(t), [description=\"Current at dst end\"]\n        V_src(t), [description=\"Voltage at src end\"]\n        V_dst(t), [description=\"Voltage at dst end\"]\n    end\n    @parameters begin\n        R=0.1, [description=\"Resistance\"]\n    end\n    @equations begin\n        i ~ (V_src - V_dst)/R\n    end\nend\n@named resistor = Resistor()\nresistor_edge = EdgeModel(resistor, [:V_src], [:V_dst], AntiSymmetric([:i]); src=:load, dst=:source)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Then we define the \"load\" vertex with sinusoidial load profile:","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"@mtkmodel Load begin\n    @variables begin\n        V(t)=0.5, [description=\"Voltage\"]\n        i_load(t), [description=\"Load current\"]\n        i_grid(t), [description=\"Current from grid\"]\n    end\n    @parameters begin\n        C=1, [description=\"Capacitance\"]\n    end\n    @equations begin\n        i_load ~ 1 + 0.1*sin(t)\n        Dt(V) ~ 1/C*(i_grid - i_load)\n    end\nend\n@named load = Load()\nload_vertex = VertexModel(load, [:i_grid], [:V]; vidx=2)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Lastly, we define the \"source\" vertex","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"@mtkmodel Source begin\n    @variables begin\n        V(t)=0.5, [description=\"Voltage\"]\n        ξ(t)=0, [description=\"Integrator state\"]\n        i_grid(t), [description=\"Current from grid\"]\n        i_source(t), [description=\"Current from source\"]\n        Δ(t), [description=\"Tracking Error\"]\n        V_load(t), [description=\"Voltage at load\"]\n    end\n    @parameters begin\n        C=1, [description=\"Capacitance\"]\n        Vref=1, [description=\"Reference voltage\"]\n        Ki=0.5, [description=\"Integral gain\"]\n        Kp=10, [description=\"Proportional gain\"]\n    end\n    @equations begin\n        Δ ~ Vref - V_load\n        Dt(ξ) ~ Δ\n        i_source ~ Kp*Δ + Ki*ξ\n        Dt(V) ~ 1/C*(i_grid + i_source)\n    end\nend\n@named source = Source()\nsource_vertex = VertexModel(source, [:i_grid], [:V]; \n                            extin=[:V_load => VIndex(:load, :V)], vidx=1)","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Then we can create the network and simulate:","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"nw = Network([source_vertex, load_vertex], [resistor_edge])\nu0 = NWState(nw) # everything has default values\nprob = ODEProblem(nw, uflat(u0), (0,100), pflat(u0))\nsol = solve(prob, Tsit5())\n\nlet\n    fig = Figure();\n    ax1 = Axis(fig[1,1]);\n    lines!(ax1, sol, idxs=VIndex(:load, :V), label=\"Voltage @ load\");\n    lines!(ax1, sol, idxs=VPIndex(:source, :Vref), label=\"Reference\", color=Cycled(2));\n    axislegend(ax1; position=:rb);\n    ax2 = Axis(fig[2,1]);\n    lines!(ax2, sol, idxs=VIndex(:load, :i_load), label=\"load current\");\n    lines!(ax2, sol, idxs=VIndex(:source, :i_source), label=\"source current\", color=Cycled(2));\n    axislegend(ax2);\n    fig\nend","category":"page"},{"location":"external_inputs/","page":"External Inputs","title":"External Inputs","text":"Using MTK for modeling, we can also inspect the currents i_load and i_source the MTK interface preserves the Observables.","category":"page"},{"location":"generated/stress_on_truss/#Stress-on-Truss","page":"Stress on Truss","title":"Stress on Truss","text":"","category":"section"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"In this exampe we'll simulate the time evolution of a truss structure consisting of joints and stiff springs. This example can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"(Image: truss animation)","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"The mathematical model is quite simple: the vertices are point masses with positions x and y and velocities v_x and v_y. For simplicity, we add some damping to the nodal motion based on the velocity.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"beginaligned\ndotx = v_x\ndoty = v_y\ndotv_x = frac1Mleft(sum F_x - γv_xright)\ndotv_y = frac1Mleft(sum F_y - γv_yright) - g\nendaligned","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"The vertices cannot absorb any torque, so the beams only exert forces in the direction of the beam.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"F = Kcdot(L - Δd)","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"where L is the nominal lenth and Δd is the actual length of the beam.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"We start by loading the necessary packages.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"using NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing Graphs\nusing GraphMakie\nusing LinearAlgebra: norm\nusing Printf\nusing CairoMakie\nCairoMakie.activate!()","category":"page"},{"location":"generated/stress_on_truss/#Definition-of-the-dynamical-system","page":"Stress on Truss","title":"Definition of the dynamical system","text":"","category":"section"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"We need 3 models:","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"a fixed vertex which cannot change its position,\na free vertex which can move, and\na beam which connects two vertices.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"function fixed_g(pos, x, p, t)\n    pos .= p\nend\nvertex_fix = VertexModel(g=fixed_g, psym=[:xfix, :yfix], outsym=[:x, :y], ff=NoFeedForward())","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Here we need to specify the ff keyword manually, because NetworkDynamics cannot distinguish between g(out, x, p, t)  (NoFeedForwarwd) and g(out, in, p, t) (PureFeedForward()) and guesses the latter when mathrmdim(x)=0.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"function free_f(dx, x, Fsum, (M, γ, g), t)\n    v = view(x, 1:2)\n    dx[1:2] .= (Fsum .- γ .* v) ./ M\n    dx[2] -= g\n    dx[3:4] .= v\n    nothing\nend\nvertex_free = VertexModel(f=free_f, g=3:4, sym=[:vx=>0, :vy=>0, :x, :y],\n                             psym=[:M=>10, :γ=>200, :g=>9.81], insym=[:Fx, :Fy])","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"For the edge, we want to do something special. Later on, we want to color the edges according to the force they exert. Therefore, are interested in the absolut force rather than just the force vector. NetworkDynamics allows you to  define so called Observed functions, which can recover additional states, so called observed, after the simulations. We can use this mechanis, to define a \"recipe\" for calculating the beam force based on the inputs (nodal positions) and  the beam parameters.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"function edge_g!(F, pos_src, pos_dst, (K, L), t)\n    dx = pos_dst[1] - pos_src[1]\n    dy = pos_dst[2] - pos_src[2]\n    d = sqrt(dx^2 + dy^2)\n    Fabs = K * (L - d)\n    F[1] = Fabs * dx / d\n    F[2] = Fabs * dy / d\n    nothing\nend\nfunction observedf(obsout, u, pos_src, pos_dst, (K, L), t)\n    dx = pos_dst[1] .- pos_src[1]\n    dy = pos_dst[2] .- pos_src[2]\n    d = sqrt(dx^2 + dy^2)\n    obsout[1] = K * (L - d)\n    nothing\nend\nbeam = EdgeModel(g=AntiSymmetric(edge_g!), psym=[:K=>0.5e6, :L], outsym=[:Fx, :Fy], obsf=observedf, obssym=[:Fabs])","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"With the models define we can set up graph topology and initial positions.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"N = 5\ndx = 1.0\nshift = 0.2\ng = SimpleGraph(2*N + 1)\nfor i in 1:N\n    add_edge!(g, i, i+N); add_edge!(g, i, i+N)\n    if i < N\n        add_edge!(g, i+1, i+N); add_edge!(g, i, i+1); add_edge!(g, i+N, i+N+1)\n    end\nend\nadd_edge!(g, 2N, 2N+1)\npos0 = zeros(Point2f, 2N + 1)\npos0[1:N] = [Point((i-1)dx,0) for i in 1:N]\npos0[N+1:2*N] = [Point(i*dx + shift, 1) for i in 1:N]\npos0[2N+1] = Point(N*dx + 1, -1)\nfixed = [1,4] # set fixed vertices\nnothing #hide","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Now can collect the vertex models and construct the Network object.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"verts = VertexModel[vertex_free for i in 1:nv(g)]\nfor i in fixed\n    verts[i] = vertex_fix # use the fixed vertex for the fixed points\nend\nnw = Network(g, verts, beam)","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"In order to simulate the system we need to initialize the state and parameter vectors. Some states and parameters are shared between all vertices/edges. Those have been allready set in their constructors. The free symbols are","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"x and y for the position of the free vertices,\nxfix and yfix for the position of the fixed vertices,\nL for the nominal length of the beams.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"s = NWState(nw)\n# set x/y and xfix/yfix\nfor i in eachindex(pos0, verts)\n    if i in fixed\n        s.p.v[i, :xfix] = pos0[i][1]\n        s.p.v[i, :yfix] = pos0[i][2]\n    else\n        s.v[i, :x] = pos0[i][1]\n        s.v[i, :y] = pos0[i][2]\n    end\nend\n# set L for edges\nfor (i,e) in enumerate(edges(g))\n    s.p.e[i, :L] = norm(pos0[src(e)] - pos0[dst(e)])\nend\nnothing #hide","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Lastly there is a special vertex at the end of the truss which has a higher mass and reduced damping.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"s.p.v[11, :M] = 200\ns.p.v[11, :γ] = 100\nnothing #hide","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"No we have everything ready to build the ODEProblem and simulate the system.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"tspan = (0.0, 12.0)\nprob = ODEProblem(nw, uflat(s), tspan, pflat(s))\nsol  = solve(prob, Tsit5())\nnothing #hide","category":"page"},{"location":"generated/stress_on_truss/#Plot-the-solution","page":"Stress on Truss","title":"Plot the solution","text":"","category":"section"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"Plotting trajectories of points is kinda boring. So instead we're going to use GraphMakie.jl to create a animation of the timeseries.","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"fig = Figure(size=(1000,550));\nfig[1,1] = title = Label(fig, \"Stress on truss\", fontsize=30)\ntitle.tellwidth = false\n\nfig[2,1] = ax = Axis(fig)\nax.aspect = DataAspect();\nhidespines!(ax); # no borders\nhidedecorations!(ax); # no grid, axis, ...\nlimits!(ax, -0.1, pos0[end][1]+0.3, pos0[end][2]-0.5, 1.15) # axis limits to show full plot\n\n# get the maximum force during the simulation to get the color scale\n# It is only possible to access `:Fabs` directly becaus we've define the observable function for it!\n(fmin, fmax) = 0.3 .* extrema(Iterators.flatten(sol(sol.t, idxs=eidxs(nw, :, :Fabs))))\np = graphplot!(ax, g;\n               edge_width = 4.0,\n               node_size = 3*sqrt.(try s.p.v[i, :M] catch; 10.0 end for i in 1:nv(g)),\n               nlabels = [i in fixed ? \"Δ\" : \"\" for i in 1:nv(g)],\n               nlabels_align = (:center,:top),\n               nlabels_fontsize = 30,\n               elabels = [\"edge $i\" for i in 1:ne(g)],\n               elabels_side = Dict(ne(g)  => :right),\n               edge_color = [0.0 for i in 1:ne(g)],\n               edge_attr = (colorrange=(fmin,fmax),\n                          colormap=:diverging_bkr_55_10_c35_n256))\n\n# draw colorbar\nfig[3,1] = cb = Colorbar(fig, get_edge_plot(p), label = \"Axial force\", vertical=false)\n\nT = tspan[2]\nfps = 30\ntrange = range(0.0, sol.t[end], length=Int(T * fps))\nrecord(fig, \"truss.mp4\", trange; framerate=fps) do t\n    title.text = @sprintf \"Stress on truss (t = %.2f )\" t\n    s_at_t = NWState(sol, t)\n    for i in eachindex(pos0)\n        p[:node_pos][][i] = (s_at_t.v[i, :x], s_at_t.v[i, :y])\n    end\n    notify(p[:node_pos])\n    load = s_at_t.e[:, :Fabs]\n    p.edge_color[] = load\n    p.elabels = [@sprintf(\"%.0f\", l) for l in load]\n    fig\nend","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"","category":"page"},{"location":"generated/stress_on_truss/","page":"Stress on Truss","title":"Stress on Truss","text":"This page was generated using Literate.jl.","category":"page"},{"location":"sparsity_detection/#Sparsity-Detection","page":"Sparsity Detection","title":"Sparsity Detection","text":"","category":"section"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"NetworkDynamics.jl can automatically detect and exploit the sparsity structure of the Jacobian matrix to significantly improve the performance of ODE solvers. This feature uses SparseConnectivityTracer.jl to analyze the network's dynamics and create a sparse Jacobian prototype that modern solvers can use for more efficient linear algebra operations.","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"The sparsity detection is particularly beneficial for:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Large networks where the Jacobian matrix is sparse\nStiff systems that require implicit solvers\nNetworks with complex component interactions\nComponents with conditional statements that complicate automatic differentiation","category":"page"},{"location":"sparsity_detection/#Core-Function","page":"Sparsity Detection","title":"Core Function","text":"","category":"section"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"The main interface is the get_jac_prototype function, which take the a Network object as an argument and returns a sparse boolean matrix containing the sparsity pattern.","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"The sparsity pattern can be passed to ODE solvers to improve performance:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"f_ode = ODEFunction(nw; jac_prototype=get_jac_prototype(nw))\nprob = ODEProblem(f_ode, x0, (0.0, 1.0), p0)\nsol = solve(prob, Rodas5P())","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Alternatively, you can store the sparsity pattern directly in the network:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"set_jac_prototype!(nw; kwargs_for_get_jac_prototype...)\nprob = ODEProblem(nw, x0, (0.0, 1.0), p0)  # automatically uses stored prototype","category":"page"},{"location":"sparsity_detection/#Example:-Handling-Conditional-Statements","page":"Sparsity Detection","title":"Example: Handling Conditional Statements","text":"","category":"section"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"A key feature of NetworkDynamics.jl's sparsity detection is the ability to handle conditional statements in component functions. This is particularly useful for ModelingToolkit-based components that use ifelse statements.","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"The conditional statements will be resolved in favor of a \"global\" sparsity pattern by replacing them temporarily with trueblock + falseblock which is then inferable by SparseConnectivityTracer.jl.","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"details: Setup code\nusing NetworkDynamics, ModelingToolkit, Graphs\nusing SparseArrays, OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\nnothing #hide","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"# Define a component with conditional logic\n@mtkmodel ValveModel begin\n    @variables begin\n        p_src(t), [description=\"source pressure\"]\n        p_dst(t), [description=\"destination pressure\"]\n        q(t), [description=\"flow through valve\"]\n    end\n    @parameters begin\n        K=1, [description=\"conductance\"]\n        active=1, [description=\"valve state\"]\n    end\n    @equations begin\n        q ~ ifelse(active > 0, K * (p_src - p_dst), 0)\n    end\nend\n\n@mtkmodel NodeModel begin\n    @variables begin\n        p(t)=1, [description=\"pressure\"]\n        q_nw(t), [description=\"network flow\"]\n    end\n    @parameters begin\n        C=1, [description=\"capacitance\"]\n        q_ext, [description=\"external flow\"]\n    end\n    @equations begin\n        C*Dt(p) ~ q_ext + q_nw\n    end\nend\nnothing # hide","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"# Create network\n@named valve = ValveModel()\n@named node = NodeModel()\n\ng = wheel_graph(10)\nv = VertexModel(node, [:q_nw], [:p])\ne = EdgeModel(valve, [:p_src], [:p_dst], AntiSymmetric([:q]))\n\nnw = Network(g, v, e)","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"# This will fail due to conditional statements\ntry\n    get_jac_prototype(nw)\ncatch\n    println(\"Error: Sparsity detection failed due to conditional statements\")\nend","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"# This works by removing conditionals\njac_prototype = get_jac_prototype(nw; remove_conditions=true)\n\n# Store the prototype directly in the network\nset_jac_prototype!(nw, jac_prototype)","category":"page"},{"location":"sparsity_detection/#Performance-Benefits","page":"Sparsity Detection","title":"Performance Benefits","text":"","category":"section"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Using sparsity detection can significantly improve solver performance, especially for large networks and stiff systems:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"using OrdinaryDiffEqRosenbrock, Chairmarks\n\n# Create a large sparse network for benchmarking\ng_large = grid([20, 20])  # 400 nodes in a 2D grid (very sparse)\nnw_large = Network(g_large, v, e)\n\n# Setup initial conditions and parameters\nusing Random # hide\nRandom.seed!(42) # hide\ns0 = NWState(nw_large)\ns0.v[:, :p] .= randn(400)  # random initial pressures\n\np0 = NWParameter(nw_large)\np0.v[:, :q_ext] .= randn(400)  # small external flow\n\nnothing #hide","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"The network is now ready for benchmarking. Let's first time the solution without sparsity detection:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"# Without sparsity detection (dense Jacobian)\nprob_dense = ODEProblem(nw_large, uflat(s0), (0.0, 1.0), pflat(p0))\n@b solve($prob_dense, Rodas5P()) seconds=1","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Now let's enable sparsity detection:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"jac = get_jac_prototype(nw_large; remove_conditions=true)","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"The pattern already shows that the Jacobian is really sparse due to the sparse network connections.","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"set_jac_prototype!(nw_large, jac)","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Now we can benchmark the sparse version:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"# Solve with sparsity detection\nprob_sparse = ODEProblem(nw_large, uflat(s0), (0.0, 1.0), pflat(p0))\n@b solve($prob_sparse, Rodas5P()) seconds=1","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"For this network, we see a substantial speedup due to the sparse solver!","category":"page"},{"location":"sparsity_detection/#Troubleshooting","page":"Sparsity Detection","title":"Troubleshooting","text":"","category":"section"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Sparsity detection fails with conditional statements:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Use remove_conditions=true to handle ifelse statements in MTK components\nFor specific problematic components, pass a vector of indices: remove_conditions=[EIndex(1), VIndex(2)]","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Detection fails for complex components:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Use dense=true to treat all components as dense (fallback option)\nFor specific components, use dense=[EIndex(1)] to treat only those components as dense","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Performance doesn't improve:","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"Sparsity detection is most beneficial for large networks (>50 nodes) with sparse connectivity\nDense networks or small systems may not see significant speedup\nEnsure you're using a solver that can exploit sparsity (e.g., Rodas5P, FBDF)","category":"page"},{"location":"sparsity_detection/","page":"Sparsity Detection","title":"Sparsity Detection","text":"The sparsity detection feature requires the SparseConnectivityTracer.jl package, which needs to be loaded manually! ","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Neurodynamic-model-of-synchronization-in-the-human-brain","page":"Directed and Weighted Graphs","title":"Neurodynamic model of synchronization in the human brain","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"This example can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Topics-covered-in-this-tutorial-include:","page":"Directed and Weighted Graphs","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"constructing a directed, weighted graph from data\nsome useful macros\nparameter handling\nstiff equations","category":"page"},{"location":"generated/directed_and_weighted_graphs/#The-FitzHugh-Nagumo-model","page":"Directed and Weighted Graphs","title":"The FitzHugh-Nagumo model","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Dynamics of spiking neurons have been described in a simplified manner by the FitzHugh-Nagumo model.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"beginaligned\nvarepsilon dot u   =  u - fracu^33 - v \ndot v  =  u + a\nendaligned","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Here u is a fast, excitatory variable corresponding to the membrane potential and v is a slower, inhibitory varibale. varepsilon is a parameter separating these time-scales, and a is a control parameter.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"In simplified models of the brain, such relaxation oscillators may be used to model individual neurons, clusters of neurons or even larger areas in the brain. The FitzHugh-Nagumo model has been widely used for studying synchronization in neuronal activity, which in turn has been connected to physiological phenomena such as epileptic seizures.","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Coupling-relaxation-oscillators","page":"Directed and Weighted Graphs","title":"Coupling relaxation oscillators","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"While different coupling schemes for FitzHugh-Nagumo oscillators have been proposed, in this tutorial we focus on coupling of the excitatory variables via electrical gap junctions, as described by the following system of equations.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"beginaligned\nvarepsilon dot u_i  =  u_i - fracu_i^33 - v_i - sigma sum_j=1^N G_ij(u_i - u_j) \ndot v_i  =   u_i + a\nendaligned","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"This is a simple diffusive coupling mediated by the difference between activation potentials in pairs of neurons. A similar coupling term was introduced in the \"getting started\" tutorial.","category":"page"},{"location":"generated/directed_and_weighted_graphs/#The-network-topology-a-brain-atlas","page":"Directed and Weighted Graphs","title":"The network topology - a brain atlas","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"In the following we will use a directed and weighted network encoding the strength and directionality of coupling between 90 different areas of the brain [Nathalie Tzourio-Mazoyer et al., 2002, Neuroimage].","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"The network weight matrix is given as a text file containing 90 lines with 90 numbers representing the coupling strength and separated by commas ,. The data can be conveniently read into a matrix with the DelimitedFiles module.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"using DelimitedFiles\nusing SimpleWeightedGraphs, Graphs\nusing NetworkDynamics\nusing OrdinaryDiffEqTsit5\nusing OrdinaryDiffEqSDIRK\nusing StableRNGs\nusing Plots\n\n# adjust the load path for your filesystem!\nfile = joinpath(pkgdir(NetworkDynamics), \"docs\", \"examples\", \"Norm_G_DTI.txt\")\nG = readdlm(file, ',', Float64, '\\n')\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"The data structure for directed, weighted graphs is provided by the package SimpleWeightedGraphs.jl which is based on Graphs.jl.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"# First we construct a weighted, directed graph\ng_weighted = SimpleWeightedDiGraph(G)\n\n# For later use we extract the edge.weight attributes\n# . is the broadcasting operator and gets the attribute :weight for every edge\nedge_weights = getfield.(collect(edges(g_weighted)), :weight)\n\n# we promote the g_weighted graph as a directed graph (weights of the edges are included in parameters)\ng_directed = SimpleDiGraph(g_weighted)\n\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Setting-up-the-ODEProblem","page":"Directed and Weighted Graphs","title":"Setting up the ODEProblem","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Defining the VertexModel and EdgeModel is similar to the example before. The macro Base.@propagate_inbounds tells the compiler to inline the function and propagate the inbounds context. For more details see the julia documentation.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Base.@propagate_inbounds function fhn_electrical_vertex!(dv, v, esum, p, t)\n    (a, ϵ) = p\n    dv[1] = v[1] - v[1]^3 / 3 - v[2] + esum[1]\n    dv[2] = (v[1] - a) * ϵ\n    nothing\nend\nvertex = VertexModel(f=fhn_electrical_vertex!, g=1, sym=[:u, :v], psym=[:a=>0.5, :ϵ=>0.05])","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Base.@propagate_inbounds function electrical_edge!(e, v_s, v_d, (w, σ), t)\n    e[1] = w * (v_s[1] - v_d[1]) * σ\n    nothing\nend\nelectricaledge = EdgeModel(g=Directed(electrical_edge!), outdim=1, psym=[:weight, :σ=>0.5])","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"fhn_network! = Network(g_directed, vertex, electricaledge)","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Since this system is a directed one with thus directed edges, the keyword argument coupling is used to set the coupling of the edges to Directed().","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Parameter-handling","page":"Directed and Weighted Graphs","title":"Parameter handling","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Some of the parameters have been declared with default values. Those default values will be used when creating the NWParameter object. We can use getindex on the parameter objects to set the missing weight values.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"p = NWParameter(fhn_network!)\np.e[1:ne(g_directed), :weight] = edge_weights\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"The initial conditions could be created similarly to the parameters as an indexable NWState obejct. Since we chose a random initial condition we initialize the flat array directly:","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"x0 = randn(StableRNG(42), dim(fhn_network!)) * 5\n\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Solving-the-system","page":"Directed and Weighted Graphs","title":"Solving the system","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Now we are ready to create an ODEProblem. Since for some choices of parameters the FitzHugh-Nagumo model is stiff (i.e. numerically unstable), we use a solver with automated stiffness detection. Such a solver switches to a more stable solver only when the solution enters a region of phase space where the problem is numerically unstable. In this case we use Tsit5 and switch to TRBDF2 when necessary. AutoTsit5 is the switching version of the Tsit5 algorithm.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"Not that we call pflat on the NWParameter object to get the flat array of parameters.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"tspan = (0.0, 200.0)\nprob  = ODEProblem(fhn_network!, x0, tspan, pflat(p))\nsol = solve(prob, AutoTsit5(TRBDF2()));\nnothing #hide","category":"page"},{"location":"generated/directed_and_weighted_graphs/#Plotting","page":"Directed and Weighted Graphs","title":"Plotting","text":"","category":"section"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"The plot of the excitatory variables shows that they synchronize for this choice of parameters.","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"plot(sol; idxs=vidxs(fhn_network!, :, :u), legend=false, ylim=(-5, 5), fmt=:png)","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"","category":"page"},{"location":"generated/directed_and_weighted_graphs/","page":"Directed and Weighted Graphs","title":"Directed and Weighted Graphs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/init_tutorial/#init-tutorial","page":"Initialization","title":"Tutorial on Stepwise Initialization of a Complex Model","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"This example demonstrates how to initialize a complex network model with both static and dynamic components. The models are closely related to the ones used in the gas network example, but greatly simplified for the sake of this tutorial. We'll create a gas network model with three nodes and pipes connecting them, and show how to:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Create static models for initialization\nFind a steady-state solution\nCreate corresponding dynamic models\nInitialize the dynamic models with the steady-state solution\nSimulate the system with dynamic behavior","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"This script can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"First, let's import the necessary packages:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"using NetworkDynamics\nusing ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/#Node-Models","page":"Initialization","title":"Node Models","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"We'll start by defining our node models using ModelingToolkit. First, let's create a template for common states and equations in all gas nodes:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel GasNode begin\n    @variables begin\n        p(t), [description=\"Pressure\"] # node output\n        q̃_nw(t), [description=\"aggregated flow from pipes into node\"] # node input\n        q̃_inj(t), [description=\"flow injected into the network\"]\n    end\n    @equations begin\n        q̃_inj ~ -q̃_nw\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Now we'll define three specific node types:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"A) A constant pressure node that forces pressure to maintain a specific value","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel ConstantPressureNode begin\n    @extend GasNode()\n    @parameters begin\n        p_set, [description=\"Constant pressure setpoint\"]\n    end\n    @equations begin\n        p ~ p_set\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"B) A static prosumer node which forces a certain flow","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"note: Fully Implicit Output\nWe need to use implicit_output(p) to handle the fully implicit pressure output. See fully implicit outputs for details.","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel StaticProsumerNode begin\n    @extend GasNode()\n    @parameters begin\n        q̃_prosumer, [description=\"flow injected by prosumer\"]\n    end\n    @equations begin\n        -q̃_nw ~ q̃_prosumer + implicit_output(p)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"C) A dynamic prosumer node with compliance, which introduces dynamic behavior to the pressure state","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel DynamicProsumerNode begin\n    @extend GasNode()\n    @parameters begin\n        q̃_prosumer, [description=\"flow injected by prosumer\"]\n        C=0.1, [description=\"Compliance\"]\n    end\n    @equations begin\n        C*D(p) ~ q̃_prosumer + q̃_nw\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"D) A pressure control node that tries to maintain a set pressure by adjusting its injection","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel PressureControlNode begin\n    @extend GasNode()\n    @parameters begin\n        p_set, [description=\"Pressure setpoint\", guess=1]\n        K_p=1, [description=\"Proportional gain\"]\n        K_i=1, [description=\"Integral gain\"]\n        C=0.1, [description=\"Compliance\"]\n    end\n    @variables begin\n        Δp(t), [description=\"Pressure error\"]\n        ξ(t), [description=\"Integral state\", guess=0]\n        q̃_prosumer(t), [description=\"flow injected by producer\"]\n    end\n    @equations begin\n        Δp ~ p_set - p\n        D(ξ) ~ Δp\n        q̃_prosumer ~ K_p*Δp + K_i*ξ\n        C*D(p) ~ q̃_prosumer + q̃_nw\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/#Edge-Models","page":"Initialization","title":"Edge Models","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Now we'll define our edge models, starting with a template for the pipe:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel GasPipe begin\n    @variables begin\n        q̃(t), [description=\"flow through pipe\"] #output\n        p_src(t), [description=\"pressure at start of pipe\"] #input\n        p_dst(t), [description=\"pressure at end of pipe\"] #input\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Next, we define a dynamic pipe with inertia (a simple delayed model):","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel DynamicPipe begin\n    @extend GasPipe()\n    @parameters begin\n        R=0.1, [description=\"Resistance\"]\n        M=0.1, [description=\"Inertia\"]\n    end\n    @equations begin\n        M*D(q̃) ~ (p_src - p_dst)/R - q̃ # some simple delayed model\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"And finally, a quasistatic pipe model for initialization purposes. This model equals the dynamic model at steady state, making it ideal for finding initial conditions:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@mtkmodel QuasistaticPipe begin\n    @extend GasPipe()\n    @parameters begin\n        R=0.1, [description=\"Resistance\"]\n    end\n    @equations begin\n        q̃ ~ (p_src - p_dst)/R\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/#Defining-a-Static-Model-for-Initialization","page":"Initialization","title":"Defining a Static Model for Initialization","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Our first step is to define a static model that we'll use to find the steady-state solution. This is a crucial step for initializing complex dynamic models.","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Step 1: Define all the components of our static model First, node 1 is our producer which will later be a controlled producer. For initialization, we use a static model:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@named v1_mod_static = ConstantPressureNode(p_set=1)\nv1_static = VertexModel(v1_mod_static, [:q̃_nw], [:p], vidx=1)\n\n# Nodes 2 and 3 are consumers. For them, we'll use static prosumer models:\n@named v2_mod_static = StaticProsumerNode(q̃_prosumer=-0.6) # consumer\nv2_static = VertexModel(v2_mod_static, [:q̃_nw], [:p], vidx=2)\n\n@named v3_mod_static = StaticProsumerNode(q̃_prosumer=-0.4) # consumer\nv3_static = VertexModel(v3_mod_static, [:q̃_nw], [:p], vidx=3)\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Now we define the static pipe models connecting our nodes:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@named p_mod_static = QuasistaticPipe()\np12_static = EdgeModel(p_mod_static, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=2)\np13_static = EdgeModel(p_mod_static, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=3)\np23_static = EdgeModel(p_mod_static, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=2, dst=3)\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Assemble all components into a static network:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"nw_static = Network([v1_static, v2_static, v3_static], [p12_static, p13_static, p23_static])","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Create an initial guess for the steady state and modify it with reasonable values:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"u_static_guess = NWState(nw_static)\nu_static_guess.v[2, :p] = 1.0\nu_static_guess.v[3, :p] = 1.0\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Find the steady-state solution using our initial guess:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"u_static = find_fixpoint(nw_static, u_static_guess)","category":"page"},{"location":"generated/init_tutorial/#Defining-a-Dynamic-Model","page":"Initialization","title":"Defining a Dynamic Model","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Now we'll define our dynamic model using more complex components:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@named v1_mod_dyn = PressureControlNode()\nv1_dyn = VertexModel(v1_mod_dyn, [:q̃_nw], [:p], vidx=1)\n\n@named v2_mod_dyn = DynamicProsumerNode(q̃_prosumer=-0.6)\nv2_dyn = VertexModel(v2_mod_dyn, [:q̃_nw], [:p], vidx=2)\n\n@named v3_mod_dyn = DynamicProsumerNode(q̃_prosumer=-0.4)\nv3_dyn = VertexModel(v3_mod_dyn, [:q̃_nw], [:p], vidx=3)\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Create dynamic pipe models with inertia:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@named p_mod_dyn = DynamicPipe()\np12_dyn = EdgeModel(p_mod_dyn, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=2)\np13_dyn = EdgeModel(p_mod_dyn, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=1, dst=3)\np23_dyn = EdgeModel(p_mod_dyn, [:p_src], [:p_dst], AntiSymmetric([:q̃]), src=2, dst=3)\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Assemble the dynamic network:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"nw_dyn = Network([v1_dyn, v2_dyn, v3_dyn], [p12_dyn, p13_dyn, p23_dyn])","category":"page"},{"location":"generated/init_tutorial/#Initializing-the-Dynamic-Model-with-the-Static-Solution","page":"Initialization","title":"Initializing the Dynamic Model with the Static Solution","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Now comes the important part: we need to initialize the dynamic model with the results from the static model. To do so, we need to make use of two functions:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"interface_values: Extracts all interface values (inputs and outputs) from a network state\ninitialize_componentwise!: Initializes all components in a network one by one","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"First, we extract all interface values from our static solution:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"interface_vals = interface_values(u_static)","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Next, we initialize the dynamic model using these interface values as defaults:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"u0_dyn = initialize_componentwise!(nw_dyn, default_overrides=interface_vals, verbose=true)","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Internally, this function uses initialize_component! on every single component. For each component, it overwrites the defaults to be consistent with the interface values of the static model. Therefore, we ensure that the dynamic model is initialized near the steady state of the static model.","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"We can inspect individual components if needed:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"dump_initial_state(nw_dyn[VIndex(1)])\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Let's verify that our initialization is correct by checking that the derivatives are close to zero:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"du = ones(dim(nw_dyn))\nnw_dyn(du, uflat(u0_dyn), pflat(u0_dyn), 0.0)\nextrema(du .- zeros(dim(nw_dyn))) # very close to zero, confirming we have a steady state!","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Alternatively, we can used the isfixpoint function to check if the state is a fixpoint:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"@assert isfixpoint(nw_dyn, u0_dyn)\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/#Simulating-the-Dynamic-Model","page":"Initialization","title":"Simulating the Dynamic Model","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"With our properly initialized model, we can now simulate the system to observe its behavior. To make the simulation more interesting, we'll introduce a disturbance to see how the system responds from its steady state.","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"We'll use a callback to increase consumer demand at a specific time. For more information on callbacks, see the documentation on Callbacks.","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"affect = ComponentAffect([], [:q̃_prosumer]) do u, p, ctx\n    @info \"Increase consumer demand at t=$(ctx.t)\"\n    p[:q̃_prosumer] -= 0.1\nend\ncb = PresetTimeComponentCallback([1.0], affect)\nset_callback!(nw_dyn[VIndex(2)], cb) # attach disturbance to second node\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Create and solve the ODE problem with the callback. Note that we're using the flat representation of our initialized state (via uflat and pflat) as input to the ODE solver:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"prob = ODEProblem(nw_dyn, copy(uflat(u0_dyn)), (0, 7), copy(pflat(u0_dyn));\n    callback=get_callbacks(nw_dyn))\nsol = solve(prob, Tsit5())\nnothing #hide","category":"page"},{"location":"generated/init_tutorial/#Visualizing-the-Results","page":"Initialization","title":"Visualizing the Results","text":"","category":"section"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Finally, let's visualize the results of our simulation. The plots show how our gas network responds to the increased consumer demand at t=1:","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"Pressure at nodes: We see a pressure drop at all nodes after the disturbance before the pressure is stabilized by the controller.\nInjection by producer: Node 1 increases its injection to compensate for the higher demand.\nConsumption by consumers: The solid lines show the actual flows at nodes 2 and 3, while the dashed lines show the set consumer demands. At t=1, we see the step change in consumer demand at node 2.\nFlows through pipes: Shows how the flows in all pipes adjust to the new demand pattern.","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"let\n    fig = Figure(size=(1000,1000))\n    ax = Axis(fig[1, 1]; title=\"Pressure at nodes\")\n    for i in 1:3\n        lines!(ax, sol; idxs=VIndex(i, :p), label=\"Node $i\", color=Cycled(i))\n    end\n\n    ax = Axis(fig[2, 1]; title=\"Injection by producer\")\n    lines!(ax, sol; idxs=VIndex(1, :q̃_inj), label=\"Node 1\", color=Cycled(1))\n\n    ax = Axis(fig[3, 1]; title=\"Consumption by consumers\")\n    for i in 2:3\n        lines!(ax, sol; idxs=@obsex(-1*VIndex(i, :q̃_inj)), label=\"Node $i\", color=Cycled(i))\n        lines!(ax, sol; idxs=@obsex(-1*VIndex(i, :q̃_prosumer)), label=\"Node $i\", linestyle=:dash, color=Cycled(i))\n    end\n\n    ax = Axis(fig[4, 1]; title=\"Flows through pipes\")\n    for i in 1:3\n        lines!(ax, sol; idxs=@obsex(abs(EIndex(i, :q̃))), label=\"Pipe $i\", color=Cycled(i))\n    end\n\n    fig\nend","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"","category":"page"},{"location":"generated/init_tutorial/","page":"Initialization","title":"Initialization","text":"This page was generated using Literate.jl.","category":"page"},{"location":"inspector/#Interactive-Solution-Inspection","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"","category":"section"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"An interactive solution inspection tool based on WGLMakie and Bonito is provided through the helper package NetworkDynamicsInspector.","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"First, we need to define the system we want to inspect.","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"details: Define some network, simulate it and get a solution object\nusing NetworkDynamics\nusing NetworkDynamicsInspector\nusing NetworkDynamicsInspector: NetworkDynamicsInspector as NDI #hide\nusing Electron # hide\nusing OrdinaryDiffEqTsit5\nusing Graphs\n\ninclude(joinpath(pkgdir(NetworkDynamics), \"test\", \"ComponentLibrary.jl\"))\nfunction get_sol(;limit=1.0)\n    g = SimpleGraph([0 1 1 0 1;\n                    1 0 1 1 0;\n                    1 1 0 1 0;\n                    0 1 1 0 1;\n                    1 0 0 1 0])\n    vs = [Lib.swing_mtk() for _ in 1:5];\n    set_default!(vs[1], :Pmech, -1)\n    set_default!(vs[2], :Pmech, 1.5)\n    set_default!(vs[3], :Pmech, -1)\n    set_default!(vs[4], :Pmech, -1)\n    set_default!(vs[5], :Pmech, 1.5)\n    ls = [Lib.line_mtk() for _ in 1:7];\n    nw = Network(g, vs, ls)\n    sinit = NWState(nw)\n    s0 = find_fixpoint(nw)\n    set_defaults!(nw, s0)\n\n    # set_position!(vs[1], (0.0, 0.0))\n    set_marker!(vs[1], :dtriangle)\n    set_marker!(vs[2], :utriangle)\n    set_marker!(vs[3], :dtriangle)\n    set_marker!(vs[4], :dtriangle)\n    set_marker!(vs[5], :utriangle)\n\n    cond = ComponentCondition([:P, :₋P, :srcθ], [:limit, :K]) do u, p, t\n        abs(u[:P]) - p[:limit]\n    end\n    affect = ComponentAffect([],[:active]) do u, p, ctx\n        @info \"Trip line $(ctx.eidx) between $(ctx.src) and $(ctx.dst) at t=$(ctx.t)\"\n        p[:active] = 0\n    end\n    cb = ContinuousComponentCallback(cond, affect)\n    set_callback!.(ls, Ref(cb))\n\n    tripfirst = PresetTimeComponentCallback(1.0, affect) # reuse the same affect\n    add_callback!(nw[EIndex(5)], tripfirst)\n\n    nwcb = NetworkDynamics.get_callbacks(nw);\n    s0 = NWState(nw)\n    s0.p.e[:, :limit] .= limit\n\n    prob = ODEProblem(nw, uflat(s0), (0,6), copy(pflat(s0)), callback=nwcb)\n    sol = solve(prob, Tsit5())\nend\n\nsol = get_sol()\nnothing #hide","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"Now that we have an ODESolution sol, we can call inspect to open the inspector GUI. The docstring provides several options to customize how the app is displayed.","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"inspect(sol; reset=true)\nsleep(1) # hide\ndefine_timeseries!([ # hide\n    (; selcomp=[EIndex(i) for i in 1:7], states=[:P]) # hide\n]) # hide\nsleep(3) # hide\nNDI.save_electron_screenshot(\"screenshot.png\") #hide","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"(Image: screenshot)","category":"page"},{"location":"inspector/#Programmatic-Access-and-GUI-State-Manipulation","page":"Interactive Solution Inspection","title":"Programmatic Access and GUI State Manipulation","text":"","category":"section"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"Internally, the NetworkDynamicsInspector maintains a global reference to an AppState object. This AppState reflects changes made to the GUI by the user and can also be modified programmatically.","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"See the NetworkDynamicsInspector API for a complete list of available functions. A good starting point is the dump_app_state function, which helps you recreate a GUI state that was previously configured manually.","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"Let's say we've adjusted the AppState to include an additional time series plot for the node states.","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"set_state!(; t=1.75) #hide\ndefine_timeseries!([ #hide\n    (; selcomp=[VIndex(i) for i in 1:5], states=[:θ, :ω]) #hide\n    (; selcomp=[EIndex(i) for i in 1:7], states=[:P]) #hide\n]) #hide\nsleep(3) #hide\nnothing #hide","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"We can dump the code which helps us to recreate the app state:","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"dump_app_state()","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"Now we can use this code to recreate the app state even though we've reseted it.","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"buf = IOBuffer() #hide\ndump_app_state(buf) #hide\ncode = String(take!(buf)) #hide\ninspect(sol; reset=true)\nsleep(1) #hide\neval(Meta.parse(\"begin;\"*code*\"end;\")) #hide\nsleep(3) #hide\nNDI.save_electron_screenshot(\"screenshot2.png\") #hide\n\"copy-paste and execute code returned by `dump_app_state` here\" #hide","category":"page"},{"location":"inspector/","page":"Interactive Solution Inspection","title":"Interactive Solution Inspection","text":"(Image: screenshot)","category":"page"},{"location":"initialization/#initialization-guide","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initialization is a critical step in simulation dynamical systems on networks, involving finding valid initial conditions that satisfy the system's constraints. NetworkDynamics provides several layers of initialization tools, from individual component initialization to full network initialization.","category":"page"},{"location":"initialization/#Initialization-Hierarchy","page":"Initialization","title":"Initialization Hierarchy","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"NetworkDynamics offers a tiered approach to initialization:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Full-System Initialization: Finding a steady state for the entire network at once\nComponent-wise Network Initialization: Initializing each component individually while respecting network coupling\nSingle Component Initialization: Finding valid internal states for a single component","category":"page"},{"location":"initialization/#Full-System-Initialization","page":"Initialization","title":"Full-System Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Full system initialization aims to find a fixed point/steady state of the entire system simultaneously.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"To do so, you can use find_fixpoint, which creates a SteadyStateProblem of the whole network and attempts to solve it:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Create a network\nnw = Network(vertices, edges)\n\n# Find a fixed point for the entire system\nstate = find_fixpoint(nw)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This approach works well for simpler systems but may face convergence challenges for complex networks with many interacting components.","category":"page"},{"location":"initialization/#Component-wise-Network-Initialization","page":"Initialization","title":"Component-wise Network Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"For more complex networks, a component-by-component approach is often more robust. NetworkDynamics provides initialize_componentwise and initialize_componentwise! functions that:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initialize each component individually\nVerify the combined solution works for the entire network","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Initialize each component in the network individually\nstate = initialize_componentwise(nw)\n\n# Or using the mutating version that updates component metadata\nstate = initialize_componentwise!(nw)","category":"page"},{"location":"initialization/#Two-Step-Initialization-Pattern","page":"Initialization","title":"Two-Step Initialization Pattern","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"A common initialization pattern for complex networks involves:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Solving a simplified static model first\nUsing those results to initialize a more complex dynamic model","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# 1. Solve a static/simplified model\nstatic_model = create_static_network(...)\nstatic_state = find_fixpoint(static_model)\n\n# 2. Extract interface values\ninterface_vals = interface_values(static_state)\n\n# 3. Use them to initialize a dynamic model\ndynamic_model = create_dynamic_network(...)\ndyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"See the Tutorial on Initialization for a complete example of this approach.","category":"page"},{"location":"initialization/#Single-Component-Initialization","page":"Initialization","title":"Single Component Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"At the lowest level, NetworkDynamics provides tools for initializing individual components based on their internal dynamics and interface constraints.","category":"page"},{"location":"initialization/#Mathematical-Meaning","page":"Initialization","title":"Mathematical Meaning","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"According to the Mathematical Model of NetworkDynamics.jl, a component forms an \"input-output-system\" of the form","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"beginaligned\nMfracmathrmdmathrmdtx = f(x i p t)\ny = g(x i p t)\nendaligned","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"where x are the internal states, i are the inputs, y are the outputs, and p are the parameters. To initialize at a fixed point, we require the RHS to be zero,","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"beginaligned\n0 = f(x i p t)\n0 = g(x i p t) - y\nendaligned","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"forming a nonlinear least squares problem for the residual. Each variable in x, i, y and p is either considered free or fixed with respect to the nonlinear problem stated above. Symbols that have a default value (see Metadata) are considered fixed. All other symbols are considered free and must provide a guess value as an initial starting point for the nonlinear solver.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The defaults and guesses can be either obtained from the Metadata directly or provided as arguments.","category":"page"},{"location":"initialization/#Non-mutating-vs-Mutating-Initialization","page":"Initialization","title":"Non-mutating vs Mutating Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"NetworkDynamics provides two approaches for component-wise initialization:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Non-mutating approach using initialize_component: Returns a dictionary of values without modifying the component\nMutating approach using initialize_component!: Directly updates the component metadata with initialization results","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Both options take guesses and defaults from metadata by default; however, it is possible to specify otherwise (see method documentation).","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The non-mutating version initialize_component is useful when you don't want to modify the metadata, for a more \"stateless\" approach:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Get initialization results as a dictionary\ninit_state = initialize_component(vf; default_overrides=Dict(:x => 4))","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"It will return a Dict{Symbol,Float64} which contains values for all symbols in the model.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The mutating version initialize_component! directly updates the component's metadata with initialization results:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"initialize_component!(vf; verbose=true) # set `init` metadata for free symbols","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The same pattern applies at the network level with initialize_componentwise and initialize_componentwise!.","category":"page"},{"location":"initialization/#Example","page":"Initialization","title":"Example","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Let's consider the following example of a Swing-equation generator model.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"using NetworkDynamics, ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as Dt\n\n@mtkmodel Swing begin\n    @variables begin\n        u_r(t)=1, [description=\"bus d-voltage\", output=true]\n        u_i(t)=0.1, [description=\"bus q-voltage\", output=true]\n        i_r(t)=1, [description=\"bus d-current (flowing into bus)\", input=true]\n        i_i(t)=0.1, [description=\"bus d-current (flowing into bus)\", input=true]\n        ω(t), [guess=0.0, description=\"Rotor frequency\"]\n        θ(t), [guess=0.0, description=\"Rotor angle\"]\n        Pel(t), [guess=1, description=\"Electrical Power injected into the grid\"]\n    end\n    @parameters begin\n        M=0.005, [description=\"Inertia\"]\n        D=0.1, [description=\"Damping\"]\n        V, [guess=1.0, description=\"Voltage magnitude\"]\n        ω_ref=0, [description=\"Reference frequency\"]\n        Pm, [guess=0.1,description=\"Mechanical Power\"]\n    end\n    @equations begin\n        Dt(θ) ~ ω - ω_ref\n        Dt(ω) ~ 1/M * (Pm - D*ω - Pel)\n        Pel ~ u_r*i_r + u_i*i_i\n        u_r ~ V*cos(θ)\n        u_i ~ V*sin(θ)\n    end\nend\nsys = Swing(name=:swing)\nvf = VertexModel(sys, [:i_r, :i_i], [:u_r, :u_i])","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"You can see in the provided metadata that we've set default values for the node outputs u_r, u_i, the node inputs i_r, i_i, and most parameters. For some states and parameters, we've only provided a guess rather than a default. Variables that only have guesses are considered \"tunable\" for the initialization algorithm.","category":"page"},{"location":"initialization/#Using-the-non-mutating-initialization","page":"Initialization","title":"Using the non-mutating initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"We can use initialize_component to get the initialized values without modifying the component:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"init_values = initialize_component(vf; default_overrides=Dict(:u_i=>0), verbose=true)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The code returns a dictionary which pins all the variables of the component to some values which satisfy the initialization condition.","category":"page"},{"location":"initialization/#Using-the-mutating-initialization","page":"Initialization","title":"Using the mutating initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Alternatively, we can make use of the mutating version to store the results of the initialization in the metadata:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"initialize_component!(vf; verbose=true)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Which stored the initialisation results as :init metadata of the component model vf:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"get_init(vf, :V) # get the value of :V at initialized state","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"It is possible to inspect initial states (works also for observed symbols) using get_initial_state. As a quick test we can ensure that the angle indeed matches the voltage angle:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"get_initial_state(vf, :θ) ≈ atan(get_initial_state(vf, :u_i), get_initial_state(vf, :u_r))","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"You can print out the whole state using dump_initial_state.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"dump_initial_state(vf)","category":"page"},{"location":"initialization/#Advanced-Component-Initialization:-Formulas-and-Constraints","page":"Initialization","title":"Advanced Component Initialization: Formulas and Constraints","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"NetworkDynamics provides two complementary mechanisms for customizing component initialization beyond the basic defaults and guesses: initialization formulas and initialization constraints. These operate at different stages of the initialization pipeline and serve distinct purposes. Both can help to resolve underconstrained initialization problems: while init formulas reduce the number of free variables (by setting additional defaults), init constraints increase the number of equations.","category":"page"},{"location":"initialization/#Initialization-Formulas-(InitFormulas)","page":"Initialization","title":"Initialization Formulas (InitFormulas)","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initialization formulas act early in the initialization pipeline to compute and set default values based on other known values. They are particularly useful for deriving dependent quantities or ensuring consistency between related variables.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Each formula can only reference symbols that are already available - it cannot use intermediate values computed within the same formula.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Basic Usage: Use the @initformula macro to define formulas with assignment syntax:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Example: Set voltage magnitude and electrical power based on voltage components\nvoltage_formula = @initformula begin\n    :V = sqrt(:u_r^2 + :u_i^2)     # Voltage magnitude from components\n    :Pel = :u_r * :i_r + :u_i * :i_i # Electrical power calculation\nend\nnothing #hide","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Applying Formulas: Formulas can be either added to the metadata of components (set_initformula!, add_initformula!) or passed as additional_initformula to the initialize_component[!] functions.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Dependency Resolution: When applying multiple separate formulas, NetworkDynamics automatically sorts them topologically to ensure correct evaluation order.","category":"page"},{"location":"initialization/#Initialization-Constraints-(InitConstraints)","page":"Initialization","title":"Initialization Constraints (InitConstraints)","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initialization constraints add equations to the nonlinear system that must be satisfied during the initialization solve. Unlike formulas, they don't directly set values but impose mathematical relationships.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Basic Usage: Use the @initconstraint macro to define constraint equations:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Example: Constrain electrical power and voltage magnitude\npower_constraint = @initconstraint begin\n    :Pel - 1.0                        # Electrical power must equal 1.0\n    sqrt(:u_r^2 + :u_i^2) - 1.0      # Voltage magnitude must equal 1.0\nend\nnothing #hide","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Applying Constraints: Constraints can be either added to the metadata of components (set_initconstraint!, add_initconstraint!) or passed as additional_initconstraint to the initialize_component[!] functions.","category":"page"},{"location":"initialization/#Analysing-Fixpoints","page":"Initialization","title":"Analysing Fixpoints","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"In order to analyse fixpoints NetworkDynamis provides the functions isfixpoint, is_linear_stable and jacobian_eigenvals.","category":"page"},{"location":"generated/heterogeneous_system/#Modeling-a-heterogeneous-system","page":"Heterogeneous Systems","title":"Modeling a heterogeneous system","text":"","category":"section"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"This example can be downloaded as a normal Julia script here.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"One of the main purposes of NetworkDynamics.jl is to facilitate the modeling systems whose components can differ in their parameters as well as their dynamics. These are known as Coupled systems with heterogeneities.","category":"page"},{"location":"generated/heterogeneous_system/#Heterogeneous-parameters","page":"Heterogeneous Systems","title":"Heterogeneous parameters","text":"","category":"section"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"We start by setting up a simple system of Kuramoto oscillators.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"using NetworkDynamics, OrdinaryDiffEqTsit5, Plots, Graphs\n\nN = 8\ng = watts_strogatz(N, 2, 0) # ring network\n\nfunction kuramoto_edge!(e, θ_s, θ_d, (K,), t)\n    e[1] = K * sin(θ_s[1] - θ_d[1])\n    nothing\nend\nedge! = EdgeModel(g=AntiSymmetric(kuramoto_edge!), outdim=1, psym=[:K=>3])","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"function kuramoto_vertex!(dθ, θ, esum, (ω0,), t)\n    dθ[1] = ω0 + esum[1]\n    nothing\nend\nvertex! = VertexModel(f=kuramoto_vertex!, g=StateMask(1:1), sym=[:θ], psym=[:ω0], name=:kuramoto)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"nw = Network(g, vertex!, edge!)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"To assign parameters, we can create a NWParameter object based on the nw definition. This parameter object will be pre-filled with the default parameters.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"p = NWParameter(nw)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"To set the vertex parameters, we can use indexing of the p.v field:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"ω = collect(1:N) ./ N\nω .-= sum(ω) / N\np.v[:, :ω0] = ω\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"Here, the index pairing :, :ω is used to index state ω for all node indices.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"The parameter object contains information about the network structure. For the actual problem definition we need to throw away this wrapper and use the flat-vector representation of the parameters pflat(p). Note that pflat(p)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"Similarily, we could use NWState(nw) to create an indexable wrapper of the initial state. However in this case we can also fill create the flat state array manually:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"x0 = collect(1:N) ./ N\nx0 .-= sum(x0) ./ N\ntspan = (0.0, 10.0)\nprob = ODEProblem(nw, x0, tspan, pflat(p))\nsol = solve(prob, Tsit5())\nplot(sol; ylabel=\"θ\", fmt=:png)","category":"page"},{"location":"generated/heterogeneous_system/#Heterogeneous-dynamics","page":"Heterogeneous Systems","title":"Heterogeneous dynamics","text":"","category":"section"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"Two paradigmatic modifications of the node model above are static nodes and nodes with inertia. A static node has no internal states and instead fixes the variable at a constant value.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"function static_g(out, u, p, t)\n    out[1] = p[1]\n    nothing\nend\nstatic! = VertexModel(g=static_g, outsym=[:θ], psym=[:θfix => ω[1]], name=:static)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"But wait! NetworkDynamics classified this as PureFeedForward, because it cannot distinguish between the function signatures","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"g(out, u, p, t)    # PureFeedForward\ng(out, ins, p, t)  # NoFeedForward","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"and since dim(u)=0 it wrongfully assumes that the latter is meant. We can overwrite the classification by passing the ff keyword:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"static! = VertexModel(g=static_g, outsym=[:θ], psym=[:θfix => ω[1]], ff=NoFeedForward(), name=:static)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"A Kuramoto model with inertia consists of two internal variables leading to more complicated (and for many applications more realistic) local dynamics.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"function kuramoto_inertia!(dv, v, esum, (ω0,), t)\n    dv[1] = v[2]\n    dv[2] = ω0 - 1.0 * v[2] + esum[1]\n    nothing\nend\n\ninertia! = VertexModel(f=kuramoto_inertia!, g=1:1, sym=[:θ, :ω], psym=[:ω0], name=:inertia)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"Since now we model a system with heterogeneous node dynamics we can no longer straightforwardly pass a single VertexModel to the Network constructor but instead have to hand over an Array.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"vertex_array    = VertexModel[vertex! for i in 1:N]\nvertex_array[1] = static!\nvertex_array[5] = inertia! # index should correspond to the node's index in the graph\nnw_hetero! = Network(g, vertex_array, edge!)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"Now we have to take a bit more care with defining initial conditions and parameters.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"First, we can generate a NWState object based on the nw_hetero! object which will be populated with the default values.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"state = NWState(nw_hetero!)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"The node with inertia is two-dimensional, hence we need to specify two initial conditions. For the first dimension we keep the initial conditions from above and insert! another one into x0 at the correct index.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"For the θ states we will use the same initial conditins as before:","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"state.v[2:8,:θ] = x0[2:8]\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"We're still missing one initial condition: the second variable ω of the 5th vertex.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"state.v[5,:ω] = 5\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"The NWState object also contains a parameter object accessible via state.p. The edge parameters are already filled with default values. The vertex parameters can be copied from our old parmeter object p.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"state.p.v[2:8, :ω0] = p.v[2:8, :ω0]\nnothing #hide","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"For the problem construction, we need to convert the nested stuctures to flat arrays using the uflat and pflat methods.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"prob_hetero = ODEProblem(nw_hetero!, uflat(state), tspan, pflat(state))\nsol_hetero = solve(prob_hetero, Tsit5());\nnothing #hide\nplot(sol_hetero)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"For clarity we plot only the variables referring to the oscillator's angle θ and color them according to their type.","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"colors = map(vertex_array) do vertexf\n    if vertexf.name == :kuramoto\n        colorant\"lightseagreen\"\n    elseif vertexf.name == :static\n        colorant\"orange\"\n    elseif vertexf.name == :inertia\n        colorant\"darkred\"\n    end\nend\n\nplot(sol_hetero; ylabel=\"θ\", idxs=vidxs(1:8,:θ), lc=colors', fmt=:png)","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"","category":"page"},{"location":"generated/heterogeneous_system/","page":"Heterogeneous Systems","title":"Heterogeneous Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Component models such as VertexModel and EdgeModel can store metadata. We distinguish between two kinds of metadata: component metadata and symbol metadata.","category":"page"},{"location":"metadata/#Component-Metadata","page":"Metadata","title":"Component Metadata","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Component metadata is a Dict{Symbol,Any} attached to each component to store various information. Use metadata to retrieve the full dict.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"To access the data, you can use the methods has_metadata, get_metadata, set_metadata! and delete_metadata! (see Component Metadata API).","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Special metadata:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":":graphelement: optional field to specialize the graphelement for each component (vidx) for vertices, (;src,dst) named tuple of either vertex names or vertex indices for edges. Has special accessors has_/get_/set_graphelement.\n:callback: optional field to define callback functions on the component level. See Callbacks and Callbacks API for more information.\n:position: Store a tuple (x, y) with position of the node for plotting. Has special accessors has_/get_/set_position.\n:marker: Store a Symbol for the graph plot. Possible values could be :circle, :rect, :utriangle, :cross, :diamond, :dtriangle, :pentagon, :xcross or anything which works as a marker keyword argument in Makie.\n:initconstraint: Store additional initialization constrains. Has special has_/get_/set_/delete_initconstraint accessors. See Initialization for further","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"details.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":":initformula: Similar to initconstraint, but is a straight forward explicit mapping to initialize some variables.","category":"page"},{"location":"metadata/#Symbol-Metadata","page":"Metadata","title":"Symbol Metadata","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Each component stores symbol metadata. The symbol metadata is a Dict{Symbol, Dict{Symbol, Any}} which stores a metadata dict per symbol. Symbols are everything that appears in sym, psym, obssym and insym.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"To access the data, you can use the methods has_metadata, get_metadata, set_metadata! and delete_metadata! (see Per Symbol Metadata API). These functions also support pattern matching using String or Regex patterns to match symbol names, making it easier to work with symbols containing special characters or when you only know part of the symbol name.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Special cases for symbol metadata are:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"default: Stores default values for states/parameters. In initialization, those are considered fixed.\nguess: Stores a guess for a state/parameter which needs to be solved during initialization (\"free\" variables).\nbounds: Stores bounds for variables/parameters\ninit: Stores the solution of the \"free\" variables, this is rarely set manually but instead when calling initialize_component!.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"For those, there are special functions has_*, get_*, set_*!, delete_*! and strip_*!. The strip_*! functions remove all metadata of a specific type from all symbols in a component. See Per Symbol Metadata API.","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"These are closely aligned with the metadata use in ModelingToolkit. They are automatically copied from the System if you use MTK models to create NetworkDynamics models.","category":"page"},{"location":"metadata/#Metadata-Utils","page":"Metadata","title":"Metadata Utils","text":"","category":"section"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"Accessing metadata (especially defaults) of states and parameters is a very common task. We provide several helper methods to do so. Please check out their docstrings for further explanation:","category":"page"},{"location":"metadata/","page":"Metadata","title":"Metadata","text":"dump_state\ndump_initial_state\nget_initial_state\nfree_u - find variables without default values\nfree_p - find parameters without default values\ndescribe_vertices (needs DataFrames.jl loaded)\ndescribe_edges (needs DataFrames.jl loaded)","category":"page"},{"location":"symbolic_indexing/#Symbolic-Indexing","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"By using SciML's SymbolicIndexingInterface.jl, ND.jl  provides numerous methods to access and change variables and parameters.","category":"page"},{"location":"symbolic_indexing/#Provide-Symbol-Names","page":"Symbolic Indexing","title":"Provide Symbol Names","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"When constructing component models, you can pass symbolic names using the sym and psym keywords.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"using NetworkDynamics, Graphs, OrdinaryDiffEqTsit5, Plots\nfunction _edgef!(e, v_s, v_d, (K,), t)\n    e .= K * (v_s[1] .- v_d[1])\nend\nedgef = EdgeModel(;g=AntiSymmetric(_edgef!), outsym=[:flow], psym=[:K=>1])","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Here we create a static diffusion edge with suitable variable and parameter names. Similarly, we define the diffusion vertex with symbolic names.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"function _vertexf!(dv, v, esum, p, t)\n    dv[1] = esum[1]\nend\nvertexf = VertexModel(f=_vertexf!, g=1, sym=[:storage])","category":"page"},{"location":"symbolic_indexing/#Fundamental-Symbolic-Indices","page":"Symbolic Indexing","title":"Fundamental Symbolic Indices","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"The default types for this access are the types VIndex, EIndex, VPIndex and EPIndex. Each of those symbolic indices consists of 2 elements: a reference to the network component and a reference to the  symbol within that component. As such: ","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"VIndex(2, :x) refers to variable with symbolic name :x in vertex number 2.\nEPIndex(4, 2) refers to the second parameter of the edge component for the 4th edge.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"details: Setup code to make following examples work\ng = wheel_graph(5)\nnw = Network(g, vertexf, edgef)\ns = NWState(nw)\ns.v[:,:storage] .= randn(5)\nprob = ODEProblem(nw, uflat(s), (0,2), pflat(s))\nsol = solve(prob, Tsit5()) \nnothing #hide","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Those fundamental indices can be used in a lot of scenarios. Most importantly you can use them to","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"sol(sol.t; idxs=VIndex(1, :storage))   # extract timeseries out of a solution object\nplot(sol; idxs=[VIndex(1, :storage), VIndex(5,:storage)]) # plot storage of two nodes","category":"page"},{"location":"symbolic_indexing/#Generate-Symbolic-Indices","page":"Symbolic Indexing","title":"Generate Symbolic Indices","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Often, you need many individual symbolic indices. To achieve this you can use the helper methods vidxs,  eidxs, vpidxs and epidxs. With their help you can generate arrays of symbolic indices:","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"vidxs(nw, :, :storage) # get variable \"storage\" for all vertices","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"plot(sol; idxs=vidxs(nw, :, :storage))","category":"page"},{"location":"symbolic_indexing/#NWState-and-NWParameter-Objects","page":"Symbolic Indexing","title":"NWState and NWParameter Objects","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Internally, both state and parameters of a Network are represented using flat arrays. To access the state or parameters of a network, you can use the NWState and NWParameter objects.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"p = NWParameter(nw)","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"creates a NWParameter object for the network nw. It essentially creates a new flat parameter array and fills it with the default parameter values defined in the component. The parameters in the NWParameter object can be accessed using symbolic indices.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"p[EPIndex(5, :K)] = 2.0 # change the parameter K of the 5th edge\nnothing #hide","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Similarly, you can create a NWState object for the network nw using","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"s = NWState(nw)","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"No default values were provided in the network components, so the state array is filled with NaN values.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"s[VIndex(:, :storage)] .= randn(5) # set the (initial) storage for all vertices \ns #hide","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"For both NWState and NWParameter objects, there is a more convenient way to access the variables and parameters.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"@assert s.v[1, :storage] == s[VIndex(1, :storage)] # s.v -> access vertex states\n@assert s.e[1, :flow]    == s[EIndex(1, :flow)]    # s.e -> access edge states\n@assert s.p.e[1,:K]      == p[EPIndex(1, :K)]      # s.p -> access parameters","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"The NWState and NWParameter objects are mutable, thus changing them will also change the underlying wrapped flat arrays. You can always access the flat representations by calling uflat and pflat. The ordering of elements  in these flat arrays corresponds exactly to the order returned by variable_symbols and  parameter_symbols respectively.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"note: Note\nThe NWState and NWParameter wrappers can be constructed from various objects. For example, within a callback you might construct p = NWParameter(integrator) to then change the parameters of ","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"the network within the callback.","category":"page"},{"location":"symbolic_indexing/#Observables","page":"Symbolic Indexing","title":"Observables","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Sometimes, the \"states\" you're interested in aren't really states in the DAE sense but rather algebraic derivations from DAE states, parameters, and time – in accordance with the naming in  the SciML ecosystem, these values are called Observables.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"A prime example of Observables are edge/vertex-outputs, such as the flow in the edge model defined above. It is also possible to define additional Observables manually by using the obssym and obsf keyword on the EdgeModel/VertexModel constructors. When building models using ModelingToolkit, the reduced algebraic states will be preserved automatically as observables.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Observables can be accessed like any other state. For example, the flows in the network don't show up in the state array  but can be accessed in all the ways discussed above.  For example:","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"plot(sol; idxs=eidxs(nw, :, :flow))","category":"page"},{"location":"symbolic_indexing/#Derived-ObservableExpressions-using-@obsex","page":"Symbolic Indexing","title":"Derived ObservableExpressions using @obsex","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Sometimes it is useful to plot or observe simple derived quantities. For that, one can use the @obsex macro to define simple derived quantities.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"For example, we can directly plot the storage difference with respect to storage of node 1.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"plot(sol; idxs=@obsex(vidxs(nw,:,:storage) .- VIndex(1,:storage)))","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Other examples include calculating the magnitude and argument of complex values that are modeled using real and  imaginary parts.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"@obsex mag = sqrt(VIndex(1, :u_r)^2 + VIndex(2, :u_i)^2)","category":"page"},{"location":"symbolic_indexing/#Low-level-accessors-for-flat-array-indices","page":"Symbolic Indexing","title":"Low-level accessors for flat array indices","text":"","category":"section"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Sometimes, you want to know the indices of your states in the flat arrays. For that, you can use the low-level methods defined in SymbolicIndexingInterface.jl:","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"using NetworkDynamics: SII # SII = SymbolicIndexingInterface\nidxs = SII.variable_index(nw, vidxs(1:2, :storage))","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"uflat(s)[idxs] == s.v[1:2, :storage]","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"Analogous with parmeters:","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"idxs = SII.parameter_index(nw, eidxs(1:2, :K))\npflat(s)[idxs] == s.p.e[1:2, :K]","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"If you need the symbols of all the states/parameters in order, you can use:","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"SII.variable_symbols(nw)","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"and","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"SII.parameter_symbols(nw)","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"These functions return the symbolic indices in the exact order they appear in the flat arrays returned by uflat and pflat, making them essential when you need to map between flat array indices and symbolic representations.","category":"page"},{"location":"symbolic_indexing/","page":"Symbolic Indexing","title":"Symbolic Indexing","text":"All above examples also work on other \"symbolic containers\", e.g. SII.variable_symbols(::NWState).","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The following functions are designed for public use.","category":"page"},{"location":"API/#Network-Construction-API","page":"API","title":"Network Construction API","text":"","category":"section"},{"location":"API/#NetworkDynamics.Network","page":"API","title":"NetworkDynamics.Network","text":"Network([g,] vertexf, edgef; kwarg...)\n\nConstruct a Network object from a graph g and edge and component models vertexf and edgef.\n\nArguments:\n\ng::AbstractGraph: The graph on which the network is defined.  Optional, can be ommittet if all component models have a defined graphelement.  See vidx and src/dst keywors for VertexModel and EdgeModel constructors respectively.\nvertexm:  A single VertexModel or a vector of VertexModel objects.  The order of the vertex models must mirror the order of the vertices(g) iterator.\nedgem: A single EdgeModel or a vector of EdgeModel objects.  The order of the edge models must mirror the order of the edges(g) iterator.\n\nOptional keyword arguments:\n\nexecution=SequentialExecution{true}():  Execution model of the network. E.g. SequentialExecution, KAExecution, PolyesterExecution or ThreadedExecution.\naggregator=execution isa SequentialExecution ? SequentialAggregator(+) : PolyesterAggregator(+):  Aggregation function applied to the edge models. E.g. SequentialAggregator, PolyesterAggregator, ThreadedAggregator, SparseAggregator.\ncheck_graphelement=true:  Check if the graphelement metadata is consistent with the graph.\ndealias=false  Check if the components alias eachother and create copies if necessary.  This is necessary if the same component model is referenced in multiple places in the Network but you want to  dynamicially asign metadata, such as initialization information to specific instances.\nverbose=false:  Show additional information during construction.\n\n\n\n\n\nNetwork(nw::Network; g, vertexm, edgem, kwargs...)\n\nRebuild the Network with same graph and vertex/edge models but possibly different kwargs.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.get_graph","page":"API","title":"NetworkDynamics.get_graph","text":"get_graph(nw::Network)\n\nExtracts the underlying graph of the network.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.dim-Tuple{Network}","page":"API","title":"NetworkDynamics.dim","text":"dim(nw::Network)\n\nReturns the number of dynamic states in the network, corresponts to the length of the flat state vector.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.pdim-Tuple{Network}","page":"API","title":"NetworkDynamics.pdim","text":"pdim(nw::Network)\n\nReturns the number of parameters in the network, corresponts to the length of the flat parameter vector.\n\n\n\n\n\n","category":"method"},{"location":"API/#Component-Models","page":"API","title":"Component Models","text":"","category":"section"},{"location":"API/#NetworkDynamics.VertexModel-Tuple{}","page":"API","title":"NetworkDynamics.VertexModel","text":"VertexModel(; kwargs...)\n\nBuild a VertexModel according to the keyword arguments.\n\nMain Arguments:\n\nf=nothing: Dynamic function of the component. Can be nothing if dim is 0.\ng: Output function of the component. Usefull helpers: StateMask\nsym/dim: Symbolic names of the states. If dim is provided, sym is set automaticially.\noutsym/outdim:  Symbolic names of the outputs. If outdim is provided, outsym is set automaticially.  Can be infered automaticially if g isa StateMask.\npsym/pdim=0: Symbolic names of the parameters. Ifpdimis provided,psym` is set automaticially.\nmass_matrix=I: Mass matrix of component. Can be a vector v and is then interpreted as Diagonal(v).\nname=dim>0 ? :VertexM : :StaticVertexM: Name of the component.\n\nOptional Arguments:\n\ninsym/indim: Symbolic names of the inputs. If indim is provided, insym is set automaticially.\nvidx: Index of the vertex in the graph, enables graphless constructor.\nff: FeedForwardType of component. Will be typically infered from g automaticially.\nobssym/obsf: Define additional \"observable\" states.\nsymmetadata/metadata: Provide prefilled metadata dictionaries.\nextin=nothing:  Define \"external\" inputs for the model with Network indices, i.e. extin=[VIndex(7,:x), ..].  Those inputs will be provided as another input vector f(x, in, extin, p, t) and g(y, x, in, extin, p, t).\n\nAll Symbol arguments can be used to set default values, i.e. psym=[:K=>1, :p].\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.EdgeModel-Tuple{}","page":"API","title":"NetworkDynamics.EdgeModel","text":"EdgeModel(; kwargs...)\n\nBuild a EdgeModel according to the keyword arguments.\n\nMain Arguments:\n\nf=nothing: Dynamic function of the component. Can be nothing if dim is 0.\ng: Output function of the component. Usefull helpers: AntiSymmetric, Symmetric, Fiducial, Directed and StateMask.\nsym/dim: Symbolic names of the states. If dim is provided, sym is set automaticially.\noutsym/outdim:  Symbolic names of the outputs. If outdim is provided, outsym is set automaticially.  In general, outsym for edges isa named tuple (; src, dst). However, depending on the g function,  it might be enough to provide a single vector or even nothing (e.g. AntiSymmetric(StateMask(1:2))).  See Building EdgeModels for examples.\npsym/pdim=0: Symbolic names of the parameters. Ifpdimis provided,psym` is set automaticially.\nmass_matrix=I: Mass matrix of component. Can be a vector v and is then interpreted as Diagonal(v).\nname=dim>0 ? :EdgeM : :StaticEdgeM: Name of the component.\n\nOptional Arguments:\n\ninsym/indim: Symbolic names of the inputs. If indim is provided, insym is set automaticially.  For edges, insym is a named tuple (; src, dst). If give as vector tuple is created automaticially.\nsrc/dst: Index or name of the vertices at src and dst end. Enables graphless constructor.\nff: FeedForwardType of component. Will be typically infered from g automaticially.\nobssym/obsf: Define additional \"observable\" states.\nsymmetadata/metadata: Provide prefilled metadata dictionaries.\nextin=nothing:  Define \"external\" inputs for the model with Network indices, i.e. extin=[VIndex(7,:x), ..].  Those inputs will be provided as another input vector f(x, insrc, indst, extin, p, t) and g(ysrc, ydst, x, insrc, indst, extin, p, t).\n\nAll Symbol arguments can be used to set default values, i.e. psym=[:K=>1, :p].\n\n\n\n\n\n","category":"method"},{"location":"API/#Component-Models-with-MTK","page":"API","title":"Component Models with MTK","text":"","category":"section"},{"location":"API/#NetworkDynamics.VertexModel-Tuple{System, Any, Any}","page":"API","title":"NetworkDynamics.VertexModel","text":"VertexModel(sys::System, inputs, outputs;\n            verbose=false, name=getname(sys), extin=nothing, ff_to_constraint=true, kwargs...)\n\nCreate a VertexModel object from a given System created with ModelingToolkit. You need to provide 2 lists of symbolic names (Symbol or Vector{Symbols}):\n\ninputs: names of variables in you equation representing the aggregated edge states\noutputs: names of variables in you equation representing the node output\n\nAdditional kw arguments:\n\nname: Set name of the component model. Will be lifted from the System name.\nextin=nothing: Provide external inputs as pairs, i.e. extin=[:extvar => VIndex(1, :a)]  will bound the variable extvar(t) in the equations to the state a of the first vertex.\nff_to_constraint=true: Controls, whether output transformations g which depend on inputs should be transformed into constraints. Defaults to true since ND.jl does not handle vertices with FF yet.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.EdgeModel-Tuple{System, Vararg{Any, 4}}","page":"API","title":"NetworkDynamics.EdgeModel","text":"EdgeModel(sys::System, srcin, dstin, srcout, dstout;\n          verbose=false, name=getname(sys), extin=nothing, ff_to_constraint=false, kwargs...)\n\nCreate a EdgeModel object from a given System created with ModelingToolkit. You need to provide 4 lists of symbolic names (Symbol or Vector{Symbols}):\n\nsrcin: names of variables in you equation representing the node state at the source\ndstin: names of variables in you equation representing the node state at the destination\nsrcout: names of variables in you equation representing the output at the source\ndstout: names of variables in you equation representing the output at the destination\n\nAdditional kw arguments:\n\nname: Set name of the component model. Will be lifted from the System name.\nextin=nothing: Provide external inputs as pairs, i.e. extin=[:extvar => VIndex(1, :a)]  will bound the variable extvar(t) in the equations to the state a of the first vertex.\nff_to_constraint=false: Controls, whether output transformations g which depend on inputs should be transformed into constraints.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.EdgeModel-Tuple{System, Any, Any, Any}","page":"API","title":"NetworkDynamics.EdgeModel","text":"EdgeModel(sys::System, srcin, dstin, AntiSymmetric(dstout); kwargs...)\n\nCreate a EdgeModel object from a given System created with ModelingToolkit for single sided models.\n\nHere you only need to provide one list of output symbols: dstout. To make it clear how to handle the single-sided output definition, you must wrap the symbol vector in\n\nAntiSymmetric(dstout),\nSymmetric(dstout), or\nDirected(dstout).\n\nAdditional kwargs are the same as for the double-sided EdgeModel MTK constructor.\n\n\n\n\n\n","category":"method"},{"location":"API/#Output-Function-Helpers/Wrappers","page":"API","title":"Output Function Helpers/Wrappers","text":"","category":"section"},{"location":"API/#NetworkDynamics.StateMask","page":"API","title":"NetworkDynamics.StateMask","text":"StateMask(i::AbstractArray)\nStateMaks(i::Number)\n\nA StateMask is a predefined output function. It can be used to define the output of a component model by picking from the internal state.\n\nI.e. g=StateMask(2:3) in a vertex function will output the internal states 2 and 3. In many contexts, StateMasks can be constructed implicitly by just providing the indices, e.g. g=1:2.\n\nFor EdgeModel this needs to be combined with a Directed, Symmetric, AntiSymmetric or Fiducial coupling, e.g. g=Fiducial(1:2, 3:4) forwards states 1:2 to dst and states 3:4 to src.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.Symmetric","page":"API","title":"NetworkDynamics.Symmetric","text":"Symmetric(g)\n\nWraps a single-sided output function g turns it into a double sided output function which applies\n\ny_dst = g(...)\ny_src = y_dst\n\ng can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also AntiSymmetric, Directed, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.AntiSymmetric","page":"API","title":"NetworkDynamics.AntiSymmetric","text":"AntiSymmetric(g_dst)\n\nWraps a single-sided output function g_dst turns it into a double sided output function which applies\n\ny_dst = g_dst(...)\ny_src = -y_dst\n\ng_dst can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also Symmetric, Directed, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.Directed","page":"API","title":"NetworkDynamics.Directed","text":"Directed(g_dst)\n\nWraps a single-sided output function g_dst turns it into a double sided output function which applies\n\ny_dst = g_dst(...)\n\nWith Directed there is no output for the src side. g_dst can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also AntiSymmetric, Symmetric, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.Fiducial","page":"API","title":"NetworkDynamics.Fiducial","text":"Fiducial(g_src, g_dst)\n\nWraps two single-sided output function g_src and g_dst and turns them into a double sided output function which applies\n\ny_dst = g_src(...)\ny_src = g_dst(...)\n\ng can be a Number/AbstractArray to impicitly wrap the corresponding StateMask.\n\nSee also AntiSymmetric, Directed, Fiducial and StateMask.\n\n\n\n\n\n","category":"type"},{"location":"API/#Accessors-for-Component-Properties","page":"API","title":"Accessors for Component Properties","text":"","category":"section"},{"location":"API/#NetworkDynamics.fftype","page":"API","title":"NetworkDynamics.fftype","text":"fftype(x)\n\nRetrieve the feed forward trait of x.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.dim-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"NetworkDynamics.dim","text":"dim(c::ComponentModel)::Int\n\nRetrieve the dimension of the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.sym","page":"API","title":"NetworkDynamics.sym","text":"sym(c::ComponentModel)::Vector{Symbol}\n\nRetrieve the symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.outdim","page":"API","title":"NetworkDynamics.outdim","text":"outdim(c::VertexModel)::Int\noutdim(c::EdgeModel)::@NamedTuple(src::Int, dst::Int)\n\nRetrieve the output dimension of the component\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.outsym","page":"API","title":"NetworkDynamics.outsym","text":"outsym(c::VertexModel)::Vector{Symbol}    outsym(c::EdgeModel)::@NamedTuple{src::Vector{Symbol}, dst::Vector{Symbol}}\n\nRetrieve the output symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.pdim-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"NetworkDynamics.pdim","text":"pdim(c::ComponentModel)::Int\n\nRetrieve the parameter dimension of the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.psym","page":"API","title":"NetworkDynamics.psym","text":"psym(c::ComponentModel)::Vector{Symbol}\n\nRetrieve the parameter symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.obssym","page":"API","title":"NetworkDynamics.obssym","text":"obssym(c::ComponentModel)::Vector{Symbol}\n\nRetrieve the observation symbols of the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.hasinsym","page":"API","title":"NetworkDynamics.hasinsym","text":"hasinsym(c::ComponentModel)\n\nChecks if the optioan field insym is present in the component model.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.insym","page":"API","title":"NetworkDynamics.insym","text":"insym(c::VertexModel)::Vector{Symbol}\ninsym(c::EdgeModel)::@NamedTuple{src::Vector{Symbol}, dst::Vector{Symbol}}\n\nMusst be called after hasinsym/hasindim returned true. Gives the insym vector(s). For vertex model just a single vector, for edges it returns a named tuple (; src, dst) with two symbol vectors.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.hasindim","page":"API","title":"NetworkDynamics.hasindim","text":"hasindim(c::ComponentModel)\n\nChecks if the optioan field insym is present in the component model.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.indim","page":"API","title":"NetworkDynamics.indim","text":"indim(c::VertexModel)::Int\nindim(c::EdgeModel)::@NamedTuple{src::Int,dst::Int}\n\nMusst be called after hasinsym/hasindim returned true. Gives the input dimension(s).\n\n\n\n\n\n","category":"function"},{"location":"API/#FeedForwardType-Traits","page":"API","title":"FeedForwardType-Traits","text":"","category":"section"},{"location":"API/#NetworkDynamics.FeedForwardType","page":"API","title":"NetworkDynamics.FeedForwardType","text":"abstract type FeedForwardType end\n\nAbstract supertype for the FeedForwardType traits.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PureFeedForward","page":"API","title":"NetworkDynamics.PureFeedForward","text":"PureFeedForward <: FeedForwardType\n\nTrait for component output functions g that have pure feed forward behavior (do not depend on x):\n\ng!(outs..., ins..., p, t)\n\nSee also FeedForward, NoFeedForward and PureStateMap.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.FeedForward","page":"API","title":"NetworkDynamics.FeedForward","text":"FeedForward <: FeedForwardType\n\nTrait for component output functions g that have feed forward behavior. May depend on everything:\n\ng!(outs..., x, ins..., p, t)\n\nSee also PureFeedForward, NoFeedForward and PureStateMap.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.NoFeedForward","page":"API","title":"NetworkDynamics.NoFeedForward","text":"NoFeedForward <: FeedForwardType\n\nTrait for component output functions g that have no feed forward behavior (do not depend on inputs):\n\ng!(outs..., x, p, t)\n\nSee also PureFeedForward, FeedForward and PureStateMap.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PureStateMap","page":"API","title":"NetworkDynamics.PureStateMap","text":"PureStateMap <: FeedForwardType\n\nTrait for component output functions g that only depends on state:\n\ng!(outs..., x)\n\nSee also PureFeedForward, FeedForward and NoFeedForward.\n\n\n\n\n\n","category":"type"},{"location":"API/#Symbolic-Indexing-API","page":"API","title":"Symbolic Indexing API","text":"","category":"section"},{"location":"API/#Network-Parameter-Object","page":"API","title":"Network Parameter Object","text":"","category":"section"},{"location":"API/#NetworkDynamics.NWParameter","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(nw_or_nw_wraper, pflat)\n\nIndexable wrapper for flat parameter array pflat. Needs Network or wrapper of Network, e.g. ODEProblem.\n\np = NWParameter(nw)\np.v[idx, :sym] # get parameter :sym of vertex idx\np.e[idx, :sym] # get parameter :sym of edge idx\np[s::Union{VPIndex, EPIndex}] # get parameter for specific index\n\nGet flat array representation using pflat. The order of parameters in the flat representation corresponds to the order given by parameter_symbols.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.NWParameter-Tuple{Any}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(nw_or_nw_wraper;\n            ptype=Vector{Float64}, pfill=filltype(ptype), default=true)\n\nCreates \"empty\" NWParameter object for the Network/Wrapper nw with flat type ptype. The array will be prefilled with pfill (defaults to NaN).\n\nIf default=true the default parameter values attached to the network components will be loaded.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWParameter-Tuple{NWParameter}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(p::NWParameter; ptype=typeof(p.pflat))\n\nCreate NWParameter based on other parameter object, just convert type.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWParameter-Tuple{SciMLBase.DEIntegrator}","page":"API","title":"NetworkDynamics.NWParameter","text":"NWParameter(int::SciMLBase.DEIntegrator)\n\nCreate NWParameter object from integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.pflat","page":"API","title":"NetworkDynamics.pflat","text":"pflat(p::NWParameter)\npflat(s::NWState)\n\nRetrieve the wrapped flat array representation of the parameters. The order of parameters in this flat representation corresponds exactly to the order given by parameter_symbols.\n\n\n\n\n\n","category":"function"},{"location":"API/#SymbolicIndexingInterface.parameter_symbols","page":"API","title":"SymbolicIndexingInterface.parameter_symbols","text":"SymbolicIndexingInterface.parameter_symbols(nw::Network)\n\nReturns a vector of all symbolic network indices which in the same order as the flat parameter vector.\n\nSee also: NWParameter, NWState, pflat.\n\n\n\n\n\n","category":"function"},{"location":"API/#Network-State-Object","page":"API","title":"Network State Object","text":"","category":"section"},{"location":"API/#NetworkDynamics.NWState","page":"API","title":"NetworkDynamics.NWState","text":"NWState(nw_or_nw_wrapper, uflat, [pflat], [t])\n\nIndexable wrapper for flat state & parameter array. Needs Network or wrapper of Network, e.g. ODEProblem.\n\ns = NWState(nw)\ns.v[idx, :sym] # get state :sym of vertex idx\ns.e[idx, :sym] # get state :sym of edge idx\ns.p.v[idx, :sym] # get parameter :sym of vertex idx\ns.p.e[idx, :sym] # get parameter :sym of edge idx\ns[s::Union{VIndex, EIndex, EPIndex, VPIndex}] # get parameter for specific index\n\nGet flat array representation using uflat and pflat. The order of states in the flat representation corresponds to the order given by variable_symbols, and the order of parameters corresponds to parameter_symbols.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.NWState-Tuple{Any}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(nw_or_nw_wrapper;\n        utype=Vector{Float64}, ufill=filltype(utype),\n        ptype=Vector{Float64}, pfill=filltype(ptype), default=true)\n\nCreates \"empty\" NWState object for the Network/Wrapper nw with flat types utype & ptype. The arrays will be prefilled with ufill and pfill respectively (defaults to NaN).\n\nIf default=true the default state & parameter values attached to the network components will be loaded.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWState-Tuple{NWState}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(p::NWState; utype=typeof(uflat(s)), ptype=typeof(pflat(s)))\n\nCreate NWState based on other state object, just convert types.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWState-Tuple{NWParameter}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(p::NWParameter; utype=Vector{Float64}, ufill=filltype(utype), default=true)\n\nCreate NWState based on existing NWParameter object.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.NWState-Tuple{SciMLBase.DEIntegrator}","page":"API","title":"NetworkDynamics.NWState","text":"NWState(int::SciMLBase.DEIntegrator)\n\nCreate NWState object from integrator.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.uflat","page":"API","title":"NetworkDynamics.uflat","text":"uflat(s::NWState)\n\nRetrieve the wrapped flat array representation of the state. The order of states in this flat representation corresponds exactly to the order given by variable_symbols.\n\n\n\n\n\n","category":"function"},{"location":"API/#SymbolicIndexingInterface.variable_symbols","page":"API","title":"SymbolicIndexingInterface.variable_symbols","text":"SymbolicIndexingInterface.variable_symbols(nw::Network)\n\nReturns a vector of all symbolic network indices which in the same order as the flat state vector.\n\nSee also: NWState, uflat.\n\n\n\n\n\n","category":"function"},{"location":"API/#Symbolic-Indices","page":"API","title":"Symbolic Indices","text":"","category":"section"},{"location":"API/#NetworkDynamics.VIndex","page":"API","title":"NetworkDynamics.VIndex","text":"VIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = VIndex(comp, sub)\n\nA symbolic index for a vertex state variable.\n\ncomp: the component index, either int, symbol or a collection\nsub: the subindex, either int, symbol or a collection of those.\n\nVIndex(1, :P)      # vertex 1, variable :P\nVIndex(1:5, 1)     # first state of vertices 1 to 5\nVIndex(7, (:x,:y)) # states :x and :y of vertex 7\nVIndex(2)          # references the second vertex model\nVIndex(:a)         # references vertex with unique name :a\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWState, NWParameter or ODESolution.\n\nSee also: EIndex, VPIndex, EPIndex\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.EIndex","page":"API","title":"NetworkDynamics.EIndex","text":"EIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = EIndex(comp, sub)\n\nA symbolic index for an edge state variable.\n\ncomp: the component index, either int, symbol, pair or a collection\nsub: the subindex, either int, symbol or a collection of those.\n\nEIndex(1, :P)      # edge 1, variable :P\nEIndex(1:5, 1)     # first state of edges 1 to 5\nEIndex(7, (:x,:y)) # states :x and :y of edge 7\nEIndex(2)          # references the second edge model\nEIndex(1=>2)       # references edge from v1 to v2\nEIndex(:a=>:b)     # references edge from (uniquely named) vertex :a to :b\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWState, NWParameter or ODESolution.\n\nSee also: VIndex, VPIndex, EPIndex\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.VPIndex","page":"API","title":"NetworkDynamics.VPIndex","text":"VPIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = VPIndex(comp, sub)\n\nA symbolic index into the parameter a vertex:\n\ncomp: the component index, either int, symbol or a collection\nsub: the subindex, either int, symbol or a collection of those.\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWParameter or ODEProblem.\n\nSee also: EPIndex, VIndex, EIndex\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.EPIndex","page":"API","title":"NetworkDynamics.EPIndex","text":"EPIndex{C,S} <: SymbolicStateIndex{C,S}\nidx = VEIndex(comp, sub)\n\nA symbolic index into the parameter of an edge:\n\ncomp: the component index, either int, symbol, pair or a collection\nsub: the subindex, either int, symbol or a collection of those.\n\nCan be used to index into objects supporting the SymbolicIndexingInterface, e.g. NWParameter or ODEProblem.\n\nSee also: VPIndex, VIndex, EIndex\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.@obsex","page":"API","title":"NetworkDynamics.@obsex","text":"@obsex([name =] expression)\n\nDefine observable expressions, which are simple combinations of knonw states/parameters/observables. @obsex(...) returns an ObservableExpression which can be used as an symbolic index. This is mainly intended for quick plotting or export of common \"derived\" variables, such as the argument of a 2-component complex state. For example:\n\nsol(t; idxs=@obsex(arg = atan(VIndex(1,:u_i), VIndex(1,:u_r))]\nsol(t; idxs=@obsex(δrel = VIndex(1,:δ) - VIndex(2,:δ)))\n\n\n\n\n\n","category":"macro"},{"location":"API/#Index-generators","page":"API","title":"Index generators","text":"","category":"section"},{"location":"API/#NetworkDynamics.vidxs","page":"API","title":"NetworkDynamics.vidxs","text":"vidxs([inpr], components=:, variables=:) :: Vector{VIndex}\n\nGenerate vector of symbolic indexes for vertices.\n\ninpr: Only needed for name matching or : access. Can be Network, sol, prob, ...\ncomponents: Number/Vector, :, Symbol (name matches), String/Regex (name contains)\nvariables: Symbol/Number/Vector, :, String/Regex (all sym containing)\n\nExamples:\n\nvidxs(nw)                 # all vertex state indices\nvidxs(1:2, :u)            # [VIndex(1, :u), VIndex(2, :u)]\nvidxs(nw, :, [:u, :v])    # [VIndex(i, :u), VIndex(i, :v) for i in 1:nv(nw)]\nvidxs(nw, \"ODEVertex\", :) # all symbols of all vertices with name containing \"ODEVertex\"\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.eidxs","page":"API","title":"NetworkDynamics.eidxs","text":"vidxs([inpr], components=:, variables=:) :: Vector{EIndex}\n\nGenerate vector of symbolic indexes for edges.\n\ninpr: Only needed for name matching or : access. Can be Network, sol, prob, ...\ncomponents: Number/Vector, :, Symbol (name matches), String/Regex (name contains)\nvariables: Symbol/Number/Vector, :, String/Regex (all sym containing)\n\nExamples:\n\neidxs(nw)                # all edge state indices\neidxs(1:2, :u)           # [EIndex(1, :u), EIndex(2, :u)]\neidxs(nw, :, [:u, :v])   # [EIndex(i, :u), EIndex(i, :v) for i in 1:ne(nw)]\neidxs(nw, \"FlowEdge\", :) # all symbols of all edges with name containing \"FlowEdge\"\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.vpidxs","page":"API","title":"NetworkDynamics.vpidxs","text":"vpidxs([inpr], components=:, variables=:) :: Vector{VPIndex}\n\nGenerate vector of symbolic indexes for parameters. See vidxs for more information.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.epidxs","page":"API","title":"NetworkDynamics.epidxs","text":"epidxs([inpr], components=:, variables=:) :: Vector{EPIndex}\n\nGenerate vector of symbolic indexes for parameters. See eidxs for more information.\n\n\n\n\n\n","category":"function"},{"location":"API/#Metadata-API","page":"API","title":"Metadata API","text":"","category":"section"},{"location":"API/#Component-Metadata-API","page":"API","title":"Component Metadata API","text":"","category":"section"},{"location":"API/#NetworkDynamics.metadata","page":"API","title":"NetworkDynamics.metadata","text":"metadata(c::ComponentModel)\n\nRetrieve metadata object for the component.\n\nSee also metadata\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}","page":"API","title":"NetworkDynamics.has_metadata","text":"has_metadata(c::ComponentModel, key::Symbol)\nhas_metadata(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)\n\nChecks if metadata key is present for the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol}","page":"API","title":"NetworkDynamics.get_metadata","text":"get_metadata(c::ComponentModel, key::Symbol)\nget_metadata(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)\n\nRetrieves the metadata key for the component.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Any}","page":"API","title":"NetworkDynamics.set_metadata!","text":"set_metadata!(c::ComponentModel, key::Symbol, value)\nset_metadata!(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol, value)\n\nSets the metadata key for the component to value.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol}","page":"API","title":"NetworkDynamics.delete_metadata!","text":"delete_metadata!(c::ComponentModel, key::Symbol)\ndelete_metadata!(nw::Network, idx::Union{VIndex,EIndex}, key::Symbol)\n\nRemoves the component-wide metadata key from the component model, or from a component referenced by idx in a network. Returns true if the metadata existed and was removed, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.has_graphelement","page":"API","title":"NetworkDynamics.has_graphelement","text":"has_graphelement(c::ComponentModel)\nhas_graphelement(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the edge or vertex function has the graphelement metadata.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_graphelement","page":"API","title":"NetworkDynamics.get_graphelement","text":"get_graphelement(c::EdgeModel)::@NamedTuple{src::T, dst::T}\nget_graphelement(c::VertexModel)::Int\nget_graphelement(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the graphelement metadata for the component model. For edges this returns a named tuple (;src, dst) where both are either integers (vertex index) or symbols (vertex name).\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_graphelement!","page":"API","title":"NetworkDynamics.set_graphelement!","text":"set_graphelement!(c::EdgeModel, nt::@NamedTuple{src::T, dst::T})\nset_graphelement!(c::EdgeModel, p::Pair)\nset_graphelement!(c::VertexModel, vidx::Int)\nset_graphelement!(nw::Network, idx::Union{VIndex,EIndex}, value)\n\nSets the graphelement metadata for the component. For edges this takes a named tuple (;src, dst) where both are either integer (vertex index) or symbol (vertex name). For vertices it takes a single integer vidx.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_position","page":"API","title":"NetworkDynamics.has_position","text":"has_position(v::VertexModel)\nhas_position(nw::Network, vidx::VIndex)\n\nChecks if vertex v has position metadata.\n\nSee also: get_position, set_position!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_position","page":"API","title":"NetworkDynamics.get_position","text":"get_position(v::VertexModel)\nget_position(nw::Network, vidx::VIndex)\n\nReturns the position metadata of vertex v. Might error if not present.\n\nSee also: has_position, set_position!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_position!","page":"API","title":"NetworkDynamics.set_position!","text":"set_position!(v::VertexModel, val)\nset_position!(nw::Network, vidx::VIndex, val)\n\nSets the position metadata of vertex v to val.\n\nSee also: has_position, get_position.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_marker","page":"API","title":"NetworkDynamics.has_marker","text":"has_marker(v::VertexModel)\nhas_marker(nw::Network, vidx::VIndex)\n\nChecks if vertex v has marker metadata.\n\nSee also: get_marker, set_marker!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_marker","page":"API","title":"NetworkDynamics.get_marker","text":"get_marker(v::VertexModel)\nget_marker(nw::Network, vidx::VIndex)\n\nReturns the marker metadata of vertex v. Might error if not present.\n\nSee also: has_marker, set_marker!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_marker!","page":"API","title":"NetworkDynamics.set_marker!","text":"set_marker!(v::VertexModel, val)\nset_marker!(nw::Network, vidx::VIndex, val)\n\nSets the marker metadata of vertex v to val.\n\nSee also: has_marker, get_marker.\n\n\n\n\n\n","category":"function"},{"location":"API/#Per-Symbol-Metadata-API","page":"API","title":"Per-Symbol Metadata API","text":"","category":"section"},{"location":"API/#NetworkDynamics.symmetadata","page":"API","title":"NetworkDynamics.symmetadata","text":"symmetadata(c::ComponentModel)::Dict{Symbol,Dict{Symbol,Any}}\n\nRetrieve the metadata dictionary for the symbols. Keys are the names of the symbols as they appear in sym, psym, obssym and insym.\n\nSee also symmetadata\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}","page":"API","title":"NetworkDynamics.get_metadata","text":"get_metadata(c::ComponentModel, sym::Symbol, key::Symbol)\nget_metadata(nw::Network, sni::SymbolicIndex, key::Symbol)\n\nRetrieves the metadata key for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can also be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nThrows an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.has_metadata-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}","page":"API","title":"NetworkDynamics.has_metadata","text":"has_metadata(c::ComponentModel, sym::Symbol, key::Symbol)\nhas_metadata(nw::Network, sni::SymbolicIndex, key::Symbol)\n\nChecks if symbol metadata key is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can also be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nThrows an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.set_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol, Any}","page":"API","title":"NetworkDynamics.set_metadata!","text":"set_metadata!(c::ComponentModel, sym::Symbol, key::Symbol, value)\nset_metadata!(nw::Network, sni::SymbolicIndex, key::Symbol, value)\nset_metadata!(c::ComponentModel, sym::Symbol, pair::Pair)\nset_metadata!(nw::Network, sni::SymbolicIndex, pair::Pair)\n\nSets the metadata key for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nFor component models, you can also use a String or Regex pattern to match symbol names:\n\nString patterns use substring matching (e.g., \"δ\" matches machine₊δ)\nRegex patterns use full regex matching (e.g., r\"P$\" matches symbols ending with \"P\")\n\nThis will error if there are none or multiple matches.\n\nIf the pattern matches multiple symbols, an error is thrown. Use a more specific pattern. Throws an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.delete_metadata!-Tuple{NetworkDynamics.ComponentModel, Symbol, Symbol}","page":"API","title":"NetworkDynamics.delete_metadata!","text":"delete_metadata!(c::ComponentModel, sym::Symbol, key::Symbol)\ndelete_metadata!(nw::Network, sni::SymbolicIndex, key::Symbol)\n\nRemoves the metadata key for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can also be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nReturns true if the metadata existed and was removed, false otherwise. Throws an error if the symbol does not exist in the component model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.strip_metadata!","page":"API","title":"NetworkDynamics.strip_metadata!","text":"strip_metadata!(c::ComponentModel, key::Symbol)\n\nRemove all metadata of type key from the component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_default","page":"API","title":"NetworkDynamics.has_default","text":"has_default(c::ComponentModel, sym::Symbol)\nhas_default(nw::Network, sni::SymbolicIndex)\n\nChecks if a default value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_default, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_default","page":"API","title":"NetworkDynamics.get_default","text":"get_default(c::ComponentModel, sym::Symbol)\nget_default(nw::Network, sni::SymbolicIndex)\n\nReturns the default value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_default, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_default!","page":"API","title":"NetworkDynamics.set_default!","text":"set_default!(c::ComponentModel, sym::Symbol, value)\nset_default!(nw::Network, sni::SymbolicIndex, value)\n\nSets the default value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_default, get_default.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_default!","page":"API","title":"NetworkDynamics.delete_default!","text":"delete_default!(c::ComponentModel, sym::Symbol)\ndelete_default!(nw::Network, sni::SymbolicIndex)\n\nRemoves the default value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_default, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_defaults!","page":"API","title":"NetworkDynamics.strip_defaults!","text":"strip_default!(c::ComponentModel)\nstrip_default!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all default values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_default!, set_default!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_guess","page":"API","title":"NetworkDynamics.has_guess","text":"has_guess(c::ComponentModel, sym::Symbol)\nhas_guess(nw::Network, sni::SymbolicIndex)\n\nChecks if a guess value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_guess, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_guess","page":"API","title":"NetworkDynamics.get_guess","text":"get_guess(c::ComponentModel, sym::Symbol)\nget_guess(nw::Network, sni::SymbolicIndex)\n\nReturns the guess value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_guess, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_guess!","page":"API","title":"NetworkDynamics.set_guess!","text":"set_guess!(c::ComponentModel, sym::Symbol, value)\nset_guess!(nw::Network, sni::SymbolicIndex, value)\n\nSets the guess value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_guess, get_guess.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_guess!","page":"API","title":"NetworkDynamics.delete_guess!","text":"delete_guess!(c::ComponentModel, sym::Symbol)\ndelete_guess!(nw::Network, sni::SymbolicIndex)\n\nRemoves the guess value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_guess, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_guesses!","page":"API","title":"NetworkDynamics.strip_guesses!","text":"strip_guess!(c::ComponentModel)\nstrip_guess!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all guess values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_guess!, set_guess!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_init","page":"API","title":"NetworkDynamics.has_init","text":"has_init(c::ComponentModel, sym::Symbol)\nhas_init(nw::Network, sni::SymbolicIndex)\n\nChecks if a init value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_init, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_init","page":"API","title":"NetworkDynamics.get_init","text":"get_init(c::ComponentModel, sym::Symbol)\nget_init(nw::Network, sni::SymbolicIndex)\n\nReturns the init value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_init, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_init!","page":"API","title":"NetworkDynamics.set_init!","text":"set_init!(c::ComponentModel, sym::Symbol, value)\nset_init!(nw::Network, sni::SymbolicIndex, value)\n\nSets the init value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_init, get_init.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_init!","page":"API","title":"NetworkDynamics.delete_init!","text":"delete_init!(c::ComponentModel, sym::Symbol)\ndelete_init!(nw::Network, sni::SymbolicIndex)\n\nRemoves the init value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_init, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_inits!","page":"API","title":"NetworkDynamics.strip_inits!","text":"strip_init!(c::ComponentModel)\nstrip_init!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all init values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_init!, set_init!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_bounds","page":"API","title":"NetworkDynamics.has_bounds","text":"has_bounds(c::ComponentModel, sym::Symbol)\nhas_bounds(nw::Network, sni::SymbolicIndex)\n\nChecks if a bounds value is present for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also get_bounds, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_bounds","page":"API","title":"NetworkDynamics.get_bounds","text":"get_bounds(c::ComponentModel, sym::Symbol)\nget_bounds(nw::Network, sni::SymbolicIndex)\n\nReturns the bounds value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_bounds, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_bounds!","page":"API","title":"NetworkDynamics.set_bounds!","text":"set_bounds!(c::ComponentModel, sym::Symbol, value)\nset_bounds!(nw::Network, sni::SymbolicIndex, value)\n\nSets the bounds value for symbol sym to value in a component model, or for a symbol referenced by sni in a network.\n\nIf value is nothing or missing, the metadata is removed.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_bounds, get_bounds.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_bounds!","page":"API","title":"NetworkDynamics.delete_bounds!","text":"delete_bounds!(c::ComponentModel, sym::Symbol)\ndelete_bounds!(nw::Network, sni::SymbolicIndex)\n\nRemoves the bounds value for symbol sym in a component model, or for a symbol referenced by sni in a network.\n\nsym can be a String or Regex, to address the only symbol containing the pattern, see set_metadata! for details.\n\nSee also has_bounds, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.strip_bounds!","page":"API","title":"NetworkDynamics.strip_bounds!","text":"strip_bounds!(c::ComponentModel)\nstrip_bounds!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all bounds values from a component model, or from a component referenced by idx in a network.\n\nSee also delete_bounds!, set_bounds!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_defaults!","page":"API","title":"NetworkDynamics.set_defaults!","text":"set_defaults!(nw::Network, s::NWState)\n\nSet the default values of the network to the values of the given state. Can be used to \"store\" the found fixpoint in the network metadata.\n\nValues of missing, nothing or NaN are ignored.\n\n\n\n\n\nset_defaults!(nw::Network, p::NWParameter)\n\nSet the parameter default values of the network to the values of the given parameter object.\n\nValues of missing, nothing or NaN are ignored.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_interface_defaults!","page":"API","title":"NetworkDynamics.set_interface_defaults!","text":"set_interface_defaults!(nw::Network, s::NWState; verbose=false)\n\nSets the interface (i.e., node and edge inputs/outputs) defaults of a given network to the ones defined by the given state. Notably, while the graph topology and interface dimensions of the target network nw and the source network of s must be identical, the systems may differ in the dynamical components.\n\nThis is mainly intended for initialization purposes: solve the interface values with a simpler – possibly static – network and \"transfer\" the steady state interface values to the full network.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_defaults_dict","page":"API","title":"NetworkDynamics.get_defaults_dict","text":"get_defaults_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their default values. Only includes symbols that have default values set.\n\nSee also: get_guesses_dict, get_inits_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_guesses_dict","page":"API","title":"NetworkDynamics.get_guesses_dict","text":"get_guesses_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their guess values. Only includes symbols that have guess values set.\n\nSee also: get_defaults_dict, get_inits_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_bounds_dict","page":"API","title":"NetworkDynamics.get_bounds_dict","text":"get_bounds_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their bounds values. Only includes symbols that have bounds values set.\n\nSee also: get_defaults_dict, get_guesses_dict, get_inits_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_inits_dict","page":"API","title":"NetworkDynamics.get_inits_dict","text":"get_inits_dict(c::ComponentModel)\n\nReturns a dictionary mapping symbols to their initialization values. Only includes symbols that have initialization values set.\n\nSee also: get_defaults_dict, get_guesses_dict\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.free_u","page":"API","title":"NetworkDynamics.free_u","text":"free_u(nw::Network)\nfree_u(cf::ComponentModel)\n\nReturns the \"free\" variables/states (variables without default values) for the given system.\n\nReturns\n\nVector of variable/state symbols that do not have default values set\n\nSee also: free_p, has_default, set_default!\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.free_p","page":"API","title":"NetworkDynamics.free_p","text":"free_p(cf::ComponentModel)\nfree_p(nw::Network)\n\nReturns the \"free\" parameters (parameters without default values) for the given system.\n\nReturns\n\nVector of parameter symbols that do not have default values set\n\nSee also: free_u, has_default, set_default!\n\n\n\n\n\n","category":"function"},{"location":"API/#Metadata-and-Inspection-Utils","page":"API","title":"Metadata and Inspection Utils","text":"","category":"section"},{"location":"API/#NetworkDynamics.dump_state","page":"API","title":"NetworkDynamics.dump_state","text":"dump_state([IO=stdout], sol, t, idx; sigdigits=5)\n\nTakes a Network solution sol and prints the state at t as well as the initial state of the specified component model to IO (defaults to stdout).\n\nidx musst a valid component index, i.e. VIndex or EIndex without symbol specification.\n\ndump_state(sol, 1.0, VIndex(4))\ndump_state(sol, 1.0, EIndex(2))\n\nSee also: dump_initial_state.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.dump_initial_state","page":"API","title":"NetworkDynamics.dump_initial_state","text":"dump_initial_state([IO=stdout], cf::ComponentModel,\n                   [defaults=get_defaults_dict(cf)],\n                   [inits=get_inits_dict(cf)],\n                   [guesses=get_guesses_dict(cf)],\n                   [bounds=get_bounds_dict(cf)];\n                   sigdigits=5, p=true, obs=true)\n\nPrints the initial state of the component model cf to IO (defaults to stdout). Optionally contains parameters and observed.\n\nSee also: get_initial_state and dump_state.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_initial_state","page":"API","title":"NetworkDynamics.get_initial_state","text":"get_initial_state(c::ComponentModel, [state=get_defaults_or_inits_dict(c)], syms; missing_val=nothing)\nget_initial_state(nw::Network, sni::SymbolicIndex; missing_val=nothing)\n\nReturns the initial state for symbol sym (single symbol or vector) of the component model c. Returns missing_val if the symbol is not initialized. Also works for observed symbols.\n\nSee also: dump_initial_state.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.describe_vertices","page":"API","title":"NetworkDynamics.describe_vertices","text":"describe_vertices(nw::Network, extras...; parameters=true, states=true, batch=nothing)\n\nCreates a DataFrame containing information about the vertices in a Network.\n\nArguments\n\nnw::Network: The network to describe\nextras...: Additional pairs of (key, function) to include as columns,  where the function gets the VertexModel as its only parameter  to extract a custom metadata field for example..\nparameters=true: Whether to include parameter values\nstates=true: Whether to include state values\nbatch=nothing: Optionally filter by specific batches\n\nReturns\n\nA DataFrame with columns for vertex indices, names, batch numbers, and any parameter/state values.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.describe_edges","page":"API","title":"NetworkDynamics.describe_edges","text":"describe_edges(nw::Network, extras...; parameters=true, states=true, batch=nothing)\n\nCreates a DataFrame containing information about the edges in a Network.\n\nArguments\n\nnw::Network: The network to describe\nextras...: Additional pairs of (key, function) to include as columns,  where the function gets the EdgeModel as its only parameter  to extract a custom metadata field for example..\nparameters=true: Whether to include parameter values\nstates=true: Whether to include state values\nbatch=nothing: Optionally filter by specific batches\n\nReturns\n\nA DataFrame with columns for edge indices, source-destination pairs, names, batch numbers, and any parameter/state values.\n\n\n\n\n\n","category":"function"},{"location":"API/#Initialization","page":"API","title":"Initialization","text":"","category":"section"},{"location":"API/#NetworkDynamics.find_fixpoint","page":"API","title":"NetworkDynamics.find_fixpoint","text":"find_fixpoint(nw::Network, [x0::NWState=NWState(nw)], [p::NWParameter=x0.p]; kwargs...)\nfind_fixpoint(nw::Network, x0::AbstractVector, p::AbstractVector; kwargs...)\n\nFind a steady-state (fixed-point) solution of the network dynamics by solving the nonlinear equation f(u, p, t) = 0, where f represents the network's right-hand side function.\n\nThis is a convenience wrapper around SteadyStateProblem from the SciML ecosystem that constructs and solves the steady state problem, returning the solution as an NWState.\n\nArguments\n\nnw::Network: The network dynamics to find a fixed point for\nx0: Initial guess for the state variables. Can be:\nNWState: Complete network state (default: NWState(nw; ufill=0))\nAbstractVector: Flat state vector\np: Network parameters. Can be:\nNWParameter: Complete parameter object (default: extracted from x0 or NWParameter(nw))\nAbstractVector: Flat parameter vector\n\nKeyword Arguments\n\nalg=SSRootfind(): Steady state solver algorithm from NonlinearSolve.jl\nt=NaN: Time at which to evaluate the system (for time-dependent networks)\nAdditional kwargs are passed to the SciML solve function\n\nReturns\n\nNWState: Network state at the found fixed point\n\nSee also: NWState, NWParameter, initialize_componentwise\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_componentwise","page":"API","title":"NetworkDynamics.initialize_componentwise","text":"initialize_componentwise[!](\n    nw::Network;\n    default_overrides=nothing,\n    guess_overrides=nothing,\n    bound_overrides=nothing,\n    additional_initformula=nothing,\n    additional_initconstraint=nothing,\n    verbose=false,\n    subverbose=false,\n    tol=1e-10,\n    nwtol=1e-10,\n    t=NaN\n) :: NWState\n\nInitialize a network by solving initialization problems for each component individually, then verifying the combined solution works for the full network.\n\nThere are two versions of that function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_component! internally, the non-mutating one initialize_component. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The network to initialize\ndefault_overrides: Dictionary mapping symbolic indices to values that should be used as defaults. Use nothing as a value for any key to remove that default.\nguess_overrides: Dictionary mapping symbolic indices to values to use as initial guesses. Use nothing as a value for any key to remove that guess.\nbound_overrides: Dictionary mapping symbolic indices to bounds for constrained variables. Use nothing as a value for any key to remove those bounds.\nadditional_initformula: Dictionary mapping component indices (VIndex/EIndex) to additional initialization formulas.\nadditional_initconstraint: Dictionary mapping component indices (VIndex/EIndex) to additional initialization constraints.\nverbose: Whether to print information about each component initialization\nsubverbose: Whether to print detailed information within component initialization. Can be Vector [VIndex(1), EIndex(3), ...] for selective output\ntol: Tolerance for individual component residuals\nnwtol: Tolerance for the full network residual\nt: Time at which to evaluate the system\n\nReturns\n\nNWState: A fully initialized network state that can be used for simulation\n\nExample of two-step initialization\n\n# First solve a static model\nstatic_model = create_static_network(...)\nstatic_state = find_fixpoint(static_model)\n\n# Extract interface values and use them to initialize dynamic model\ninterface_vals = interface_values(static_state)\ndynamic_model = create_dynamic_network(...)\ndyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)\n\n# Simulate the dynamic model from this initialized state\nprob = ODEProblem(dynamic_model, uflat(dyn_state), tspan, pflat(dyn_state))\nsol = solve(prob)\n\nSee also: initialize_component, interface_values, find_fixpoint\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_componentwise!","page":"API","title":"NetworkDynamics.initialize_componentwise!","text":"initialize_componentwise[!](\n    nw::Network;\n    default_overrides=nothing,\n    guess_overrides=nothing,\n    bound_overrides=nothing,\n    additional_initformula=nothing,\n    additional_initconstraint=nothing,\n    verbose=false,\n    subverbose=false,\n    tol=1e-10,\n    nwtol=1e-10,\n    t=NaN\n) :: NWState\n\nInitialize a network by solving initialization problems for each component individually, then verifying the combined solution works for the full network.\n\nThere are two versions of that function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_component! internally, the non-mutating one initialize_component. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The network to initialize\ndefault_overrides: Dictionary mapping symbolic indices to values that should be used as defaults. Use nothing as a value for any key to remove that default.\nguess_overrides: Dictionary mapping symbolic indices to values to use as initial guesses. Use nothing as a value for any key to remove that guess.\nbound_overrides: Dictionary mapping symbolic indices to bounds for constrained variables. Use nothing as a value for any key to remove those bounds.\nadditional_initformula: Dictionary mapping component indices (VIndex/EIndex) to additional initialization formulas.\nadditional_initconstraint: Dictionary mapping component indices (VIndex/EIndex) to additional initialization constraints.\nverbose: Whether to print information about each component initialization\nsubverbose: Whether to print detailed information within component initialization. Can be Vector [VIndex(1), EIndex(3), ...] for selective output\ntol: Tolerance for individual component residuals\nnwtol: Tolerance for the full network residual\nt: Time at which to evaluate the system\n\nReturns\n\nNWState: A fully initialized network state that can be used for simulation\n\nExample of two-step initialization\n\n# First solve a static model\nstatic_model = create_static_network(...)\nstatic_state = find_fixpoint(static_model)\n\n# Extract interface values and use them to initialize dynamic model\ninterface_vals = interface_values(static_state)\ndynamic_model = create_dynamic_network(...)\ndyn_state = initialize_componentwise(dynamic_model, default_overrides=interface_vals)\n\n# Simulate the dynamic model from this initialized state\nprob = ODEProblem(dynamic_model, uflat(dyn_state), tspan, pflat(dyn_state))\nsol = solve(prob)\n\nSee also: initialize_component, interface_values, find_fixpoint\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_component","page":"API","title":"NetworkDynamics.initialize_component","text":"initialize_component(cf;\n                     defaults=get_defaults_dict(cf),\n                     guesses=get_guesses_dict(cf),\n                     bounds=get_bounds_dict(cf),\n                     default_overrides=nothing,\n                     guess_overrides=nothing,\n                     bound_overrides=nothing,\n                     additional_initformula=nothing,\n                     additional_initconstraint=nothing,\n                     verbose=true,\n                     apply_bound_transformation=true,\n                     t=NaN,\n                     tol=1e-10,\n                     residual=nothing,\n                     kwargs...)\n\nThe function solves a nonlinear problem to find values for all free variables/parameters (those without defaults) that satisfy the component equations in steady state (i.e. RHS equals 0). The initial guess for each variable depends on the provided guesses parameter (defaults to the metadata guess values).\n\nParameters\n\ncf: ComponentModel to initialize\ndefaults: Dictionary of default values (defaults to metadata defaults)\nguesses: Dictionary of initial guesses (defaults to metadata guesses)\nbounds: Dictionary of bounds (defaults to metadata bounds)\ndefault/guess/bound_overrides: Dictionary to merge with defaults/guesses/bounds. You can use nothing as a value for any key to remove that entry from the respective dictionary.\nadditional_initformula: Additional initialization formulas to apply beyond those in component metadata\nadditional_initconstraint: Additional initialization constraints to apply beyond those in component metadata\nverbose: Whether to print information during initialization\napply_bound_transformation: Whether to apply bound-conserving transformations\nt: Time at which to solve for steady state. Only relevant for components with explicit time dependency.\ntol: Tolerance for the residual of the initialized model (defaults to 1e-10). Init throws error if resid < tol.\nresidual: Optional Ref{Float64} which gets the final residual of the initialized model.\nkwargs...: Additional arguments passed to the nonlinear solver\n\nReturns\n\nDictionary mapping symbols to their values (complete state including defaults and initialized values)\n\nBounds of free variables\n\nWhen encountering any bounds in the free variables, NetworkDynamics will try to conserve them by applying a coordinate transformation. This behavior can be suppressed by setting apply_bound_transformation=false. The following transformations are used:\n\n(a, b) intervals where both a and b are positive are transformed to u^2/sqrt(u)\n(a, b) intervals where both a and b are negative are transformed to -u^2/sqrt(-u)\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.initialize_component!","page":"API","title":"NetworkDynamics.initialize_component!","text":"initialize_component!(cf::ComponentModel;\n                      defaults=nothing,\n                      guesses=nothing,\n                      bounds=nothing,\n                      default_overrides=nothing,\n                      guess_overrides=nothing,\n                      bound_overrides=nothing,\n                      additional_initformula=nothing,\n                      additional_initconstraint=nothing,\n                      verbose=true,\n                      t=NaN,\n                      kwargs...)\n\nMutating version of initialize_component. See this docstring for all details. In contrast to the non mutating version, this function reads in defaults and guesses from the symbolic metadata and writes the initialized values back in to the metadata.\n\nParameters\n\ncf: ComponentModel to initialize\ndefaults: Optional dictionary to replace all metadata defaults\nguesses: Optional dictionary to replace all metadata guesses\nbounds: Optional dictionary to replace all metadata bounds\ndefault/guess/bound_overrides: Dict of values that override existing  default/guess/bound metadata. Use nothing as a value for any key to remove  that metadata entry from the component model.\nadditional_initformula: Additional initialization formulas to apply beyond those in component metadata\nadditional_initconstraint: Additional initialization constraints to apply beyond those in component metadata\nverbose: Whether to print information during initialization\nt: Time at which to solve for steady state. Only relevant for components with explicit time dependency.\nAll other kwargs are passed to initialize_component\n\nWhen defaults, guesses, or bounds are provided, they replace the corresponding metadata in the component model. Any keys in the original metadata that are not in the provided dictionaries will be removed, and new keys will be added.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.init_residual","page":"API","title":"NetworkDynamics.init_residual","text":"init_residual(cf::ComponentModel, [state=get_defaults_or_inits_dict(cf)]; t=NaN)\n\nCalculates the residual |du| for the given component model using the values provided. If no state dictionary is provided, it uses the values from default/init Metadata.\n\nSee also initialize_component.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.InitConstraint","page":"API","title":"NetworkDynamics.InitConstraint","text":"struct InitConstraint{F}\nInitConstraint(f, sym, dim)\n\nA representation of an additional constraint that is applied during the initialization phase of a component. It contains a function f that defines the constraint, a vector of symbols sym that are involved in the constraint, and the dimension dim of the constraint.\n\nInitConstraint([:x, :y], 2) do res, u\n    res[1] = u[:x]^2 + u[:y]^2 - 1\nend\n\nSee also @initconstraint for a macro to create such constraints.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.@initconstraint","page":"API","title":"NetworkDynamics.@initconstraint","text":"@initconstraint\n\nGenerate an InitConstraint from an expression using symbols.\n\n@initconstraint begin\n    :x + :y\n    :z^2\nend\n\nis equal to\n\nInitConstraint([:x, :y, :z], 2) do out, u\n    out[1] = u[:x] + u[:y]\n    out[2] = u[:z]^2\nend\n\n\n\n\n\n","category":"macro"},{"location":"API/#NetworkDynamics.set_initconstraint!","page":"API","title":"NetworkDynamics.set_initconstraint!","text":"set_initconstraint!(c::ComponentModel, constraint; check=true)\nset_initconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nSets the initialization constraint(s) for the component. Overwrites any existing constraints. constraint can be a single InitConstraint or a tuple of InitConstraint objects.\n\nSee also: add_initconstraint!, get_initconstraints, delete_initconstraints!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_initconstraints!","page":"API","title":"NetworkDynamics.delete_initconstraints!","text":"delete_initconstraints!(c::ComponentModel)\ndelete_initconstraints!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the initialization constraint from the component model, or from a component referenced by idx in a network. Returns true if the constraint existed and was removed, false otherwise.\n\nSee also: set_initconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.has_initconstraint","page":"API","title":"NetworkDynamics.has_initconstraint","text":"has_initconstraint(c::ComponentModel)\nhas_initconstraint(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization constraint in metadata.\n\nSee also: get_initconstraints, set_initconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_initconstraints","page":"API","title":"NetworkDynamics.get_initconstraints","text":"get_initconstraints(c::ComponentModel)\nget_initconstraints(nw::Network, idx::Union{VIndex,EIndex})\n\nGets all initialization constraints for the component. Returns a tuple, even if there is only a single constraint.\n\nSee also: has_initconstraint, set_initconstraint!, add_initconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.add_initconstraint!","page":"API","title":"NetworkDynamics.add_initconstraint!","text":"add_initconstraint!(c::ComponentModel, constraint; check=true)\nadd_initconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nAdds an initialization constraint to the component. Does not overwrite existing constraints. constraint should be a single InitConstraint object.\n\nSee also: set_initconstraint!, get_initconstraints.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.InitFormula","page":"API","title":"NetworkDynamics.InitFormula","text":"InitFormula(f, outsym, sym)\n\nA representation of initialization formulas that are applied during the initialization phase of a component. InitFormulas act earlier in the initialization pipeline than InitConstraints - they essentially set additional defaults rather than adding equations to the nonlinear system.\n\nIt contains a function f that defines the formulas, a vector of output symbols outsym that will be set by the formulas, a vector of input symbols sym that are used in the formulas, and an optional pretty-print string.\n\nInitFormula([:Vset], [:u_r, :u_i]) do out, u\n    out[:Vset] = sqrt(u[:u_r]^2 + u[:u_i]^2)\nend\n\nSee also @initformula for a macro to create such formulas.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.@initformula","page":"API","title":"NetworkDynamics.@initformula","text":"@initformula\n\nGenerate an InitFormula from an expression using symbols.\n\n@initformula begin\n    :Vset = sqrt(:u_r^2 + :u_i^2)\n    :Pset = :u_r * :i_r + :u_i * :i_i\nend\n\nis equal to\n\nInitFormula([:Vset, :Pset], [:u_r, :u_i, :i_r, :i_i]) do out, u\n    out[:Vset] = sqrt(u[:u_r]^2 + u[:u_i]^2)\n    out[:Pset] = u[:u_r] * u[:i_r] + u[:u_i] * u[:i_i]\nend\n\n\n\n\n\n","category":"macro"},{"location":"API/#NetworkDynamics.has_initformula","page":"API","title":"NetworkDynamics.has_initformula","text":"has_initformula(c::ComponentModel)\nhas_initformula(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has initialization formulas in metadata.\n\nSee also: get_initformulas, set_initformula!, add_initformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_initformulas","page":"API","title":"NetworkDynamics.get_initformulas","text":"get_initformulas(c::ComponentModel)\nget_initformulas(nw::Network, idx::Union{VIndex,EIndex})\n\nGets all initialization formulas for the component. Returns a tuple, even if there is only a single formula.\n\nSee also: has_initformula, set_initformula!, add_initformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_initformula!","page":"API","title":"NetworkDynamics.set_initformula!","text":"set_initformula!(c::ComponentModel, formula; check=true)\nset_initformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nSets the initialization formula(s) for the component. Overwrites any existing formulas. formula can be a single InitFormula or a tuple of InitFormula objects.\n\nSee also: add_initformula!, get_initformulas, delete_initformulas!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.add_initformula!","page":"API","title":"NetworkDynamics.add_initformula!","text":"add_initformula!(c::ComponentModel, formula; check=true)\nadd_initformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nAdds an initialization formula to the component. Does not overwrite existing formulas. formula should be a single InitFormula object.\n\nSee also: set_initformula!, get_initformulas.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.delete_initformulas!","page":"API","title":"NetworkDynamics.delete_initformulas!","text":"delete_initformulas!(c::ComponentModel)\ndelete_initformulas!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves all initialization formulas from the component model, or from a component referenced by idx in a network. Returns true if formulas existed and were removed, false otherwise.\n\nSee also: set_initformula!, add_initformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.interface_values","page":"API","title":"NetworkDynamics.interface_values","text":"interface_values(s::NWState) :: OrderedDict{SymbolicIndex, Float64}\n\nExtract all interface values (inputs and outputs) from a network state and return them as a dictionary mapping symbolic indices to their values.\n\nThis function is particularly useful in two-step initialization workflows where you want to:\n\nSolve a simplified static model first (using find_fixpoint)\nUse the resulting interface values to initialize a more complex dynamic model componentwise.\n\nIn that scenario, use interface_values to for the default_overrides argument of initialize_componentwise.\n\nSee also: initialize_componentwise, find_fixpoint and initialize_component.\n\n\n\n\n\n","category":"function"},{"location":"API/#Linear-Stability-Analysis","page":"API","title":"Linear Stability Analysis","text":"","category":"section"},{"location":"API/#NetworkDynamics.isfixpoint","page":"API","title":"NetworkDynamics.isfixpoint","text":"isfixpoint(nw::Network, s0::NWState; tol=1e-10)\n\nCheck if the state s0 is a fixpoint of the network nw by calculating the the RHS and check that every entry is within the given tolerance tol.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.jacobian_eigenvals","page":"API","title":"NetworkDynamics.jacobian_eigenvals","text":"jacobian_eigenvals(nw::Network, s0::NWState; eigvalf=LinearAlgebra.eigvals)\n\nCompute the eigenvalues of the Jacobian matrix for linear stability analysis of the network dynamics at state s0.\n\nFor systems without algebraic constraints (identity mass matrix), this returns the eigenvalues of the full Jacobian matrix. For constrained systems (non-identity mass matrix), it computes the eigenvalues of the reduced Jacobian following the approach for differential-algebraic equations outlined in [1]\n\nArguments\n\nnw::Network: The network dynamics object\ns0::NWState: The state at which to compute the Jacobian eigenvalues\neigvalf: Function to compute eigenvalues (default: LinearAlgebra.eigvals)\n\nReturns\n\nVector: Eigenvalues of the Jacobian (or reduced Jacobian for constrained systems)\n\nAlgorithm\n\nFor unconstrained systems (M = I):\n\nComputes eigenvalues of the full Jacobian J\n\nFor constrained systems (M ≠ I, differential-algebraic equations):\n\nThe system has the form: M * dz/dt = f(z, t) where M is a diagonal mass matrix\nVariables are partitioned into differential (Mii = 1) and algebraic (Mii = 0) components\nLet z = [x; y] where x are differential and y are algebraic variables\nThe Jacobian J = ∂f/∂z is partitioned as:\nJ = [f_x  f_y]  where f_x = ∂f_d/∂x, f_y = ∂f_d/∂y\n    [g_x  g_y]        g_x = ∂g_a/∂x, g_y = ∂g_a/∂y\nFor the algebraic constraints 0 = ga(x, y), we have dy/dt = -gy^(-1) * g_x * dx/dt\nSubstituting into the differential equations gives the reduced system: dx/dt = (fx - fy * gy^(-1) * gx) * x = A_s * x\nThe eigenvalues of the reduced Jacobian A_s determine stability\nThis approach follows the theory of differential-algebraic equations [1]\n\nReferences\n\n[1] \"Power System Modelling and Scripting\", F. Milano, Chapter 7.2.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.is_linear_stable","page":"API","title":"NetworkDynamics.is_linear_stable","text":"is_linear_stable(nw::Network, s0::NWState; kwargs...)\n\nCheck if the fixpoint s0 of the network nw is linearly stable by computing the eigenvalues of the Jacobian matrix (or reduced Jacobian for constrained systems).\n\nA fixpoint is linearly stable if all eigenvalues of the Jacobian have negative real parts. For systems with algebraic constraints (non-identity mass matrix), the reduced Jacobian is used following the approach in [1]. See jacobian_eigenvals for more details.\n\nArguments\n\nnw::Network: The network dynamics object\ns0::NWState: The state to check for linear stability (must be a fixpoint)\nkwargs...: Additional keyword arguments passed to jacobian_eigenvals\n\nReturns\n\nBool: true if the fixpoint is linearly stable, false otherwise\n\nReferences\n\n[1] \"Power System Modelling and Scripting\", F. Milano, Chapter 7.2.\n\n\n\n\n\n","category":"function"},{"location":"API/#Callbacks-API","page":"API","title":"Callbacks API","text":"","category":"section"},{"location":"API/#Define-Callbacks","page":"API","title":"Define Callbacks","text":"","category":"section"},{"location":"API/#NetworkDynamics.ComponentCallback","page":"API","title":"NetworkDynamics.ComponentCallback","text":"abstract type ComponentCallback end\n\nAbstract type for a component based callback. A component callback bundles a ComponentCondition as well as a ComponentAffect which can be then tied to a component model using add_callback! or set_callback!.\n\nOn a Network level, you can automatically create network wide CallbackSets using get_callbacks.\n\nSee ContinuousComponentCallback and VectorContinuousComponentCallback for concrete implementations of this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ContinuousComponentCallback","page":"API","title":"NetworkDynamics.ContinuousComponentCallback","text":"ContinuousComponentCallback(condition, affect; kwargs...)\n\nConnect a ComponentCondition and a ComponentAffect to a continuous callback which can be attached to a component model using add_callback! or set_callback!.\n\nThe kwargs will be forwarded to the VectorContinuousCallback when the component based callbacks are collected for the whole network using get_callbacks. DiffEq.jl docs for available options.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.VectorContinuousComponentCallback","page":"API","title":"NetworkDynamics.VectorContinuousComponentCallback","text":"VectorContinuousComponentCallback(condition, affect, len; kwargs...)\n\nConnect a ComponentCondition and a ComponentAffect to a continuous callback which can be attached to a component model using add_callback! or set_callback!. This vector version allows for conditions which have len output dimensions. The affect will be triggered with the additional event_idx argument to know in which dimension the zerocrossing was detected.\n\nThe kwargs will be forwarded to the VectorContinuousCallback when the component based callbacks are collected for the whole network using get_callbacks(::Network). DiffEq.jl docs for available options.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.DiscreteComponentCallback","page":"API","title":"NetworkDynamics.DiscreteComponentCallback","text":"DiscreteComponentCallback(condition, affect; kwargs...)\n\nConnect a ComponentCondition and a ComponentAffect to a discrete callback which can be attached to a component model using add_callback! or set_callback!.\n\nNote that the condition function returns a boolean value, as the discrete callback perform no rootfinding.\n\nThe kwargs will be forwarded to the DiscreteCallback when the component based callbacks are collected for the whole network using get_callbacks(::Network). DiffEq.jl docs for available options.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PresetTimeComponentCallback","page":"API","title":"NetworkDynamics.PresetTimeComponentCallback","text":"PresetTimeComponentCallback(ts, affect; kwargs...)\n\nTrigger a ComponentAffect at given timesteps ts in discrete callback, which can be attached to a component model using add_callback! or set_callback!.\n\nThe kwargs will be forwarded to the PresetTimeCallback when the component based callbacks are collected for the whole network using get_callbacks(::Network).\n\nThe PresetTimeCallback will take care of adding the timesteps to the solver, ensuring to exactly trigger at the correct times.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ComponentCondition","page":"API","title":"NetworkDynamics.ComponentCondition","text":"ComponentCondition(f::Function, sym, psym)\n\nCreates a callback condition for a [ComponentCallback].\n\nf: The condition function. Must be a function of the form out=f(u, p, t) when used for ContinuousComponentCallback or DiscreteComponentCallback and f!(out, u, p, t) when used for VectorContinuousComponentCallback.\nArguments of f\nu: The current value of the selected sym states, provided as a SymbolicView object.\np: The current value of the selected psym parameters.\nt: The current simulation time.\nsym: A vector or tuple of symbols, which represent states (including inputs, outputs, observed) of the component model. Determines, which states will be available through parameter u in the callback condition function f.\npsym: A vector or tuple of symbols, which represent parameters of the component mode. Determines, which parameters will be available in the condition function f\n\nExample\n\nConsider a component model with states [:u1, :u2], inputs [:i], outputs [:o] and parameters [:p1, :p2].\n\nComponentCondition([:u1, :o], [:p1]) do u, p, t\n    # access states symbolically or via int index\n    u[:u1] == u[1]\n    u[:o] == u[2]\n    p[:p1] == p[1]\n    # the states/prameters `:u2`, `:i` and `:p2` are not available as\n    # they are not listed in the `sym` and `psym` arguments.\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ComponentAffect","page":"API","title":"NetworkDynamics.ComponentAffect","text":"ComponentAffect(f::Function, sym, psym)\n\nCreates a callback condition for a [ComponentCallback].\n\nf: The affect function. Must be a function of the form f(u, p, [event_idx], ctx) where event_idx is only available in VectorContinuousComponentCallback.\nArguments of f\nu: The current (mutable) value of the selected sym states, provided as a SymbolicView object.\np: The current (mutable) value of the selected psym parameters.\nevent_idx: The current event index, i.e. which out element triggered in case of VectorContinuousComponentCallback.\nctx::NamedTuple a named tuple with context variables.\nctx.model: a reference to the component model\nctx.vidx/ctx.eidx: The index of the vertex/edge model.\nctx.src/ctx.dst: src and dst indices (only for edge models).\nctx.integrator: The integrator object. Use extract_nw to obtain the network.\nctx.t=ctx.integrator.t: The current simulation time.\nsym: A vector or tuple of symbols, which represent states (excluding inputs, outputs, observed) of the component model. Determines, which states will be available through parameter u in the callback condition function f.\npsym: A vector or tuple of symbols, which represent parameters of the component mode. Determines, which parameters will be available in the condition function f\n\nExample\n\nConsider a component model with states [:u1, :u2], inputs [:i], outputs [:o] and parameters [:p1, :p2].\n\nComponentAffect([:u1, :o], [:p1]) do u, p, ctx\n    u[:u1] = 0 # change the state\n    p[:p1] = 1 # change the parameter\n    @info \"Changed :u1 and :p1 on vertex $(ctx.vidx)\" # access context\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SymbolicView","page":"API","title":"NetworkDynamics.SymbolicView","text":"SymbolicView{N,VT} <: AbstractVetor{VT}\n\nIs a (smallish) fixed size vector type with named dimensions. Its main purpose is to allow named acces to variables in ComponentCondition and ComponentAffect functions.\n\nI.e. when the ComponentAffect declared sym=[:x, :y], you can acces u[:x] and u[:y] inside the condition function.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.get_callbacks-Tuple{Network}","page":"API","title":"NetworkDynamics.get_callbacks","text":"get_callbacks(nw::Network)::CallbackSet\n\nReturns a CallbackSet composed of all the \"component-based\" callbacks in the metadata of the Network components.\n\n\n\n\n\n","category":"method"},{"location":"API/#Attach-Callbacks-to-Edge/VertexModels","page":"API","title":"Attach Callbacks to Edge/VertexModels","text":"","category":"section"},{"location":"API/#NetworkDynamics.has_callback","page":"API","title":"NetworkDynamics.has_callback","text":"has_callback(c::ComponentModel)\nhas_callback(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has a callback function in metadata.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.get_callbacks-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"NetworkDynamics.get_callbacks","text":"get_callbacks(c::ComponentModel)\nget_callbacks(nw::Network, idx::Union{VIndex,EIndex})\n\nGets all callback functions for the component. Wraps in tuple, even if there is only a single one.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.set_callback!","page":"API","title":"NetworkDynamics.set_callback!","text":"set_callback!(c::ComponentModel, cb; check=true)\nset_callback!(nw::Network, idx::Union{VIndex,EIndex}, cb; check=true)\n\nSets the callback function for the component. Overwrites any existing callback. See also add_callback!.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.add_callback!","page":"API","title":"NetworkDynamics.add_callback!","text":"add_callback!(c::ComponentModel, cb; check=true)\nadd_callback!(nw::Network, idx::Union{VIndex,EIndex}, cb; check=true)\n\nAdds a callback function to the component. Does not overwrite existing callbacks. See also set_callback!.\n\n\n\n\n\n","category":"function"},{"location":"API/#Sparsity-Detection","page":"API","title":"Sparsity Detection","text":"","category":"section"},{"location":"API/#NetworkDynamics.get_jac_prototype","page":"API","title":"NetworkDynamics.get_jac_prototype","text":"get_jac_prototype(nw::Network; dense=false, remove_conditions=false)\n\nCompute the sparsity pattern of the Jacobian matrix for a NetworkDynamics network.\n\nThis function uses SparseConnectivityTracer.jl to detect the sparsity pattern of the Jacobian  matrix of the network's dynamics function. The resulting sparsity pattern can be used to  improve the performance of ODE solvers by providing structural information about the system. The dense option is useful when certain components have complex sparsity patterns that are difficult to detect automatically. The remove_conditions option helps when conditional statements in component functions interfere with sparsity detection.\n\nArguments\n\nnw::Network: The NetworkDynamics network for which to compute the Jacobian prototype\ndense=false: Controls which components should be treated as dense during sparsity detection:\nfalse: Use actual component functions (default)\ntrue: Replace all components with dense equivalents\nVector{Union{VIndex, EIndex}}: Replace only the specified vertex/edge components with dense equivalents\nremove_conditions=false: Controls removal of conditional statements from component functions: this is only applicable to components defined via MTK. It essentially scans the function expression for if/else statements, deleting the condition and replacing the block by truepath + falsepath, which can help with sparsity detection.\nfalse: Keep conditional statements as-is (default)\ntrue: Remove conditionals from all components by converting if-else to additive form\nVector{Union{VIndex, EIndex}}: Remove conditionals only from specified vertex/edge components\ncheck=true: If true, the function checks the sparsity pattern against a forward-differentiated Jacobian as a sanity check.\n\nReturns\n\nA sparse matrix representing the sparsity pattern of the Jacobian matrix\n\nExample Usage\n\nnw = Network(...)\njac_prototype = get_jac_prototype(nw) # get the sparsity pattern\n\n# manually set define ODEFunction\nf_ode = ODEFunction(nw; jac_prototype=jac_prototype)\nprob = ODEProblem(f_ode, x0, (0.0, 1.0), p0)\nsol = solve(prob, Rodas5P())\n\n# ALTERNATIVE: use set_jac_prototype!\nset_jac_prototype!(nw; jac_prototype) # attach pattern to network\nprob = ODEProblem(nw, x0, (0.0, 1.0), p0) # uses jac prototype from network\nsol = solve(prob, Rodas5P())\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.set_jac_prototype!","page":"API","title":"NetworkDynamics.set_jac_prototype!","text":"set_jac_prototype!(nw::Network, jac::SparseMatrixCSC{Bool,Int})\n\nSet the Jacobian prototype for a NetworkDynamics network.\n\nThis function stores a pre-computed Jacobian sparsity pattern in the network object, which can be used by ODE solvers to improve performance during integration.\n\nArguments\n\nnw::Network: The NetworkDynamics network to modify\njac::SparseMatrixCSC{Bool,Int}: A sparse matrix representing the Jacobian sparsity pattern\n\n\n\n\n\nset_jac_prototype!(nw::Network; kwargs...)\n\nCompute and set the Jacobian prototype for a NetworkDynamics network.\n\nThis is a convenience function that automatically computes the Jacobian sparsity pattern using get_jac_prototype and stores it in the network object. Needs SparseConnectivityTracer to be loaded!\n\nArguments\n\nnw::Network: The NetworkDynamics network to modify\nkwargs...: Keyword arguments passed to get_jac_prototype (e.g., dense, remove_conditions)\n\nExample Usage\n\nnw = Network(...)\nset_jac_prototype!(nw) # computs sparsity pattern and stores in network\nprob = ODEProblem(nw, x0, (0.0, 1.0), p0)\nsol = solve(prob, Rodas5P())\n\nSee also: get_jac_prototype\n\n\n\n\n\n","category":"function"},{"location":"API/#Execution-Types","page":"API","title":"Execution Types","text":"","category":"section"},{"location":"API/#NetworkDynamics.ExecutionStyle","page":"API","title":"NetworkDynamics.ExecutionStyle","text":"abstract type ExecutionStyle{buffered::Bool} end\n\nAbstract type for execution style. The coreloop dispatches based on the Execution style stored in the network object.\n\nbuffered=true means that the edge input es explicitly gathered, i.e. the vertex outputs in the output buffer will be copied into a dedicated input buffer for the edges.\nbuffered=false means, that the edge inputs are not explicitly gathered, but the corloop will perform a redirected lookup into the output buffer.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SequentialExecution","page":"API","title":"NetworkDynamics.SequentialExecution","text":"struct SequentialExecution{buffered::Bool}\n\nSequential execution, no parallelism. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PolyesterExecution","page":"API","title":"NetworkDynamics.PolyesterExecution","text":"struct PolyesterExecution{buffered}\n\nParallel execution using Polyester.jl. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ThreadedExecution","page":"API","title":"NetworkDynamics.ThreadedExecution","text":"struct ThreadedExecution{buffered}\n\nParallel execution using Julia threads. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.KAExecution","page":"API","title":"NetworkDynamics.KAExecution","text":"struct KAExecution{buffered}\n\nParallel execution using KernelAbstractions.jl. Works with GPU and CPU arrays. For buffered see ExecutionStyle.\n\n\n\n\n\n","category":"type"},{"location":"API/#Aggregators","page":"API","title":"Aggregators","text":"","category":"section"},{"location":"API/#NetworkDynamics.Aggregator","page":"API","title":"NetworkDynamics.Aggregator","text":"abstract type Aggregator end\n\nAbstract sypertype for aggregators. Aggregators operate on the output buffer of all components and fill the aggregation buffer with the aggregatated edge values per vertex.\n\nAll aggregators have the constructor\n\nAggegator(aggfun)\n\nfor example\n\nSequentialAggreator(+)\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SequentialAggregator","page":"API","title":"NetworkDynamics.SequentialAggregator","text":"SequentialAggregator(aggfun)\n\nSequential aggregation.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.SparseAggregator","page":"API","title":"NetworkDynamics.SparseAggregator","text":"SparseAggregator(+)\n\nOnly works with additive aggregation +. Aggregates via sparse inplace matrix multiplication. Works with GPU Arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.ThreadedAggregator","page":"API","title":"NetworkDynamics.ThreadedAggregator","text":"ThreadedAggregator(aggfun)\n\nParallel aggregation using Julia threads.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.PolyesterAggregator","page":"API","title":"NetworkDynamics.PolyesterAggregator","text":"PolyesterAggregator(aggfun)\n\nParallel aggregation using Polyester.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#NetworkDynamics.KAAggregator","page":"API","title":"NetworkDynamics.KAAggregator","text":"KAAggregator(aggfun)\n\nParallel aggregation using KernelAbstractions.jl. Works with both GPU and CPU arrays.\n\n\n\n\n\n","category":"type"},{"location":"API/#Utils","page":"API","title":"Utils","text":"","category":"section"},{"location":"API/#NetworkDynamics.save_parameters!","page":"API","title":"NetworkDynamics.save_parameters!","text":"save_parameters!(integrator::SciMLBase.DEIntegrator)\n\nSave the current parameter values in the integrator. Call this function inside callbacks if the parameter values have changed. This will store a timeseries of said parameters in the solution object, thus alowing us to recosntruct observables which depend on time-dependet variables.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.ff_to_constraint","page":"API","title":"NetworkDynamics.ff_to_constraint","text":"ff_to_constraint(v::VertexModel)\n\nTakes VertexModel v with feed forward and turns all algebraic output states into internal states by defining algebraic constraints contraints 0 = out - g(...). The new output function is just a StateMask into the extended internal state vector.\n\nReturns the transformed VertexModel.\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.copy-Tuple{NetworkDynamics.ComponentModel}","page":"API","title":"Base.copy","text":"copy(c::NetworkDynamics.ComponentModel)\n\nShallow copy of the component model. Creates a deepcopy of metadata and symmetadata but references the same objects everywhere else.\n\n\n\n\n\n","category":"method"},{"location":"API/#NetworkDynamics.extract_nw","page":"API","title":"NetworkDynamics.extract_nw","text":"extract_nw(thing)\n\nTry to extract the Network object from thing.\n\nThing can by many things, e.g. ODEProblem, ODESolution, Integrator, NWState, NWParameter, ...\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamics.implicit_output","page":"API","title":"NetworkDynamics.implicit_output","text":"implicit_output(x) = 0\nModelingToolkit.@register_symbolic implicit_output(x)\n\nThis is a helper function to define MTK models with fully implicit outputs. It is sort of a barrier for Symbolics to not descent in to the equation. When added to an equation, it does nothing (defined as 0), but it tricks MTK/Symbolics into believing the equation depends on x. This can be necessary to define a model with fully implicit outputs.\n\n@mtkmodel ImplicitForcing begin\n    @variables begin\n        u(t), [description = \"Input Variable\", input=true]\n        y(t), [description = \"fully implicit output\", output=true]\n    end\n    @equations begin\n        # 0 ~ u  # WRONG!\n        0 ~ u + implicit_output(y) # CORRECT!\n    end\nend\nVertexModel(ImplicitForcing(name=:implicit), [:u], [:y])\n\nFor more information see the NetworkDynamics docs on fully implicit outputs.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector-API","page":"API","title":"NetworkDynamicsInspector API","text":"","category":"section"},{"location":"API/#NetworkDynamicsInspector.inspect","page":"API","title":"NetworkDynamicsInspector.inspect","text":"inspect(sol; restart=false, reset=false, display=nothing)\n\nMain entry point for gui. Starts the server and serves the app for solution sol.\n\nrestart: If true, the display will be restartet (i.e. new Electron window, new server or new Browser tab)\nreset: If true, reset the appstate with the new solution sol.\ndisplay=CURRENT_DISPLAY[]: Can be BrowserDisp(), ServerDisp() or ElectronDisp().  Per default, the current display will be used (defaults toBrowserDisp()).\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.dump_app_state","page":"API","title":"NetworkDynamicsInspector.dump_app_state","text":"dump_app_state()\n\nGenerate a list of set_sol!, set_state!, set_graphplot! and define_timeseries! commands to recreate the current appstate. The intended usecase is to quickly recreate \"starting points\" for interactive exploration.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_sol!","page":"API","title":"NetworkDynamicsInspector.set_sol!","text":"set_sol!(sol)\n\nSet the solution of the current appstate to sol.\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_state!","page":"API","title":"NetworkDynamicsInspector.set_state!","text":"set_state!(; sol, t, tmin, tmax)\n\nSet the solution, current time and time limits of the current appstate.\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_graphplot!","page":"API","title":"NetworkDynamicsInspector.set_graphplot!","text":"set_graphplot!(; nstate, estate, nstate_rel, estate_rel, ncolorrange, ecolorrange)\n\nSet the properties of the graphplot of the current appstate.\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.set_timeseries!","page":"API","title":"NetworkDynamicsInspector.set_timeseries!","text":"set_timeseries!(key; selcomp, states, rel)\n\nSet properties of the timeseries plot with key key. See also define_timeseries!.\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"API/#NetworkDynamicsInspector.define_timeseries!","page":"API","title":"NetworkDynamicsInspector.define_timeseries!","text":"define_timeseries!(tsarray)\n\nDefines timeseries, where tsarray is an array of timeseries keyword arguments (see set_timeseries!).\n\nTo automaticially create commands see dump_app_state().\n\n\n\n\n\n","category":"function"},{"location":"mathematical_model/#Mathematical-Model","page":"Mathematical Model","title":"Mathematical Model","text":"","category":"section"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The core of the NetworkDynamics.jl package is the Network function. It accepts functions describing the local dynamics on the edges and nodes of the graph g as inputs, and returns a composite function compatible with the DifferentialEquations.jl syntax as output.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"nd = Network(g, vertex_dynamics,  edge_dynamics)\nnd(dx, x, p, t)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"In general, the local dynamics on the edges and nodes of a graph can be described through the use of (a) algebraic equations, (b) differential algebraic equations (DAEs) in mass matrix form, or (c) ordinary differential equations (ODEs). The NetworkDynamics.jl package uses Differential-Algebraic-Equations (DAE) to express the overall network dynamics:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Mfracmathrmdmathrmdtu = f^mathrmnw(u p t)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"where M is a (possibly singular) mass matrix, u is the internal state vector of the system, p are the parameters, and t is the time. To make this compatible with the solvers used in OrdinaryDiffEq.jl, the generated Network object is callable","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"nw(du, u, p, t) # mutates du as an \"output\"","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"and represents the right-hand-side (RHS) of the equation above. The mass-matrix M is stored in the Network object as well.","category":"page"},{"location":"mathematical_model/#Modeling-the-Dynamics-of-the-System","page":"Mathematical Model","title":"Modeling the Dynamics of the System","text":"","category":"section"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Each component model mathrm c is modeled as a general input-output system:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"beginaligned\nM_mathrm cfracmathrmdmathrmdtx_mathrm c = f^mathrm c(x^mathrm c i_mathrm c p_mathrm c t)\ny^mathrm c = g^mathrm c(x^mathrmc i_mathrm c p_mathrm c t)\nendaligned","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"where M_mathrmc is the component mass matrix, x^mathrm c are the component states, i^mathrm c are the inputs of the component, and y^mathrm c is the output of the component. If mathrmdim(x^mathrmc) = 0, the number of internal states is 0.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The mathematical model of NetworkDynamics.jl splits the network system into two parts: the vertex and the edge components (the nodes and edges, respectively). Instead of defining the f^mathrmnw by hand, ND.jl builds it automatically based on a list of decentralized nodal and edge dynamics that the user provides (the VertexModel and EdgeModel objects).","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"In the context of the network, the output of the edges are flow variables and the outputs of vertices are potential variables. When the node and edge models are placed on a graph, the inputs and outputs are connected: the nodes receive the output of the adjacent edges as inputs and the edges receive the output of the adjacent nodes as inputs. Thus, the flow on the edges depends on the potentials at both ends as inputs. The potentials of the nodes depend on the incoming flows from all connected edges as an input. (Here, flow and potentials are meant in a conceptual and not necessarily physical way.)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"<picture>\n  <source srcset=\"../assets/mathmodel-dark.svg\" media=\"(prefers-color-scheme: dark)\">\n  <img src=\"../assets/mathmodel.svg\" width=\"100%\" height=\"100%\"/>\n</picture>","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"In this graphical representation of a partial network graph, three nodes are visible (node 1, node 2, and node 3) as well as the edges connecting node 1 and node 2 (e_mathrm12). Above the network, you can see the dynamical systems for both nodes 1 and 2 as well as the connecting edge. The figure shows how the outputs of the edge appear as inputs to the nodes and the outputs of the nodes appear as inputs to the edge models.","category":"page"},{"location":"mathematical_model/#Vertex-Models","page":"Mathematical Model","title":"Vertex Models","text":"","category":"section"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The equations of a (single-layer) full vertex model are:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"beginaligned\nM^mathrm vfracmathrmdmathrmdtx^mathrm v = f^mathrm v(x^mathrm v i^mathrm v p^mathrm v t)\ny^mathrm v = g^mathrm v(x^mathrm v i^mathrm v p^mathrm v t)\nendaligned","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"and they correspond to the Julia functions:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"function fᵥ(dxᵥ, xᵥ, e_aggr, pᵥ, t)\n    # mutate dxᵥ\n    nothing\nend\nfunction gᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)\n    # mutate yᵥ\n    nothing\nend\nvertf = VertexModel(; f=fᵥ, g=gᵥ, mass_matrix=Mᵥ, ...)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"A (single-layer) full vertex model has one input, and one output. Its input is an aggregation/reduction over all the incident edge outputs which is calculated using:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"i^mathrm v = mathopmathrmagglimits_k^textincident y^mathrm e_k qquadtextoftenqquad\ni^mathrm v = sum_k^textincident y^mathrm e_k","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The graphical representation of such a model is:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"<picture>\n  <source srcset=\"../assets/nodemodel-dark.svg\" media=\"(prefers-color-scheme: dark)\">\n  <img src=\"../assets/nodemodel.svg\" width=\"70%\" height=\"70%\"/>\n</picture>","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"where y^e_i and y^e_j are two of the n incident edge outputs that are aggregated to produce the model input i^v and the model output y^v (the vertex model output).","category":"page"},{"location":"mathematical_model/#Edge-Models","page":"Mathematical Model","title":"Edge Models","text":"","category":"section"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"In contrast to vertex models, edge models in general have two inputs and two outputs, for both the source and the destination end of the edge. We commonly use src and dst to describe the source and destination ends of an edge, respectively.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"note: On the directionality of edges\nMathematically, in a system defined on an undirected graph, there is no difference between edge (12) and edge (21), because the edge has no direction. However, from an implementation point of view, we always need to have some kind of ordering. For undirected graphs, the edges are always defined from src -> dst where src < dst (this convention matches the behavior of the edges iterator from Graphs.jl). I.e., the undirected edge between nodes 1 and 2 will always be referenced as 1 -> 2, never 2 -> 1. The source and destination naming is related to this notion of directionality; it is not related to the actual flows, i.e., a system might exist where there is a net flow from destination to source.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The full edge model equations are:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"beginaligned\nM^mathrm efracmathrmdmathrmdtx^mathrm e = f^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t)\ny^mathrm e_mathrmdst = g_mathrmdst^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t)\ny^mathrm e_mathrmsrc = g_mathrmsrc^mathrm e(u^mathrm e y^mathrm v_mathrmsrc y^mathrm v_mathrmdst p^mathrm e t)\nendaligned","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"and they correspond to the Julia functions:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"function fₑ(dxₑ, xₑ, v_src, v_dst, pₑ, t)\n    # mutate dxₑ\n    nothing\nend\nfunction gₑ(y_src, y_dst, xₑ, v_src, v_dst, pₑ, t)\n    # mutate y_src and y_dst\n    nothing\nend\nedgef = EdgeModel(; f=fₑ, g=gₑ, mass_matrix=Mₑ, ...)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Each edge has:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"two inputs:\nthe node outputs of the source\nthe node outputs of the destination end of the edge\ntwo outputs:\nthe dst output (which is used as input for the vertex at the destination end)\nthe src output (which is used as input for the vertex at the source end)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"In general, the two edge outputs y_mathrmsrc and y_mathrmdst are completely independent because there is no implicit conservation law dictating that their values should be identical. An example of such unbalanced systems is power lines in an energy grid with losses, where the power flowing into a line does not match the power flowing out of it, because some of the energy transported is lost in the form of heat. Another example would be a gas pipeline with some internal pressure: it is entirely possible to push in gas from both ends simultaneously. It would simply result in increased pressure within the pipe. For the (important) special cases where there is a strong correlation between source and destination output, see the section on Single Sided Edge Outputs below.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The vertex models connected to the edge do not know whether they are at the 'src' or the 'dst' end of the edge. Therefore, the sign convention for both outputs of an edge must be identical. Typically, a positive flow represents a flow into the connected vertex, whereas a negative flow represents a flow out of the connected vertex.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"          y_src ┌───────────────────┐ y_dst\n  V_src o───←───┤ internal dynamics ├───→───o V_dst\n                └───────────────────┘","category":"page"},{"location":"mathematical_model/#Single-Sided-Edge-Outputs","page":"Mathematical Model","title":"Single Sided Edge Outputs","text":"","category":"section"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Often, the edge output functions g_mathrmsrc and g_mathrmdst are not independent, but rather one of them is a function of the other. For example, in an edge model with flow conservation without internal storage, the flow magnitude at the source end is equal to the flow magnitude at the destination end (what flows in must come out). Since the sign convention on both ends must be identical (e.g., positive flow is a flow towards the vertex), we get antisymmetric behavior: y_mathrmsrc = -y_mathrmdst.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"To accommodate such cases, we can use the concept of single-sided edge output functions. A single-sided output function only defines a function for one of the outputs:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"function g_single(y, xᵥ, v_src, v_dst, pₑ, t)\n    # mutate y\n    nothing\nend","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"There are multiple wrappers available to automatically convert them into double-sided edge output functions:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Directed(g_single) builds a double-sided function which only couples to the destination side (i.e., y_dst=y and y_src = 0).\nSymmetric(g_single) builds a double-sided function in which both ends receive y (i.e., y = y_src = y_dst).\nAntiSymmetric(g_single) builds a double-sided function where the destination receives y and the source receives -y (i.e., y=y_dst=-y_src).\nFiducial(g_single_src, g_single_dst) builds a double-sided edge output function based on two single-sided functions.","category":"page"},{"location":"mathematical_model/#Feed-Forward-Behavior","page":"Mathematical Model","title":"Feed Forward Behavior","text":"","category":"section"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"warning: Feed Forward Vertices\nAs of 11/2024, vertices with feed forward behavior (FF) are not supported at all. Use ff_to_constraint to transform them into vertex models without FF.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Component models can have a so-called feed forward behavior, which provides a direct link between the input and the output.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The most generic version of the component models can contain direct FFs from the input to the output. This means that the output function g depends directly on the component inputs i rather than just on the component state x.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Whenever possible, you should define output functions without FFs in the following way:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"gᵥ_noff(yᵥ, xᵥ, pᵥ, t)\ngₑ_noff([y_src,] y_dst, xₑ, pₑ, t)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"instead of the more general","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"gᵥ(yᵥ, xᵥ, e_aggr, pᵥ, t)\ngₑ([y_src,] y_dst, xₑ, v_src, v_dst, pₑ, t)","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"NetworkDynamics cannot couple two components with FFs to each other. However, it is always possible to transform feed forward behavior to an internal state x with mass matrix entry zero to circumvent this problem. This transformation can be performed automatically using ff_to_constraint.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"Concretely, NetworkDynamics distinguishes between 4 types of feed forward behaviors of g functions based on the FeedForwardType trait. The feed forward type is inferred automatically based on the provided function g (this is done by inspecting the available method signatures for g, i.e., NetworkDynamics checks how many arguments your g function takes). If the automatic inference of feed forward type fails, the user may specify it explicitly using the ff keyword argument of the Edge/VertexModel constructor.","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"The code block below presents the different g signatures for the different feed forward types:","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"PureFeedForward()","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"g!(outs...,          ins...,       p, t) # abstractly\ng!(out_dst,          v_src, v_dst, p, t) # single-sided edge\ng!(out_src, out_dst, v_src, v_dst, p, t) # double-sided edge\ng!(v_out,            e_aggr,       p, t) # single layer vertex","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"FeedForward()","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"g!(outs...,          x, ins...,       p, t) # abstractly\ng!(out_dst,          x, v_src, v_dst, p, t) # single-sided edge\ng!(out_src, out_dst, x, v_src, v_dst, p, t) # double-sided edge\ng!(v_out,            x, e_aggr,       p, t) # single layer vertex","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"NoFeedForward()","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"g!(outs...,          x, p, t) # abstractly\ng!(out_dst,          x, p, t) # single-sided edge\ng!(out_src, out_dst, x, p, t) # double-sided edge\ng!(v_out,            x, p, t) # single layer vertex","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"PureStateMap()","category":"page"},{"location":"mathematical_model/","page":"Mathematical Model","title":"Mathematical Model","text":"g!(outs...,          x) # abstractly\ng!(out_dst,          x) # single-sided edge\ng!(out_src, out_dst, x) # double-sided edge\ng!(v_out,            x) # single layer vertex","category":"page"},{"location":"data_structure/#Data-Structure","page":"Data Structure","title":"Data Structure","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"A Network contains a list of vertex and edge models along with a graph. However, in tight numerical loops, it will never access these lists of models directly. Instead, the network maintains an internal representation that tracks all symbolic indices, defining the precise ordering of states and parameters in a flat array representation. To optimize performance, especially for heterogeneous networks, the network employs specialized data structures that batch identical models together.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"This disconnect between the explicit lists and the internal data structures can be confusing.","category":"page"},{"location":"data_structure/#Flat-Parameter-and-State-Arrays","page":"Data Structure","title":"Flat Parameter and State Arrays","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"The vertex and edge models may contain metadata, such as the initial values for states and parameters. Crucially, this metadata is only for the building and initialization of the simulation. During actual simulation, the state and parameters are handled as flat arrays, i.e., plain Vector{Float64} objects.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"NWState and NWParameter serve as wrappers around flat arrays and the Network objects, allowing you to inspect and modify those flat arrays by addressing vertices and edges directly.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"A typical workflow is the following:","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"Set default values in the models using the metadata (see Metadata).\nCreate a network (see Network Construction).\nGenerate a state s = NWState(nw) which will be prefilled with the default values from the component metadata (see Symbolic Indexing).\nChange the values of s, i.e., s.v[1,:x] = 1.0: This changes the underlying flat array but not the metadata of the models.\nBuild a problem with the updated flat arrays using uflat(s) and pflat(s).","category":"page"},{"location":"data_structure/#Accessing-Components","page":"Data Structure","title":"Accessing Components","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"Per default, the models are not copied on Network construction:","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"using NetworkDynamics # hide\nusing Graphs #hide\ninclude(joinpath(pkgdir(NetworkDynamics), \"test\", \"ComponentLibrary.jl\")) # hide\nkuramoto_first = Lib.kuramoto_vertex! # hide\nkuramoto_secnd = Lib.kuramoto_inertia! # hide\nkuramoto_edge = Lib.kuramoto_edge! # hide\n\nv1 = VertexModel(f=kuramoto_first, sym=[:θ], psym=[:ω], g=1)\nv2 = VertexModel(f=kuramoto_secnd, sym=[:δ, :ω], psym=[:M, :D, :Pm], g=1)\ne = EdgeModel(;g=AntiSymmetric(kuramoto_edge), outsym=[:P], psym=[:K])\nnw = Network(complete_graph(2), [v1, v2], e)","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"You can access the models using getindex/[] with VIndex or EIndex:","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"v1 === nw[VIndex(1)]","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"This can be important when changing the metadata of components. i.e., both lines below are equivalent:","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"set_position!(v1, (1,0))\nset_position!(nw[VIndex(1)], (1,0))\nnothing #hide","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"note: Aliasing of component models\nSince components are not copied, multiple entries in the vertex and edge lists might point to the same instance of a model. nw = Network(complete_graph(3), [v1,v2,v1], e)\nv1 === nw[VIndex(1)] === nw[VIndex(3)]Consequently, metadata set for one model might affect another model. This behavior can be beneficial for performance reasons. To force the copying of components, use the dealias keyword:nw = Network(complete_graph(3), [v1,v2,v1], e; dealias=true)\nnw[VIndex(1)] === nw[VIndex(3)] # neither of them === v1","category":"page"},{"location":"data_structure/#Extracting-a-Network-object-from-Containers","page":"Data Structure","title":"Extracting a Network-object from Containers","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"NetworkDynamics.jl provides a extract_nw function, to get a reference to the wrapped Network object from different containers, such as solution objects or integrator objects. ","category":"page"},{"location":"generated/cascading_failure/#Cascading-Failure","page":"Cascading Failure","title":"Cascading Failure","text":"","category":"section"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"This script reimplements the minimal example of a dynamic cascading failure described in Schäfer et al. (2018) [1]. This is an example how to use callback functions to change network parameters. In this case to disable certain lines. This script can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"[1] Schäfer, B., Witthaut, D., Timme, M., & Latora, V. (2018). Dynamically induced cascading failures in power grids. Nature communications, 9(1), 1-13. https://www.nature.com/articles/s41467-018-04287-5","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"This example has three subchaperts:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"first we define the network model,\nsecondly, we implement component based callbacks and\nthirdly we solve the problem using systemwide callbacks.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"The system is modeled using swing equation and active power edges. The nodes are characterized by the voltage angle δ, the active power on each line is symmetric and a function of the difference between source and destination angle δ_src - δ_dst.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"using NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEqTsit5\nusing DiffEqCallbacks\nusing Plots\nusing Test #hide\nimport SymbolicIndexingInterface as SII","category":"page"},{"location":"generated/cascading_failure/#Defining-the-Model","page":"Cascading Failure","title":"Defining the Model","text":"","category":"section"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"For the nodes we define the swing equation. State v[1] = δ, v[2] = ω. The swing equation has three parameters: p = (P_ref, I, γ) where P_ref is the power setpopint, I is the inertia and γ is the droop or damping coeficcient.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"The output of the node is just the first state. g=1 is a shorthand for g=StateMask(1:1) which implements a trivial output function g which just takes the first element of the state vector.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"function swing_equation(dv, v, esum, p,t)\n    P, I, γ = p\n    dv[1] = v[2]\n    dv[2] = P - γ * v[2] .+ esum[1]\n    dv[2] = dv[2] / I\n    nothing\nend\nvertex = VertexModel(f=swing_equation, g=1, sym=[:δ, :ω], psym=[:P_ref, :I=>1, :γ=>0.1])","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"Lets define a simple purely active power line whose active power flow is completlye determined by the connected voltage angles and the coupling constant K. We give an additonal parameter, the line limit, which we'll use later in the callback.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"function simple_edge(e, v_s, v_d, (K,), t)\n    e[1] = K * sin(v_s[1] - v_d[1])\nend\nedge = EdgeModel(;g=AntiSymmetric(simple_edge), outsym=:P, psym=[:K=>1.63, :limit=>1])","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"With the definition of the graph topology we can build the Network object:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"g = SimpleGraph([0 1 1 0 1;\n                 1 0 1 1 0;\n                 1 1 0 1 0;\n                 0 1 1 0 1;\n                 1 0 0 1 0])\nnw = Network(g, vertex, edge; dealias=true)","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"Note that we used dealias=true to automaticially generate separate ComponentModels for each vertex/edge. Doing so allows us to later set different metadata (callbacks, default values, etc.) for each vertex/edge.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"We proceed by setting the default reference power for the nodes:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"set_default!(nw, VIndex(1, :P_ref), -1.0) # load\nset_default!(nw, VIndex(2, :P_ref),  1.5) # generator\nset_default!(nw, VIndex(3, :P_ref), -1.0) # load\nset_default!(nw, VIndex(4, :P_ref), -1.0) # load\nset_default!(nw, VIndex(5, :P_ref),  1.5) # generator\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"We can use find_fixpoint to find a valid initial condition of the network. We also use set_defaults! to overwirte all the default values for states and parameters with the one of the fixpoint, this means that we can allways re-extract this setpoint by using u0 = NWState(nw).","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"u0 = find_fixpoint(nw)\nset_defaults!(nw, u0)\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/#Component-based-Callbacks","page":"Cascading Failure","title":"Component-based Callbacks","text":"","category":"section"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"For the component based callback we need to define a condtion and an affect. Both functions take three inputs:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"the actual function f\nthe states which to be accessed sym\nthe parameters to be accessed psym","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"cond = ComponentCondition([:P], [:limit]) do u, p, t\n    abs(u[:P]) - p[:limit]\nend\naffect = ComponentAffect([], [:K]) do u, p, ctx\n    println(\"Line $(ctx.eidx) tripped at t=$(ctx.integrator.t)\")\n    p[:K] = 0\nend\nedge_cb = ContinuousComponentCallback(cond, affect)","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"To enable the callback in simulation, we need to attach them to the individual edgemodels/vertexmodels.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"for i in 1:ne(g)\n    edgemodel = nw[EIndex(i)]\n    set_callback!(edgemodel, edge_cb)\nend\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"The system starts at a steady state. In order to see any dynamic, we need to fail a first line intentionally. For that we use a PresetTimeComponentCallback, which triggers an ComponentAffect at a given time. We can reuse the previously defined component affect for that and just add it to line number 5 at time 1.0.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"trip_first_cb = PresetTimeComponentCallback(1.0, affect)\nadd_callback!(nw[EIndex(5)], trip_first_cb)\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"When we inspect the edge model for 5 no, we see that we've registered 2 callbacks:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"nw[EIndex(5)]","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"Now we can simulate the network. We use get_callbacks(::Network) to generate a callback set for the whole network which represents all of the individual component callbacks.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"u0 = NWState(nw)\nnetwork_cb = get_callbacks(nw)\nprob = ODEProblem(nw, uflat(u0), (0, 6), pflat(u0); callback=network_cb)\nsol = solve(prob, Tsit5());\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"Lastly we plot the power flow on all lines using the eidxs function to generate the symbolic indices for the states of interest:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"plot(sol; idxs=eidxs(sol, :, :P))","category":"page"},{"location":"generated/cascading_failure/#System-wide-Callbacks","page":"Cascading Failure","title":"System wide Callbacks","text":"","category":"section"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"The above solution relies on the ComponentCallback features of NetworkDynamics. The \"low-level\" API would be to use VectorContinuousCallback and PresetTimeCallback directly to achieve the same effect, essentially doing manually what get_callbacks(::Network) is doing for us.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"While not necessary in this case, this method offers more flexibility than the component based approach.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"In order to implement the line failures, we need to create a VectorContinuousCallback. In the callback, we compare the current flow on the line with the limit. If the limit is reached, the coupling K is set to 0.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"First we can define the affect function:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"function affect!(integrator, idx)\n    println(\"Line $idx tripped at t=$(integrator.t)\")\n    p = NWParameter(integrator) # get indexable parameter object\n    p.e[idx, :K] = 0\n    auto_dt_reset!(integrator)\n    save_parameters!(integrator)\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"There is one important aspect to this function: the save_parameters! call. In the callback, we change the parameters of the network, making the parameters time dependent. The flow on the line is a function P(t) = f(u(t), p(t)). Thus we need to inform the integrator, that a discrete change in parameters happend. With this, the solution object not only tracks u(t) but also p(t) and we may extract the observable P(t) directly.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"The callback trigger condition is a bit more complicated. The straight forward version looks like this:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"function naive_condition(out, u, t, integrator)\n    # careful,  u != integrator.u\n    # therefore construct nwstate with Network info from integrator but u\n    s = NWState(integrator, u, integrator.p, t)\n    for i in eachindex(out)\n        out[i] = abs(s.e[i,:P]) - s.p.e[1,:limit] # compare flow with limit for line\n    end\n    nothing\nend\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"However, from a performacne perspectiv there are problems with this solution: on every call, we need to perform symbolic indexing into the NWState object. Symbolic indexing is not cheap, as it requires to gather meta data about the network. Luckily, the SymbolicIndexingInterface package which powers the symbolic indexing provides the lower level functions getp and getu which can be used to create and cache accessors to the internal states.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"This still isn't ideal beacuse both getlim and getflow getters will create arrays within the callback. But is far better then resolving the flat state indices every time.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"condition = let getlim = SII.getp(nw, epidxs(nw, :, :limit)),\n                getflow = SII.getu(nw, eidxs(nw, :, :P))\n    function (out, u, t, integrator)\n        # careful,  u != integrator.u\n        # therefore construct nwstate with Network info from integrator but u\n        s = NWState(integrator, u, integrator.p, t)\n        out .= getlim(s) .- abs.(getflow(s))\n        nothing\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"We can combine affect and condition to form the callback.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"trip_cb = VectorContinuousCallback(condition, affect!, ne(g));\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"Similarily to before, we need to generate a initial perturbation by failing one line using a PresetTimeCallback. We see that every flow is below the trip value 1.0. Therefor we need to add a distrubance to the network. We do this by manually disabeling line 5 at time 1.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"trip_first_cb = PresetTimeCallback(1.0, integrator->affect!(integrator, 5));\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"Now we are set for solving the system again. This time we create our own callback set by combining both Callbacks manually.","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"u0 = NWState(nw)\ncbset = CallbackSet(trip_cb, trip_first_cb)\nprob = ODEProblem(nw, uflat(u0), (0,6), pflat(u0); callback=cbset)\nsol2 = solve(prob, Tsit5());\n# we want to test the reconstruction of the observables # hide\n@test all(!iszero, sol2(sol2.t; idxs=eidxs(sol2,:,:P)).u[begin]) # hide\n@test all(iszero, sol2(sol2.t; idxs=eidxs(sol2,:,:P)).u[end][[1:5...,7]]) # hide\nnothing #hide","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"Then again we plot the solution:","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"plot(sol2; idxs=eidxs(sol2,:,:P))","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"","category":"page"},{"location":"generated/cascading_failure/","page":"Cascading Failure","title":"Cascading Failure","text":"This page was generated using Literate.jl.","category":"page"},{"location":"callbacks/#Callbacks","page":"Callbacks and Events","title":"Callbacks and Events","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Callback-functions are a way of handling discontinuities in differential equations. In a nutshell, the solver checks for some \"condition\" (i.e. a zero crossing of some variable) and calls some \"affect\" if the condition is fulfilled. Within the affect function, it is safe to modify the integrator, e.g. changing some state or some parameter.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Since NetworkDynamics.jl provides nothing more than a RHS for DifferentialEquations.jl, please check their docs on event handling as a general reference. This page is introducing the general concepts, for a hands on example of a simulation with callbacks refer to the Cascading Failure example.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"warning: Warning\nThe ODEProblem contains a reference to exactly one copy of the flat parameter array. If you use callbacks to change those parameters (as we often do), it is advised to copy the parameter array before passing it to the ODEProblem!  Also, this means you need to be careful when using the same prob for multiple subsequent solve calls, as the initial state of the prob object might have changed!","category":"page"},{"location":"callbacks/#Component-based-Callback-functions","page":"Callbacks and Events","title":"Component-based Callback functions","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"In practice, events often act locally, meaning they only depend and act on a specific component or type of component. NetworkDynamics.jl provides a way of defining those callbacks on a component level and automatically combine them into performant VectorContinuousCallback and DiscreteCallback for the whole network.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"The main entry points are the types ContinuousComponentCallback, VectorContinuousComponentCallback and DiscreteComponentCallback. All of those objects combine a ComponentCondition with an ComponentAffect.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"The \"normal\" ContinuousComponentCallback and DiscreteComponentCallback have a condition which returns a single value. The corresponding affect is triggered when the return value hits zero. In contrast, the \"vector\" version has an in-place condition which writes len outputs. When any of those outputs hits zero, the affect is triggered with an additional argument event_idx which tells the effect which dimension encountered the zerocrossing.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"There is a special type PresetTimeComponentCallback which has no explicit condition and triggers the affect at given times. This internally generates a PresetTimeCallback object from DiffEqCallbacks.jl.","category":"page"},{"location":"callbacks/#Defining-the-Callback","page":"Callbacks and Events","title":"Defining the Callback","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"To construct a condition function, you need to tell network dynamics which states and parameters you'd like to \"observe\" within the condition. Within the actual condition, those states will be made available:","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"condition = ComponentCond([:x, :y], [:p1, :p2]) do u, p, t\n    u[:x]  == u[1] # access a state or observable :x at current time\n    p[:p2] == p[2] # access a parameter at current time\n    return some_condition(u[:x], u[:y], ...)\nend","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"In case of a VectorContinuousComponentCallback, the function signature looks slightly different:","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"vectorcondition = ComponentCond([:x, :y], [:p1, :p2]) do out, u, p, t\n    out[1] = some_condition(u[...], p[...])\n    out[2] = some_condition(u[...], p[...])\n    return nothing\nend","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Note that the syms argument (here [:x, :y]) can be used to reference any named state of the component model, this includes \"ordinary\" states, observed, inputs and outputs. The arguments u and p will be passed as SymbolicView objects, which mean it is possible to use the getindex syntax to acces the desired states by name.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"The affect takes a similar form:","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"affect = ComponentAffect([:u], [:p]) do u, p, ctx\n   t = ctx.t # extract data from context\n   obs = NWState(ctx.integrator)[VIndex(ctx.vidx, :obs)] # extract some observed state from context\n   println(\"Trigger affect at t=$t\")\nend\nvectoraffect = ComponentAffect([:u], [:p]) do u, p, event_idx, ctx\n    if event_idx == 1\n        u[:u] = 0 # change state\n    else\n        u[:p] = 0 # change parameter\n    end\nend","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Notably, the syms (here :u) can exclusively refer to \"ordinary\" states, since they are now writable. However the affect gets passed a ctx \"context\" object, which is a named tuple which holds additional context like the integrator object, the component model, the index of the component model, the current time and so on. Please refer to the ComponentAffect docstring for a detailed list.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Lastly we need to define the actual callback object using ContinuousComponentCallback/VectorContinuousComponentCallback:","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"ccb  = ContinuousComponentCallback(condition, affect; kwargs...)\nvccb = VectorContinuousComponentCallback(condition, affect; kwargs...)","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"where the kwargs are passed to the underlying SciMLBase.VectorContinuousCallback to finetune the zerocrossing-detection.","category":"page"},{"location":"callbacks/#Registering-the-Callback","page":"Callbacks and Events","title":"Registering the Callback","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Once the callback is defined, we need to \"attach\" it to the component, for that you can use the methods add_callback! and set_callback!:","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"vert = VertexModel(...)\nadd_callback!(vert, ccb)\nadd_callback!(vert, vccb)","category":"page"},{"location":"callbacks/#Extracting-the-Callback","page":"Callbacks and Events","title":"Extracting the Callback","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"In order to use the callback during simulation, we need to generate a SciMLBase.CallbackSet which contains the conditions and affects of all the component based callbacks in the network. For that we use get_callbacks(::Network):","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"u0 = NWState(u0)\ncbs = get_callbacks(nw)\nprob = ODEProblem(nw, uflat(u0), (0,10), pflat(u0); callback=cbs)\nsol = solve(prob, ...)","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"When combining the component based callbacks to a single callback, NetworkDynamics will check whether states and or parameters changed during the affect and automatically call SciMLBase.auto_dt_reset! and save_parameters! if necessary.","category":"page"},{"location":"callbacks/#Normal-DiffEq-Callbacks","page":"Callbacks and Events","title":"Normal DiffEq Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Besides component based callbacks, it is also possible to use \"normal\" DiffEq callbacks together with NetworkDynamics.jl. It is far more powerful but also more cumbersome compared to the component based callback functions. To access states and parameters of specific components, we heavily rely on the Symbolic Indexing features.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"using SymbolicIndexingInterface as SII\nnw = Network(#= some network =#)\n\ncondition = let getvalue = SII.getsym(nw, VIndex(1:5, :some_state))\n    function(out, u, t, integrator)\n        s = NWState(integrator, u, integrator.p, t)\n        some_state = getvalue(s)\n        out .= some_condition(some_state)\n    end\nend","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Please note a few important things here:","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Symbolic indexing can be costly, and the condition function gets called very often. By using SII.getsym we did some of the work before the callback by creating the accessor function. When handling with \"normal states\" and parameters consider using SII.variable_index and SII.parameter_index for even better access patterns.\nt refers to the current time of the zerocrossing-detection-algorithm. This is different from integrator.t which refers to the current timestep in which the zerocross-detectio takes place..","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"function affect!(integrator, vidx)\n    p = NWParameter(integrator) # get symbolically indexable parameter object\n    p.v[vidx, :some_vertex_parameter] = 0 # change some parameter\n    auto_dt_reset!(integrator)\n    save_parameters!(integrator)\nend","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"The affect function is much more straight forward, as it (typically) is called far less frequent and thus less perfomance critical.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"Once the condition and affect! is defined, you can use the SciMLBase.ContinuousCallback and SciMLBase.VectorContinuousCallback constructors to create the callback.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"note: Introducing discontinuities with adaptive timestepping\nSince changes to u and p mostly introduce discontinuities in the solution, it is recommend to call auto_dt_reset! within the affect to restart integration with small steps afterwards.","category":"page"},{"location":"callbacks/","page":"Callbacks and Events","title":"Callbacks and Events","text":"note: Changing Parameters and Observables\nAn \"observable\" is kind of a \"virtual\" state, which can be reconstructed for a given time t, a given state u and a given set of parameters po = f(u(t) p(t) t)To extract or plot timeseries of observed states under time variant parameters (i.e. parameters that are changed in a callback), those changes need to be recorded using the save_parameters! function whenever p is changed. When using ComponentCallback, NetworkDynamics will automatically check for changes in p and save them if necessary.","category":"page"},{"location":"generated/gas_network/#gas-example","page":"Gas Network","title":"Dynamic Flow in Simple Gas Network","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"This example is based on the paper","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Albertus J. Malan, Lukas Rausche, Felix Strehle, Sören Hohmann, Port-Hamiltonian Modelling for Analysis and Control of Gas Networks, IFAC-PapersOnLine, Volume 56, Issue 2, 2023, https://doi.org/10.1016/j.ifacol.2023.10.193.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"and tries to replicate a simple simulation of flow in a 3-node gas network.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"This example can be dowloaded as a normal Julia script here.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"We start by importing the necessary packages:","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"using NetworkDynamics\nusing ModelingToolkit\nusing DynamicQuantities\nusing ModelingToolkit: D as Dt, t as t\nusing Test\nusing StaticArrays\nusing DataInterpolations\nusing OrdinaryDiffEqTsit5\nusing CairoMakie\nCairoMakie.activate!(type=\"svg\") #hide","category":"page"},{"location":"generated/gas_network/#Node-Models","page":"Gas Network","title":"Node Models","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"In this example, we use equation-based modeling using ModelingToolkit.jl. To verify the equations on a basic level, we also provide units to everything to perform dimensionality checks.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"There are 2 node models used in the paper. The first node type has a constant pressure. Additionally, we add some \"internal\" state q̃_inj which we want to plot later (see also Observables).","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"@mtkmodel ConstantPressureNode begin\n    @parameters begin\n        p_set, [description=\"Constant pressure setpoint\", unit=u\"Pa\"]\n    end\n    @variables begin\n        p(t) = p_set, [description=\"Pressure\", unit=u\"Pa\", output=true]\n        q̃_nw(t), [description=\"aggregated flow from pipes into node\", unit=u\"m^3/s\", input=true]\n        q̃_inj(t), [description=\"internal state for introspection\", unit=u\"m^3/s\"]\n    end\n    @equations begin\n        p ~ p_set\n        q̃_inj ~ -q̃_nw\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"The second node model is a variable pressure node. It has one output state (the pressure) and one input state, the aggregated flows from the connected pipes. As an internal state we have the injected flow from our source/load. The source/load behavior itself is provided via a time-dependent function.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"@mtkmodel VariablePressureNode begin\n    @structural_parameters begin\n        load_profile # time dependent load profile\n    end\n    @constants begin\n        load_unit = 1, [description=\"unit of the load profile\", unit=u\"m^3/s\"]\n    end\n    @parameters begin\n        C, [description=\"Lumped capacitance of connected pipes\", unit=u\"m^4 * s^2 / kg\"]\n    end\n    @variables begin\n        p(t)=5e6, [description=\"Pressure\", unit=u\"Pa\", output=true]\n        q̃_inj(t), [description=\"external injection into node\", unit=u\"m^3/s\"]\n        q̃_nw(t), [description=\"aggregated flow from pipes into node\", unit=u\"m^3/s\", input=true]\n    end\n    @equations begin\n        q̃_inj ~ load_profile(t) * load_unit\n        C * Dt(p) ~ q̃_inj + q̃_nw # (30)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/gas_network/#Pipe-Model","page":"Gas Network","title":"Pipe Model","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"The pipe is modeled as a first-order ODE for the volumetric flow at the dst end. It has two inputs: the pressure at the source and the pressure at the destination end. Later on, we'll specify the model to be antisymmetric, thus the flow is calculated explicitly for the destination end, but the source end will just receive that times (-1).","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"@mtkmodel Pipe begin\n    @parameters begin\n        L, [description=\"Length of pipe\", unit=u\"m\"]\n        D, [description=\"Diameter of pipe\", unit=u\"m\"]\n        A, [description=\"Cross-sectional area of pipe\", unit=u\"m^2\"]\n        sinθ, [description=\"Angle of inclination\" ]\n        γ, [description=\"Friction efficiency factor\"]\n        η, [description=\"Dynamic viscosity\", unit=u\"kg/(m*s)\"]\n        r, [description=\"Pipe roughness\", unit=u\"m\"]\n        g, [description=\"Gravitational acceleration\", unit=u\"m/s^2\"]\n        T, [description=\"simulation temperature\", unit=u\"K\"]\n        Tc, [description=\"crictical temperature\", unit=u\"K\"]\n        pc, [description=\"critical pressure\", unit=us\"Pa\"]\n        Rs, [description=\"Specific gas constant for natural gas\", unit=us\"J/(kg*K)\"]\n        c̃, [description=\"Speed of sound in fluid at standard conditions\", unit=u\"m/s\"]\n        ρ̃, [description=\"standard density\", unit=u\"kg/m^3\"]\n        p̃, [description=\"standard pressure\", unit=us\"Pa\"]\n    end\n    @variables begin\n        p_src(t), [description=\"Pressure at source end\", unit=us\"Pa\", input=true]\n        p_dst(t), [description=\"Pressure at destination end\", unit=us\"Pa\", input=true]\n        q̃(t)=1, [description=\"Flow through pipe\", unit=u\"m^3/s\", output=true]\n        Re(t), [description=\"Reynolds number\"]\n        λ(t), [description=\"Friction factor\"]\n        λe(t), [description=\"Effective friction factor\"]\n        pM(t), [description=\"mean pressure\", unit=us\"Pa\"]\n        Z(t), [description=\"compressibility factor\"]\n        ρ(t), [description=\"density\", unit=u\"kg/m^3\"]\n        c(t), [description=\"speed of sound\", unit=u\"m/s\"]\n    end\n    @equations begin\n        Z ~ 1 - 3.52 * pM/pc * exp(-2.26*(T/Tc)) + 0.274 * (pM/pc)^2 * exp(-1.878*(T/Tc)) # (5)\n        ρ ~ pM / (Rs * T * Z) # (4)\n\n        # TODO: Whats the correct speed of sound?\n        c ~ sqrt(T * Rs * Z) # (4) # pressure/temp dependent\n        # c ~ c̃                   # \"standard\" speed of sound based on standard conditions\n\n        # TODO: Whats the correct Reynolds number?\n        Re ~ (ρ * abs(q̃*p̃/pM) * D) / (η * A) # (6) # based \"actual\" conditions\n        # Re ~ (ρ̃ * abs(q̃) * D) / (η * A) # (6)   # based on standard conditions\n\n        λ ~ ifelse(Re < 2300,\n            64/Re, # laminar (7)\n            (2*log10(4.518/Re * log10(Re/7) + r/(3.71*D)))^(-2) # turbulent (8)\n        )\n        λe ~ λ/γ^2 # (10)\n        pM ~ 2/3*(p_src + p_dst - (p_src*p_dst)/(p_src + p_dst)) # (20)\n\n        Dt(q̃) ~ A/(L*ρ̃)*(-(λe * ρ̃^2 * c^2 * L * abs(q̃))/(2 * D * A^2 * pM) * q̃ - (g * L * sinθ)/(c^2) * pM + (p_src - p_dst)) # (31)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/gas_network/#Parametrization","page":"Gas Network","title":"Parametrization","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"The parameterization turned out to be a bit tricky. There might be errors in there.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Some of them are quite cleare and explicitly given.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"g = 9.81u\"m/s^2\"       # that we just know\nRs = 518.28u\"J/(kg*K)\" # Specific gas constant for natural gas\nη  = 1e-5u\"kg/(m*s)\"   # Dynamic viscosity\npc = 46.5u\"bar\"        # Critical pressure\np̃  = 1.01325u\"bar\"     # standard pressure\nTc = 190.55u\"K\"        # critical temperature\nT̃  = 273.15u\"K\"        # standard temperature\nT  = 278u\"K\"           # simulation temperature\nγ  = 0.98              # friction efficiency factor\nr  = 0.012u\"mm\"        # pipe roughness\nD  = 0.6u\"m\"           # pipe diameter\n\nL₁₂ = 90u\"km\"\nL₁₃ = 80u\"km\"\nL₂₃ = 100u\"km\"\nΔh₁ = 0u\"km\"           # this value is different for different sims in the paper\np₁_set = 50u\"bar\"\nnothing # hide","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"The geometric parameters for the pipes can be directly derived.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"A = π/4 * D^2\nsinθ₁₂ = ustrip(Δh₁ / L₁₂)\nsinθ₁₃ = ustrip(Δh₁ / L₁₃)\nsinθ₂₃ = 0.0\nnothing # hide","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Lastly, we need to calculate the compressibility factor, the speed of sound, and the density at standard conditions:","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Z̃ = 1 - 3.52 * p̃/pc * exp(-2.26*(T̃/Tc)) + 0.274 * (p̃/pc)^2 * exp(-1.878*(T̃/Tc)) # (5)\nc̃ = sqrt(T̃ * Rs * Z̃) # (4) at standard conditions\nρ̃ = p̃ / (Rs * T̃ * Z̃) # (4) at standard conditions\n\nnothing # hide","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"The equivalent \"pressure capacity\" at the nodes is calculated as a sum of the connected pipe parameters according to (28).","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Here we use definitions based on the speed and \"standard\" conditions.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"C₂ = L₁₂*A/(2*ρ̃*c̃^2) + L₂₃*A/(2*ρ̃*c̃^2) # (28)\nC₃ = L₁₃*A/(2*ρ̃*c̃^2) + L₂₃*A/(2*ρ̃*c̃^2) # (28)\nnothing #hide","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Alternatively, we could calculate Z2 and Z3 based on the actual pressure and simulation temperature. Then we could calculate the speed of sound for the \"correct\" conditions at the node. It seems to have very little effect on the actual results, so I kept it simple.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"nothing #hide","category":"page"},{"location":"generated/gas_network/#Load-Profile","page":"Gas Network","title":"Load Profile","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"The paper specifies the load profile at two nodes. We use the package DataInterpolations.jl to get a callable object which represents this piecewise linear interpolation.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Currently, the linear interpolation does not support any units yet. To satisfy the static unit check, we multipy the interpolation output by a constant 1 of that unit.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Note however, that the unit check is only performed at the construction of the model. Later on, when the nummeric code will be generated from the symbolic representation, all units will be stripped.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"note: Discontinuities in RHS\nThe piecewise linear interpolated function creates discontinuities in the RHS of the system. However, since we know the times exactly, we can handle this by simply giving a list of explicit tstops to the solve command, to make sure those are hit exactly.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"load2 = LinearInterpolation(-1*Float64[20, 30, 10, 30, 20], [0, 4, 12, 20, 24]*3600.0; extrapolation=ExtrapolationType.Constant)\nload3 = LinearInterpolation(-1*Float64[40, 50, 30, 50, 40], [0, 4, 12, 20, 24]*3600.0; extrapolation=ExtrapolationType.Constant)\nModelingToolkit.get_unit(::LinearInterpolation, _ ) = 1.0 # type piracy!\nnothing #hide","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"As a workaround we had to explicitly define LinearInterpolations as unitless, which is type piracy! Don't to this in any package code!","category":"page"},{"location":"generated/gas_network/#Building-the-Network","page":"Gas Network","title":"Building the Network","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"To build the network, we first need to define the components. This is a two-step process:","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"first create the symbolic System using ModelingToolkit\nsecondly build a NetworkDynamics component model (VertexModel/EdgeModel) based on the symbolic system.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"In the first step we can use the keyword arguments to pass \"default\" values for our parameters and states. Those values will be automatically transferred to the metadata of the component model in the second step.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"The second step requires to define the interface variables, i.e. what are the \"input\" states of your component model and what are the \"output\" states. For VertexModel the input state is the aggregated flow of all connected pipes. The output state is the pressure of the node.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"@named v1_mtk = ConstantPressureNode(p_set=p₁_set)\nv1 = VertexModel(v1_mtk, [:q̃_nw], [:p]; name=:v1, vidx=1)","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"@named v2_mtk = VariablePressureNode(C=C₂, load_profile=load2)\nv2 = VertexModel(v2_mtk, [:q̃_nw], [:p]; name=:v2, vidx=2)","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"@named v3_mtk = VariablePressureNode(C=C₃, load_profile=load3)\nv3 = VertexModel(v3_mtk, [:q̃_nw], [:p]; name=:v3, vidx=3)","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"For the edge model we have two inputs: the pressure on both source and destination end. There is a single output state: the volumetric flow. However, we also need to tell NetworkDynamics about the coupling type. In this case we use AntiSymmetric, which means that the source end will receive the same flow, just with inverted sign.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"@named e12_mtk = Pipe(; L=L₁₂, sinθ=sinθ₁₂, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)\n@named e13_mtk = Pipe(; L=L₁₃, sinθ=sinθ₁₃, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)\n@named e23_mtk = Pipe(; L=L₂₃, sinθ=sinθ₂₃, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)\n\ne12 = EdgeModel(e12_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e12, src=1, dst=2)\ne13 = EdgeModel(e13_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e13, src=1, dst=3)\ne23 = EdgeModel(e23_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e23, src=2, dst=3)","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"To build the network object we just need to pass the vertices and edges to the constructor.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Note that we've used the vidx and src/dst keywords in the constructors to define for each component to which \"part\" of the network it belongs.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"This means the constructor can automatically construct a graph based on that information and we don't need to pass it explicitly.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"nw = Network([v1, v2, v3], [e12, e13, e23])","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"As a result, we recive a network with 3 unique types (v2 and v3 are similar but structurally different, because both functions capure a unique loadprofile function).","category":"page"},{"location":"generated/gas_network/#Finding-a-Steady-State","page":"Gas Network","title":"Finding a Steady State","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"To simulate the system, we first need to find a steady state. As a \"guess\" for that, we create a NWState object from the network. This will allocate flat arrays for states u and parameters p and fill them with the default values.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"uguess = NWState(nw)","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"This is not a steady state of the system however. To find a true steady state, we want to ensure that the LHS of the system is zero.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"We can use the find_fixpoint from NetworkDynamics.jl to initialize the system. Internally, this uses a nummerical solve for the rootfind problem 0 = rhs. The result is automaticially wrapped as a NWState object.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"u0 = find_fixpoint(nw, uguess, t=0)","category":"page"},{"location":"generated/gas_network/#Solving-the-ODE","page":"Gas Network","title":"Solving the ODE","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Using this as our initial state we can create the actual ODEProblem. Since the ODE always operates on flat state and parameter arrays, we use uflat and pflat to extract them.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"prob = ODEProblem(nw, uflat(u0), (0.0,24*3600), copy(pflat(u0)))\nsol = solve(prob, Tsit5(), tstops=[0,4,12,20,24]*3600)\nnothing #hide","category":"page"},{"location":"generated/gas_network/#Inspect-the-Solution","page":"Gas Network","title":"Inspect the Solution","text":"","category":"section"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Inspecting the solution is all which is left to do.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"xticks = ((0:4:24)*3600, string.(0:4:24)) # its nice to display hours\nfig = begin\n    _fig = Figure()\n    row = 1\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"pressure [Pa]\", title=\"Pressure at nodes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    ylims!(ax, 47.9e5, 49.9e5)\n    for i in 1:3\n        lines!(ax, sol, idxs=vidxs(nw, i, :p); label=\"v$i\", color=Cycled(i))\n    end\n    axislegend(ax)\n    row += 1\n\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"flow [m³/s]\", title=\"Flow through pipes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    ylims!(ax, 16, 44)\n    for i in 1:2\n        lines!(ax, sol, idxs=eidxs(nw, i, :q̃); label=\"e$i flow\", color=Cycled(i))\n    end\n    axislegend(ax, position=:rb)\n    row += 1\n    _fig\nend","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Notably, the \"internal\" states defined in the symbolic models are not \"states\" in the sense of the ODE. For example, we captured the load profile in the q̃_inj state of the VariablePressureNode. The only dynamic state of the model however is p. Using the \"observables\" mechanism from SciML, which is implemented by NetworkDynamics, we can reconstruct those \"optimized\" states which have been removed symbolically. Here we plot the reconstructed load profile of nodes 2 and 3. Also, we know that node 1 is infinitely stiff, acting as an infinite source of volumetric flow. We can reconstruct this flow too.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"fig = begin\n    _fig = Figure()\n    row = 1\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"flow [m³/s]\", title=\"Flow at nodes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    lines!(ax, sol, idxs=vidxs(nw, 1, :q̃_inj); label=\"v1 compensation\", color=Cycled(1))\n    for i in 2:3\n        lines!(ax, sol, idxs=vidxs(nw, i, :q̃_inj); label=\"v$i load profile\", color=Cycled(i))\n    end\n    axislegend(ax, position=:rc)\n    _fig\nend","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"Lastly we want to observe two internal states of the pipes: the Reynolds number and the mean pressure. We see, that we're purely in the turbulent flow regime.","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"fig = begin\n    _fig = Figure()\n    row = 1\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"Reynolds number\", title=\"Reynolds number\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    for i in 1:3\n        lines!(ax, sol, idxs=eidxs(nw, i, :Re); label=\"e $i\", color=Cycled(i))\n    end\n    hlines!(ax, 2300, color=:black, linestyle=:dash, label=\"L/T transition\")\n    axislegend(ax, position=:rb)\n    row += 1\n\n    ax = Axis(_fig[row, 1]; xlabel=\"time [h]\", ylabel=\"Mean pressure [Pa]\", title=\"Mean pressure in pipes\", xticks)\n    xlims!(ax, sol.t[begin], sol.t[end])\n    for i in 1:3\n        lines!(ax, sol, idxs=eidxs(nw, i, :pM); label=\"e $i\", color=Cycled(i))\n    end\n    axislegend(ax, position=:rb)\n    _fig\nend","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"","category":"page"},{"location":"generated/gas_network/","page":"Gas Network","title":"Gas Network","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#NetworkDynamics","page":"General","title":"NetworkDynamics","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"The NetworkDynamics.jl package simulates the dynamics of complex networks. It provides an interface  between the Graphs.jl and the  DifferentialEquations.jl packages and facilitates the simulation of  highly efficient dynamic networks by describing the local dynamics of the edges and vertices of the network.","category":"page"},{"location":"","page":"General","title":"General","text":"The core idea of this package is to define the global dynamics of a complex network in terms of local dynamics: each node and each edge exhibits some local dynamics defined as an input-output system. The graph topology describes, how the local dynamical systems are interconnected. To learn more check out the docs on the Mathematical Model behind NetworkDynamics.jl. For basic terminology see the Wikipedia article on Graph Theory.","category":"page"},{"location":"","page":"General","title":"General","text":"Main features:","category":"page"},{"location":"","page":"General","title":"General","text":"Clear separation of local dynamics and topology: you can easily change the topology of your system or switch out dynamic components.\nHigh performance when working with heterogeneous models: you can have different local dynamics in different parts of your network.\nSymbolic Indexing into solutions and states: NetworkDynamics keeps track of the states of each individual subsystem.\nDiverse execution schemes: NetworkDynamics exploits the known interdependencies between components to auto parallelize execution, even on GPUs!\nEquation based models: you can model local dynamics using  ModelingToolkit.jl and then combine them into larger networks using NetworkDynamics.jl!","category":"page"},{"location":"#Where-to-begin?","page":"General","title":"Where to begin?","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"To learn how to implement your own models and understand the underlying modeling ideas of NetworkDynamics you should  first read the Mathematical Model section, followed by the Network Construction section.","category":"page"},{"location":"","page":"General","title":"General","text":"If you prefer to look at some concrete code first check out the Getting Started tutorial!","category":"page"},{"location":"#Installation","page":"General","title":"Installation","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Install Julia:","category":"page"},{"location":"","page":"General","title":"General","text":"Julia Installation\nFind your OS and follow the instructions for the installation","category":"page"},{"location":"","page":"General","title":"General","text":"Install NetworkDynamics.jl with Julia's package manager:","category":"page"},{"location":"","page":"General","title":"General","text":"(v1.11) pkg> add NetworkDynamics","category":"page"},{"location":"","page":"General","title":"General","text":"To learn more about how to use Julia you can visit: Modern Julia Workflows","category":"page"},{"location":"#Reproducibility","page":"General","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"<details><summary>Direct dependencies used for this documentation:</summary>","category":"page"},{"location":"","page":"General","title":"General","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"General","title":"General","text":"</details>","category":"page"},{"location":"","page":"General","title":"General","text":"<details><summary>Julia Version:</summary>","category":"page"},{"location":"","page":"General","title":"General","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"General","title":"General","text":"</details>","category":"page"},{"location":"","page":"General","title":"General","text":"<details><summary>Full Manifest:</summary>","category":"page"},{"location":"","page":"General","title":"General","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"General","title":"General","text":"</details>","category":"page"},{"location":"#Funding","page":"General","title":"Funding","text":"","category":"section"},{"location":"","page":"General","title":"General","text":"Development of this project was in part funded by the German Federal Ministry for Economic Affairs and Climate Action  as part of the OpPoDyn-Project (Project ID 01258425/1, 2024-2027).","category":"page"},{"location":"","page":"General","title":"General","text":"<img src=\"assets/bmwk_logo_en.svg\" width=\"300\"/>","category":"page"},{"location":"network_construction/#Network-Construction","page":"Network Construction","title":"Network Construction","text":"","category":"section"},{"location":"network_construction/#Building-a-Network","page":"Network Construction","title":"Building a Network","text":"","category":"section"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"The main type of NetworkDynamics.jl is a Network. A network bundles various component models (edge and vertex models) together with a graph to form a callable object which represents the right hand side (RHS) of the overall dynamical system, see Mathematical Model.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"A Network is build by passing a graph g, vertex models vertexm and edge models edgem to the Network constructor:.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"nw = Network(g, vertexm, edgem; kwargs...)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"Two important keywords for the Network constructor are:","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"execution:   Defines the ExecutionStyle of the coreloop, e.g. SequentialExecution{true}().   A execution style is a special Julia object, which tells the backend how to parallelize (e.g. ThreadedExecution{true}() will use native Julia threads to parallelize the RHS call).   A list of available executions styles can be found under Execution Types in the API.\naggregator:   Instructs the backend how to perform the aggregation and which aggregation function to use.   Aggregation is the process of creating a single vertex input by reducing over the outputs of adjecent edges of said vertex. The aggregator contains both the function and the algorithm. E.g. SequentialAggregator(+) is a sequential aggregation by summation. A list of availabe Aggregators can be found under Aggregators in the API.","category":"page"},{"location":"network_construction/#Graphless-Constructor","page":"Network Construction","title":"Graphless Constructor","text":"","category":"section"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"If each of the network components has a \"graphelement\" metadata, we may omit the explicit graph.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"nw = Network(vertexm, edgem)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"The graphelement metadata can be set using the following syntax:","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"VertexModel(; ..., vidx=1)         # places vertex at position 1\nEdgeModel(; ..., src=1, dst=2)     # places edge between 1 and 2\nEdgeModel(; ..., src=:v1, dst=:v2) # places edge between vertices with names `:v1` and `:v2`","category":"page"},{"location":"network_construction/#Building-VertexModels","page":"Network Construction","title":"Building VertexModels","text":"","category":"section"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"This chapter will walk you through the most important aspects of defining a custom vertex model. For a list of all keyword arguments please check out the docstring of VertexModel.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"As an example, we'll construct an second order kuramoto model.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"using NetworkDynamics #hide\nfunction kuramoto_f!(dv, v, esum, p, t)\n    M, P, D = p\n    dv[1] = v[2]\n    dv[2] = (P - D*v[2] + esum[1])/M\n    nothing\nend\nfunction kuramoto_g!(y, v, esum, p, t)\n    y[1] = v[1]\n    nothing\nend\nVertexModel(; f=kuramoto_f!, g=kuramoto_g!, dim=2, pdim=3, outdim=1)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"Those keywords are the minimum metadata we need to provide.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"However there is a problem: the vertex is classified as a FeedForward vertex, which is unnecessary. We can improve the implementation of g according to the Feed Forward Behavior section.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"function kuramoto_g_noff!(y, v, p, t)\n    y[1] = v[1]\n    nothing\nend\nVertexModel(; f=kuramoto_f!, g=kuramoto_g_noff!, dim=2, pdim=3, outdim=1)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"To simplify your programming and avoid explicitly writing the above trivial output function you can use StateMask. By writing","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"VertexModel(; f=kuramoto_f!, g=StateMask(1:1), dim=2, pdim=3)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"we are instructing the vertex model, that the output is part of the states x[1:1]. This results in the following changes:","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"outdim is removed because it can be inferred from StateMask\noutsym is not a generic :o any more but inferred from the state symbols.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"We can be even less verbose by writing g=1:1 or just g=1.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"Lastly, we define improved names for our states and parameters as well as assigning a position in the graph to enable the graphless network construction. Whenever you provide a sym keyword the corresponding dim keyword stops being neccessary. So, we end up with a relatively short definition","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"VertexModel(; f=kuramoto_f!, g=1,\n              sym=[:θ, :ω], psym=[:M=>1, :P=>0.1, :D=>0],\n              insym=[:P_nw], name=:swing, vidx=1)","category":"page"},{"location":"network_construction/#Building-EdgeModels","page":"Network Construction","title":"Building EdgeModels","text":"","category":"section"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"This chapter walks you through the most important aspects when defining custom edge models. For a list of all keyword arguments please check the docstring of EdgeModel.","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"As an example edge model we define a standard sinusoidal coupling between the vertices in our network. The full definition is:","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"function edge_f!(de, e, vsrc, vdst, p, t)\n    nothing\nend\nfunction edge_g!(ysrc, ydst, e, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\n    ysrc[1] = -ydst[1]\nend\nEdgeModel(; f=edge_f!, g=edge_g!, dim=0, pdim=1, outdim=1)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"This is a purely \"static\" edge without internal states. This means we can omit f and dim entirely. Also, we can define a variant of g without the e input","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"function edge_g_ff!(ysrc, ydst, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\n    ysrc[1] = -ydst[1]\nend\nEdgeModel(;g=edge_g_ff!, pdim=1, outdim=1)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"which classifies as a PureFeedForward edge. In cases like this, where the edge is actually anti-symmetrical we can define a single sided output function and wrap it in an AntiSymmetric object:","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"function edge_g_s!(ydst, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\nend\nEdgeModel(;g=AntiSymmetric(edge_g_ff!), pdim=1, outdim=1)","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"This can also lead to briefer output naming. Available single sided wrappers are:","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"Directed (no coupling at src),\nAntiSymmetric (same coupling at src and dst),\nSymmetric (inverse coupling at dst) and\nFiducial (define separate g for both ends).","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"Once again we can add additonal data like defining a src and dst index","category":"page"},{"location":"network_construction/","page":"Network Construction","title":"Network Construction","text":"function edge_g_s!(ydst, vsrc, vdst, p, t)\n    ydst[1] = p[1] * sin(vsrc[1] - vdst[1])\nend\nEdgeModel(;g=AntiSymmetric(edge_g_ff!), psym=:K=>1, outsym=:P, insym=:θ, src=1, dst=4)","category":"page"}]
}
