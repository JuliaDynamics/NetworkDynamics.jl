<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · NetworkDynamics</title><meta name="title" content="Functions · NetworkDynamics"/><meta property="og:title" content="Functions · NetworkDynamics"/><meta property="twitter:title" content="Functions · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#VertexFunctions"><span>VertexFunctions</span></a></li><li><a class="tocitem" href="#EdgeFunctions"><span>EdgeFunctions</span></a></li><li><a class="tocitem" href="#Constructor"><span>Constructor</span></a></li></ul></li><li><a class="tocitem" href="../parameters/">Parameter handling</a></li><li><a class="tocitem" href="../Multithreading/">Multi-Threading</a></li><li><a class="tocitem" href="../Library/">Library</a></li><li><a class="tocitem" href="../accessing_edge_variables/">Accessing internal edge values</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_network_dynamics/">Getting started</a></li><li><a class="tocitem" href="../directed_and_weighted_graphs/">Directed and weighted graphs</a></li><li><a class="tocitem" href="../heterogeneous_system/">Heterogeneous systems</a></li><li><a class="tocitem" href="../SDEVertex/">Stochastic differential equations</a></li><li><a class="tocitem" href="../kuramoto_delay/">Delay differential equations</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PIK-ICoNe/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/PIK-ICoNe/NetworkDynamics.jl/blob/main/docs/src/BasicConstructors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><p>The key  <a href="../Library/#NetworkDynamics.network_dynamics"><code>network_dynamics</code></a> assembles the dynamics of the whole network from functions for the single vertices and edges of the graph <code>g</code>. These functions have to be wrapped in types <code>VertexFunction</code> and <code>EdgeFunction</code> which store additional information on dimension and coupling type. Both have several subtypes that account for the different classes of equations that may represent the local dynamics. At the moment, algebraic (static) equations, ordinary differential equations (ODEs) and delay differential equations (DDEs) are supported:</p><pre><code class="language-julia hljs"># VertexFunctions
StaticVertex(vertexfunction!, dimension, symbol)
ODEVertex(vertexfunction!, dimension, mass_matrix, symbol)
DDEVertex(vertexfunction!, dimension, mass_matrix, symbol)

# EdgeFunctions
StaticEdge(edgefunction!, dimension, coupling, symbol)
ODEEdge(edgefunction!, dimension, mass_matrix, coupling, symbol)
StaticDelayEdge(edgefunction!, dimension, mass_matrix, coupling, symbol)</code></pre><h1 id="VertexFunctions"><a class="docs-heading-anchor" href="#VertexFunctions">VertexFunctions</a><a id="VertexFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#VertexFunctions" title="Permalink"></a></h1><p>Given a set of (algebraic or differential) equations describing a node or an edge the first step is to turn them into a <strong>mutating</strong> function <code>vertexfunction!</code>. Depending on the class of the function <code>vertexfunction!</code>, the constructors <code>StaticVertex</code>, <code>ODEVertex</code> or <code>DDEVertex</code> are called in order to turn <code>vertexfunction!</code> into a <code>VertexFunction</code> object compatible with <a href="../Library/#NetworkDynamics.network_dynamics"><code>network_dynamics</code></a>.</p><p>Since in general the state of a vertex depends on the vertex value itself as well as on the in- and outgoing edges, the function <code>vertexfunction!</code> has to respect one of the following calling syntaxes.</p><pre><code class="language-julia hljs"># For static nodes
function vertexfunction!(v, edges, p, t) end
# For dynamic nodes
function vertexfunction!(dv, v, edges, p, t) end
# For delay nodes
function vertexfunction!(dv, v, edges, h_v, p, t) end</code></pre><p>Here <code>dv</code>, <code>v</code>, <code>p</code>, and <code>t</code> are the usual ODE arguments, while <code>edges</code> is an array containing the edges for which the vertex is the destination (corresponding to incoming edges for directed graphs). In the delay case, the array <code>h_v</code> denotes the vertex history. The typical case of diffusive coupling on a directed graph could be described as</p><pre><code class="language-julia hljs">function vertex!(dv, v, edges, p, t)
    dv .= 0.0
    for e in edges
        dv .+= e
    end
    nothing
end</code></pre><h3 id="[StaticVertex](@ref)"><a class="docs-heading-anchor" href="#[StaticVertex](@ref)"><a href="../Library/#NetworkDynamics.StaticVertex"><code>StaticVertex</code></a></a><a id="[StaticVertex](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[StaticVertex](@ref)" title="Permalink"></a></h3><p>If a vertex is described by an algebraic equation  <code>vertexfunction!(v, edges, p, t)</code>, i.e. <code>dv = 0</code> the <code>VertexFunction</code> is constructed as</p><pre><code class="language-julia hljs">StaticVertex(vertexfunction!, dim, sym)</code></pre><p>Here, <strong>dim</strong> is the number of independent variables in the vertex equations and <strong>sym</strong> is an array of symbols for these variables. For example, if a node models a constant input <span>$I = p$</span>, then <code>dim = 1</code> and <code>sym = [:I]</code>. For more details on the use of symbols, check out the <a href="../getting_started_with_network_dynamics/#getting_started">Getting started</a> tutorial and the Julia <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">documentation</a>. The use of symbols makes it easier to select variables of interest from the solution object.</p><h3 id="[ODEVertex](@ref)"><a class="docs-heading-anchor" href="#[ODEVertex](@ref)"><a href="../Library/#NetworkDynamics.ODEVertex"><code>ODEVertex</code></a></a><a id="[ODEVertex](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[ODEVertex](@ref)" title="Permalink"></a></h3><p>If a vertex has local dynamics <code>vertexfunction!(dv, v, edges, p, t)</code> described by an ODE, the <code>VertexFunction</code> is contructed as</p><pre><code class="language-julia hljs">ODEVertex(vertexfunction!, dim, mass_matrix, sym)</code></pre><p>As above, <strong>dim</strong> is the number of independent variables in the vertex equations and <strong>sym</strong> corresponds to the symbols of these variables.</p><p><strong>mass_matrix</strong> is an optional argument that defaults to the identity matrix <code>I</code>. If a mass matrix M is given, the local system <code>M * dv = vertexfunction!</code> will be solved. <code>network_dynamics</code> assembles all local mass matrices into one global mass matrix that can be passed to a differential equation solver like <code>Rodas4</code>.</p><p>One may also call ODEVertex with keyword arguments, omitting optional arguments:</p><pre><code class="language-julia hljs">ODEVertex(; f=vertexfunction!, dim=dim)</code></pre><p>The function then defaults to using the identity as mass matrix and <code>[:v for i in 1:dimension]</code> as symbols.</p><h3 id="[DDEVertex](@ref)"><a class="docs-heading-anchor" href="#[DDEVertex](@ref)"><a href="../Library/#NetworkDynamics.DDEVertex"><code>DDEVertex</code></a></a><a id="[DDEVertex](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[DDEVertex](@ref)" title="Permalink"></a></h3><p>If a vertex has local dynamics described by a delay differential equation (DDE) the local dynamics need to have the signature <code>vertexfunction!(dv, v, edges, h_v, p, t)</code>, where <code>h_v</code> is an automatically generated wrapper of the global history function, providing history values for<code>v</code>. Then the <code>VertexFunction</code> is constructed as</p><pre><code class="language-julia hljs">DDEVertex(vertexfunction!, dim, mass_matrix, sym)</code></pre><p>As before, <strong>dim</strong> is the number of independent variables in the vertex function and <strong>sym</strong> describes the symbols of the variables. The <strong>mass matrix</strong> is optional and defaults to the identity matrix <code>I</code>.</p><p>As above, the DDEVertex function can also be called without the optional arguments:</p><pre><code class="language-julia hljs">DDEVertex(; f=vertexfunction!, dim=dim)</code></pre><h2 id="EdgeFunctions"><a class="docs-heading-anchor" href="#EdgeFunctions">EdgeFunctions</a><a id="EdgeFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#EdgeFunctions" title="Permalink"></a></h2><p>Similar to the case of vertices, an edge is described by <strong>mutating</strong> function <code>edgefunction!</code>. At the moment the constructors <code>StaticEdge</code>, <code>ODEEdge</code>, and <code>StaticDelayEdge</code> are available. <code>edgefunction!</code> has to respect one of the following syntaxes:</p><pre><code class="language-julia hljs"># For static edges
function edgefunction!(e, v_s, v_d, p, t) end
# For dynamics edges
function edgefunction!(de, e, v_s, v_d, p, t) end
# For static delay edges
function edgefunction!(e, v_s, v_d, h_v_s, h_v_d, p, t) end</code></pre><p>Just like above, <code>de</code>, <code>e</code>, <code>p</code> and <code>t</code> are the usual ODE arguments, while <code>v_s</code> and <code>v_d</code> are the source and destination vertices respectively and <code>h_v_s</code> and <code>h_v_d</code> the corresponding history arrays.</p><h3 id="[StaticEdge](@ref)"><a class="docs-heading-anchor" href="#[StaticEdge](@ref)"><a href="../Library/#NetworkDynamics.StaticEdge"><code>StaticEdge</code></a></a><a id="[StaticEdge](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[StaticEdge](@ref)" title="Permalink"></a></h3><p>Static here means, that the edge value described by <code>edgefunction!</code> only depends on the values of the vertices the edge connects to and that no derivative of the edge&#39;s internal state is involved. One very simple and natural example is a diffusive edge:</p><pre><code class="language-julia hljs">edgefunction! = (e, v_s, v_d, p, t) -&gt; e .= v_s .- v_d</code></pre><p>In this case the <code>EdgeFunction</code> is constructed by</p><pre><code class="language-julia hljs">StaticEdge(edgefunction!, dim, coupling, sym)</code></pre><p>The keywords are the same as for the vertices, except from the additional keyword <strong>coupling</strong>, which describes if the <code>EdgeFunction</code> is intended for a (<code>:directed</code>) or for an undirected graph (<code>{:undirected, :symmetric, :antisymmetric, :fiducial}</code>). <code>:directed</code> is intended for directed graphs. <code>:undirected</code> is the default option and is only compatible with SimpleGraph. In this case the <code>edgefunction!</code> should specify the coupling from a source vertex to a destination vertex. <code>:symmetric</code> and <code>:antisymmetric</code> trigger performance optimizations, if <code>edgefunction!</code> has that symmetry property. <code>:fiducial</code> lets the user specify both the coupling from source to destination, as well as the coupling from destination to source and is intended for advanced users.</p><h3 id="[ODEEdge](@ref)"><a class="docs-heading-anchor" href="#[ODEEdge](@ref)"><a href="../Library/#NetworkDynamics.ODEEdge"><code>ODEEdge</code></a></a><a id="[ODEEdge](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[ODEEdge](@ref)" title="Permalink"></a></h3><p>For problems where <code>edgefunction!</code> describes the differential of an edge value, we use the <code>ODEEdge</code> function. An example for such a system is given by:</p><pre><code class="language-julia hljs">edgefunction! = (de, e, v_s, v_d, p, t) -&gt; de .= 1000 * (v_s .- v_d .- e)</code></pre><p>The <code>EdgeFunction</code> object is constructed as</p><pre><code class="language-julia hljs">ODEEdge(edgefunction!, dim, coupling, mass_matrix, sym)</code></pre><p>The keywords are the same as above for the <code>StaticEdge</code>. For <code>ODEEdge</code> the same simplified construction rules apply when keyword arguments are used, except that the coupling type has to be specified explicitly to avoid ambiguities. The available coupling tyes are only <code>:directed, :undirected, :fiducial</code>. For <code>:undirected</code> coupling the internal dimension of the EdgeFunction is doubled in order to resolve both directions in an undirected network. Remember to specify 2 initial conditiosn for every edge in that case.</p><pre><code class="language-julia hljs">ODEEdge(; f=edgefunction!, dim=n, coupling=:undirected)</code></pre><p>In this case the function defaults to using the identity matrix as mass matrix and <code>[:e for in 1:dimension]</code> as symbols.</p><h3 id="[StaticDelayEdge](@ref)"><a class="docs-heading-anchor" href="#[StaticDelayEdge](@ref)"><a href="../Library/#NetworkDynamics.StaticDelayEdge"><code>StaticDelayEdge</code></a></a><a id="[StaticDelayEdge](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[StaticDelayEdge](@ref)" title="Permalink"></a></h3><p>This constructor is used when edge variables depend on past values of the vertex variables. In this case the <code>edgefunction!</code> has to accept two additional arguments <code>h_v_s</code> and <code>h_v_d</code> that hold the (automatically generated) localised history functions of <code>v_s</code> and <code>v_d</code>. <em>Static</em> means that the edge depends only on the dynamics of the vertices the edge is connected to and not on an internal derivative of the edge variables itself.</p><p>As an example for such system, we show a diffusive coupling with delay:</p><pre><code class="language-julia hljs">edgefunction! = (e, v_s, v_d, h_v_s, h_v_d, p, t) -&gt; e .= 0.1 * (h_v_s(t - p) .- v_d)</code></pre><p>The <code>EdgeFunction</code> object is constructed as</p><pre><code class="language-julia hljs">StaticDelayEdge(edgefunction!, dim, coupling, mass_matrix, sym)</code></pre><p>Like for a StaticEdge, we can also leave out the optional keywords <strong>coupling</strong>, <strong>sym</strong> and <strong>mass_matrix</strong>. Available coupling types are <code>:unspecified, :directed, :undirected, :fiducial</code>.</p><pre><code class="language-julia hljs">StaticDelayEdge(; f=edgefunction!, dim=n)</code></pre><h2 id="Constructor"><a class="docs-heading-anchor" href="#Constructor">Constructor</a><a id="Constructor-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor" title="Permalink"></a></h2><p>The central constructor is the function <a href="../Library/#NetworkDynamics.network_dynamics"><code>network_dynamics</code></a> that takes in two arrays of <code>EdgeFunctions</code> and <code>VertexFunctions</code> describing the local dynamics on the edges and nodes of a graph <code>g</code>, given as a <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a> object. It returns a composite function compatible with the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> calling syntax.</p><pre><code class="language-julia hljs">nd = network_dynamics(vertices!::Array{VertexFunction},
                      edges!::Array{EdgeFunction}, g)
nd(dx, x, p, t)</code></pre><p>If all vertices, respectively edges share the same <code>VertexFunction</code> or <code>EdgeFunction</code>, than <code>network_dynamics</code> can be conveniently called with these functions as arguments.</p><pre><code class="language-julia hljs">nd = network_dynamics(vertexfunction!::VertexFunction,
                      edgefunction!::EdgeFunction, g)
</code></pre><p>The optional keyword argument <code>parallel</code> is <code>false</code> by default and can be set to <code>true</code> if a multi-threaded <code>ODEFunction</code> should be used. This may significantly improve performance on multi-core machines, for more details see section <a href="../Multithreading/#Multi-Threading">Multi-Threading</a>.</p><pre><code class="language-julia hljs">nd = network_dynamics(vertexfunction!::VertexFunction,
                      edgefunction!::EdgeFunction, g; parallel=true)
</code></pre><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Let&#39;s look at an example. First, we define our graph as well as the differential systems connected to its vertices and edges:</p><pre><code class="language-julia hljs">using NetworkDynamics, Graphs

g = erdos_renyi(10, 25) # random graph with 10 vertices and 25 edges

function vertexfunction!(dv, v, edges, p, t)
    dv .= 0
    for e in edges
        dv .+= e
    end
end

function edgefunction!(de, e, v_s, v_d, p, t)
    de .= 1000 .* (v_s .- v_d .- e)
    nothing
end

vertex = ODEVertex(; f=vertexfunction!, dim=1)
vertexarr = [vertex for v in vertices(g)]

edge = ODEEdge(; f=edgefunction!, dim=1, coupling=:undirected)
edgearr = [edge for e in edges(g)]

nd = network_dynamics(vertexarr, edgearr, g)</code></pre><p>Now we have an <code>ODEFunction</code> <code>nd</code> that can be solved with the tools provided by <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>For more details check out the Tutorials section.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« General</a><a class="docs-footer-nextpage" href="../parameters/">Parameter handling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Monday 16 October 2023 13:11">Monday 16 October 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
