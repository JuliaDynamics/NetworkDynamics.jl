<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Indexing · NetworkDynamics</title><meta name="title" content="Symbolic Indexing · NetworkDynamics"/><meta property="og:title" content="Symbolic Indexing · NetworkDynamics"/><meta property="twitter:title" content="Symbolic Indexing · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li><a class="tocitem" href="../mathematical_model/">Mathematical Model</a></li><li><a class="tocitem" href="../network_construction/">Network Construction</a></li><li><a class="tocitem" href="../data_structure/">Data Structure</a></li><li><span class="tocitem">Features</span><ul><li class="is-active"><a class="tocitem" href>Symbolic Indexing</a><ul class="internal"><li><a class="tocitem" href="#Provide-Symbol-Names"><span>Provide Symbol Names</span></a></li><li><a class="tocitem" href="#Fundamental-Symbolic-Indices"><span>Fundamental Symbolic Indices</span></a></li><li><a class="tocitem" href="#Generate-Symbolic-Indices"><span>Generate Symbolic Indices</span></a></li><li><a class="tocitem" href="#NWState-and-NWParameter-Objects"><span><code>NWState</code> and <code>NWParameter</code> Objects</span></a></li><li><a class="tocitem" href="#Interactive-Filtering-with-FilteringProxy"><span>Interactive Filtering with FilteringProxy</span></a></li><li><a class="tocitem" href="#Observables"><span>Observables</span></a></li><li><a class="tocitem" href="#Derived-ObservableExpressions-using-@obsex"><span>Derived <code>ObservableExpressions</code> using <code>@obsex</code></span></a></li><li><a class="tocitem" href="#Low-level-accessors-for-flat-array-indices"><span>Low-level accessors for flat array indices</span></a></li></ul></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../callbacks/">Callbacks and Events</a></li><li><a class="tocitem" href="../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../sparsity_detection/">Sparsity Detection</a></li><li><a class="tocitem" href="../external_inputs/">External Inputs</a></li><li><a class="tocitem" href="../inspector/">Interactive Solution Inspection</a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../generated/heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../generated/init_tutorial/">Initialization</a></li><li><a class="tocitem" href="../generated/cascading_failure/">Cascading Failure</a></li><li><a class="tocitem" href="../generated/gas_network/">Gas Network</a></li><li><a class="tocitem" href="../generated/stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../generated/directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Features</a></li><li class="is-active"><a href>Symbolic Indexing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Indexing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/src/symbolic_indexing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Indexing"><a class="docs-heading-anchor" href="#Symbolic-Indexing">Symbolic Indexing</a><a id="Symbolic-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Indexing" title="Permalink"></a></h1><p>By using SciML&#39;s <a href="https://github.com/SciML/SymbolicIndexingInterface.jl"><code>SymbolicIndexingInterface.jl</code></a>, <code>ND.jl</code>  provides numerous methods to access and change variables and parameters.</p><h2 id="Provide-Symbol-Names"><a class="docs-heading-anchor" href="#Provide-Symbol-Names">Provide Symbol Names</a><a id="Provide-Symbol-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Provide-Symbol-Names" title="Permalink"></a></h2><p>When constructing component models, you can pass symbolic names using the <code>sym</code> and <code>psym</code> keywords.</p><pre><code class="language-julia hljs">using NetworkDynamics, Graphs, OrdinaryDiffEqTsit5, Plots
function _edgef!(e, v_s, v_d, (K,), t)
    e .= K * (v_s[1] .- v_d[1])
end
edgef = EdgeModel(;g=AntiSymmetric(_edgef!), outsym=[:flow], psym=[:K=&gt;1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EdgeModel <span class="sgr1">:StaticEdgeM</span> <span class="sgr94">PureFeedForward()</span>
 ├─   0 states:  []  
 ├─ 1/1 outputs: src=[₋flow] dst=[flow]
 └─   1 param:   [K=1]</code></pre><p>Here we create a static diffusion edge with suitable variable and parameter names. Similarly, we define the diffusion vertex with symbolic names.</p><pre><code class="language-julia hljs">function _vertexf!(dv, v, esum, p, t)
    dv[1] = esum[1]
end
vertexf = VertexModel(f=_vertexf!, g=1, sym=[:storage])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:VertexM</span> <span class="sgr94">PureStateMap()</span>
 ├─ 1 state:  [storage]
 └─ 1 output: [storage]</code></pre><p>When constructing component models using ModelingToolkit, the variable names are extracted automatically. </p><h2 id="Fundamental-Symbolic-Indices"><a class="docs-heading-anchor" href="#Fundamental-Symbolic-Indices">Fundamental Symbolic Indices</a><a id="Fundamental-Symbolic-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Fundamental-Symbolic-Indices" title="Permalink"></a></h2><p>The main types for symbolic indexing are <a href="../API/#NetworkDynamics.VIndex"><code>VIndex</code></a> and <a href="../API/#NetworkDynamics.EIndex"><code>EIndex</code></a> for vertices and edges respectively. Each symbolic index consists of 2 elements: a reference to the network component and a reference to the symbol within that component. Indices may reference states and parameters, but also things like outputs, inputs and observables which do not directly appear in the state/parameter vector.</p><p>For accessing by symbol:</p><ul><li><code>VIndex(2, :x)</code> refers to variable with symbolic name <code>:x</code> in vertex number 2.</li><li><code>EIndex(4, :K)</code> refers to parameter <code>:K</code> of the edge component for the 4th edge.</li></ul><p>For numeric indexing, use <a href="../API/#NetworkDynamics.StateIdx"><code>StateIdx</code></a> and <a href="../API/#NetworkDynamics.ParamIdx"><code>ParamIdx</code></a> wrappers:</p><ul><li><code>VIndex(2, StateIdx(1))</code> refers to the <em>first</em> state of vertex 2.</li><li><code>EIndex(4, ParamIdx(2))</code> refers to the <em>second</em> parameter of edge 4.</li></ul><details class="admonition is-details" id="Setup-code-to-make-following-examples-work-7846ac071c28d9d6"><summary class="admonition-header">Setup code to make following examples work<a class="admonition-anchor" href="#Setup-code-to-make-following-examples-work-7846ac071c28d9d6" title="Permalink"></a></summary><div class="admonition-body"><pre><code class="language-julia hljs">g = wheel_graph(5)
nw = Network(g, vertexf, edgef)
s = NWState(nw)
s.v[:,:storage] .= randn(5)
prob = ODEProblem(nw, uflat(s), (0,2), pflat(s))
sol = solve(prob, Tsit5())</code></pre></div></details><p>Those fundamental indices can be used in a lot of scenarios. Most importantly you can use them to extract points or timeseries from a solution object</p><pre><code class="language-julia hljs">ts = 0:0.1:1
sol(ts; idxs=VIndex(1,:storage)) # value of VIndex(1,:storage) at each t in ts</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">t: 0.0:0.1:1.0
u: 11-element Vector{Float64}:
 -1.4670155261580178
 -1.2142688572525058
 -1.0609707437303897
 -0.9679903888584531
 -0.9115949816152927
 -0.8773870116778747
 -0.8566472642136346
 -0.8440569331863896
 -0.8364310016932017
 -0.8317946181581243
 -0.8289963736167151</code></pre><p>Alternatively, you can use them directly in specialized plotting recipes:</p><pre><code class="language-julia hljs">plot(sol; idxs=[VIndex(1, :storage), VIndex(5,:storage)]) # plot storage of vertex 1 and vertex 5</code></pre><img src="96b23c55.svg" alt="Example block output"/><p>It is often advised to choose your timesteps for plotting directly, i.e.</p><pre><code class="language-julia hljs">ts = range(0, 1; length=1000)
plot(ts, sol(ts; idxs=VIndex(1,:storage)).u)</code></pre><p>gives you more control over how many points are used within the range <span>$(0,1)$</span>.</p><h2 id="Generate-Symbolic-Indices"><a class="docs-heading-anchor" href="#Generate-Symbolic-Indices">Generate Symbolic Indices</a><a id="Generate-Symbolic-Indices-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-Symbolic-Indices" title="Permalink"></a></h2><p>Often, you need many individual symbolic indices. NetworkDynamics provides several approaches:</p><h3 id="Quick-Access-with-Helper-Functions"><a class="docs-heading-anchor" href="#Quick-Access-with-Helper-Functions">Quick Access with Helper Functions</a><a id="Quick-Access-with-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Access-with-Helper-Functions" title="Permalink"></a></h3><p>The helper methods <a href="../API/#NetworkDynamics.vidxs"><code>vidxs</code></a>, <a href="../API/#NetworkDynamics.eidxs"><code>eidxs</code></a>, <a href="../API/#NetworkDynamics.vpidxs"><code>vpidxs</code></a> and <a href="../API/#NetworkDynamics.epidxs"><code>epidxs</code></a> provide shortcuts for common patterns</p><pre><code class="language-julia hljs">vidxs(nw, :, :storage) # get state variable &quot;storage&quot; for all vertices</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{NetworkDynamics.SymbolicIndex}:
 VIndex(1, :storage)
 VIndex(2, :storage)
 VIndex(3, :storage)
 VIndex(4, :storage)
 VIndex(5, :storage)</code></pre><pre><code class="language-julia hljs">plot(sol; idxs=vidxs(nw, :, :storage))</code></pre><img src="c3e66592.svg" alt="Example block output"/><h3 id="Advanced-Generation-with-generate_indices"><a class="docs-heading-anchor" href="#Advanced-Generation-with-generate_indices">Advanced Generation with <code>generate_indices</code></a><a id="Advanced-Generation-with-generate_indices-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Generation-with-generate_indices" title="Permalink"></a></h3><p>For more complex filtering, use <a href="../API/#NetworkDynamics.generate_indices"><code>generate_indices</code></a>, which provides the underlying functionality:</p><pre><code class="language-julia hljs"># All edge parameters containing &quot;K&quot; in their name
generate_indices(nw, EIndex(:), &quot;K&quot;; s=false, p=true, out=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{NetworkDynamics.SymbolicIndex}:
 EIndex(1, :K)
 EIndex(2, :K)
 EIndex(3, :K)
 EIndex(4, :K)
 EIndex(5, :K)
 EIndex(6, :K)
 EIndex(7, :K)
 EIndex(8, :K)</code></pre><p>The helper functions are actually just shortcuts to <code>generate_indices</code> calls:</p><pre><code class="nohighlight hljs">vidxs(nw, cf, vf) = generate_indices(nw, VIndex(cf), vf; s=true, p=false, out=true, obs=true)</code></pre><h2 id="NWState-and-NWParameter-Objects"><a class="docs-heading-anchor" href="#NWState-and-NWParameter-Objects"><code>NWState</code> and <code>NWParameter</code> Objects</a><a id="NWState-and-NWParameter-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#NWState-and-NWParameter-Objects" title="Permalink"></a></h2><p>Internally, both state and parameters of a <code>Network</code> are represented using flat arrays. To access the state or parameters of a network, you can use the <a href="../API/#NetworkDynamics.NWState"><code>NWState</code></a> and <a href="../API/#NetworkDynamics.NWParameter"><code>NWParameter</code></a> objects.</p><pre><code class="language-julia hljs">p = NWParameter(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Parameter{Vector{Float64}} of Network (5 vertices, 8 edges)
  ├─ EIndex(1, :K) =&gt; 1.0
  ├─ EIndex(2, :K) =&gt; 1.0
  ├─ EIndex(3, :K) =&gt; 1.0
  ├─ EIndex(4, :K) =&gt; 1.0
  ├─ EIndex(5, :K) =&gt; 1.0
  ├─ EIndex(6, :K) =&gt; 1.0
  ├─ EIndex(7, :K) =&gt; 1.0
  └─ EIndex(8, :K) =&gt; 1.0</code></pre><p>creates a <code>NWParameter</code> object for the network <code>nw</code>. It essentially creates a new flat parameter array and fills it with the default parameter values defined in the component. The parameters in the <code>NWParameter</code> object can be accessed using symbolic indices.</p><pre><code class="language-julia hljs">p[EIndex(5, :K)] = 2.0 # change the parameter K of the 5th edge</code></pre><p>Similarly, you can create a <code>NWState</code> object for the network <code>nw</code> using</p><pre><code class="language-julia hljs">s = NWState(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (5 vertices, 8 edges)
  ├─ VIndex(1, :storage) =&gt; NaN
  ├─ VIndex(2, :storage) =&gt; NaN
  ├─ VIndex(3, :storage) =&gt; NaN
  ├─ VIndex(4, :storage) =&gt; NaN
  └─ VIndex(5, :storage) =&gt; NaN<span class="sgr90">
 p = NWParameter([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
 t = nothing</span></code></pre><p>No default values were provided in the network components, so the state array is filled with <code>NaN</code> values.</p><p>We can set those values like this:</p><pre><code class="language-julia hljs">s[VIndex(:, :storage)] .= randn(5) # set the (initial) storage for all vertices</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (5 vertices, 8 edges)
  ├─ VIndex(1, :storage) =&gt; 1.065925193737959
  ├─ VIndex(2, :storage) =&gt; 1.0557820783858887
  ├─ VIndex(3, :storage) =&gt; 0.641441737008656
  ├─ VIndex(4, :storage) =&gt; 0.05355473856151899
  └─ VIndex(5, :storage) =&gt; 1.4519772689582484<span class="sgr90">
 p = NWParameter([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
 t = nothing</span></code></pre><p>For both <code>NWState</code> and <code>NWParameter</code> objects, there is a more convenient way to access the variables and parameters using the <a href="../API/#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> interface. The filtering proxy can be accessed by calling <code>.v</code> or <code>.e</code> on a state:</p><pre><code class="language-julia hljs">s.v</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FilteringProxy</span> for NWState()
  Component filter: AllVertices()<span class="sgr90"> &lt;- filter further by obj[1], obj[&quot;name&quot;], ...</span>
  State filter:     <span class="sgr90">none</span>
  Types:<span class="sgr92"><span class="sgr1">  states ✓</span></span><span class="sgr1"><span class="sgr93">  parameters ✓</span><span class="sgr95">  inputs ✓</span><span class="sgr94">  outputs ✓</span><span class="sgr96">  observables ✓</span></span>
<span class="sgr1">Matching Indices:</span>
  ● VIndex(1, <span class="sgr92">:storage</span>)   1.0659252    :VertexM
  ● VIndex(2, <span class="sgr92">:storage</span>)   1.0557821    :VertexM
  ● VIndex(3, <span class="sgr92">:storage</span>)   0.64144174   :VertexM
  ● VIndex(4, <span class="sgr92">:storage</span>)   0.053554739  :VertexM
  ● VIndex(5, <span class="sgr92">:storage</span>)   1.4519773    :VertexM</code></pre><p>You can then subsequently filter the list by &quot;indexing&quot; into the <code>FilteringProxy</code> object:</p><pre><code class="language-julia hljs">s.v[1:2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FilteringProxy</span> for NWState()
  Component filter: VIndex([1, 2])
  State filter:     <span class="sgr90">none &lt;- filter states by obj[&quot;δ&quot;], obj[:x], ...</span>
  Types:<span class="sgr92"><span class="sgr1">  states ✓</span></span><span class="sgr1"><span class="sgr93">  parameters ✓</span><span class="sgr95">  inputs ✓</span><span class="sgr94">  outputs ✓</span><span class="sgr96">  observables ✓</span></span>
<span class="sgr1">Matching Indices:</span>
  ● VIndex(1, <span class="sgr92">:storage</span>)   1.0659252  :VertexM
  ● VIndex(2, <span class="sgr92">:storage</span>)   1.0557821  :VertexM</code></pre><p>... until you&#39;ve filtered on both components and variables and the indexing returns the actual values:</p><pre><code class="language-julia hljs">s.v[1:2][:storage]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 1.065925193737959
 1.0557820783858887</code></pre><p>Check out the docstring of <a href="../API/#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> for an in-depth explanation.</p><p>The <code>NWState</code> and <code>NWParameter</code> objects are mutable, thus changing them will also change the underlying wrapped flat arrays.</p><p>For example, we can use the syntax introduced above to update the values within the state</p><pre><code class="language-julia hljs">s.v[1:2][:storage] = [1,2]</code></pre><p>We can confirm the update by inspecting the values again:</p><pre><code class="language-julia hljs">s.v</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">FilteringProxy</span> for NWState()
  Component filter: AllVertices()<span class="sgr90"> &lt;- filter further by obj[1], obj[&quot;name&quot;], ...</span>
  State filter:     <span class="sgr90">none</span>
  Types:<span class="sgr92"><span class="sgr1">  states ✓</span></span><span class="sgr1"><span class="sgr93">  parameters ✓</span><span class="sgr95">  inputs ✓</span><span class="sgr94">  outputs ✓</span><span class="sgr96">  observables ✓</span></span>
<span class="sgr1">Matching Indices:</span>
  ● VIndex(1, <span class="sgr92">:storage</span>)   1            :VertexM
  ● VIndex(2, <span class="sgr92">:storage</span>)   2            :VertexM
  ● VIndex(3, <span class="sgr92">:storage</span>)   0.64144174   :VertexM
  ● VIndex(4, <span class="sgr92">:storage</span>)   0.053554739  :VertexM
  ● VIndex(5, <span class="sgr92">:storage</span>)   1.4519773    :VertexM</code></pre><p>You can always access the flat representations by calling <a href="../API/#NetworkDynamics.uflat"><code>uflat</code></a> and <a href="../API/#NetworkDynamics.pflat"><code>pflat</code></a>. The ordering of elements  in these flat arrays corresponds exactly to the order returned by <a href="../API/#SymbolicIndexingInterface.variable_symbols"><code>variable_symbols</code></a> and  <a href="../API/#SymbolicIndexingInterface.parameter_symbols"><code>parameter_symbols</code></a> respectively.</p><div class="admonition is-info" id="Note-388aa5aa2a3a0fc2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-388aa5aa2a3a0fc2" title="Permalink"></a></header><div class="admonition-body"><p>The <code>NWState</code> and <code>NWParameter</code> wrappers can be constructed from various objects. For example, within a callback you might construct <code>p = NWParameter(integrator)</code> to then change the parameters of the network within the callback.</p></div></div><h2 id="Interactive-Filtering-with-FilteringProxy"><a class="docs-heading-anchor" href="#Interactive-Filtering-with-FilteringProxy">Interactive Filtering with FilteringProxy</a><a id="Interactive-Filtering-with-FilteringProxy-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-Filtering-with-FilteringProxy" title="Permalink"></a></h2><p>The <a href="../API/#NetworkDynamics.FilteringProxy"><code>FilteringProxy</code></a> system provides an intuitive way to explore and access network variables through progressive filtering. When you access <code>.v</code>, <code>.e</code>, or <code>.p</code> properties of <code>NWState</code>/<code>NWParameter</code> objects, you get a filtering proxy that can be refined step by step.</p><h2 id="Observables"><a class="docs-heading-anchor" href="#Observables">Observables</a><a id="Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Observables" title="Permalink"></a></h2><p>Sometimes, the &quot;states&quot; you&#39;re interested in aren&#39;t really states in the DAE sense but rather algebraic derivations from DAE states, parameters, and time – in accordance with the naming in  the <code>SciML</code> ecosystem, these values are called Observables.</p><p>A prime example of Observables are edge/vertex-outputs, such as the <code>flow</code> in the edge model defined above. It is also possible to define additional Observables manually by using the <code>obssym</code> and <code>obsf</code> keyword on the <code>EdgeModel</code>/<code>VertexModel</code> constructors. When building models using ModelingToolkit, the reduced algebraic states will be preserved automatically as observables.</p><p>Observables can be accessed like any other state. For example, the flows in the network don&#39;t show up in the state array  but can be accessed in all the ways discussed above.  For example:</p><pre><code class="language-julia hljs">plot(sol; idxs=eidxs(nw, :, :flow))</code></pre><img src="a468301a.svg" alt="Example block output"/><h2 id="Derived-ObservableExpressions-using-@obsex"><a class="docs-heading-anchor" href="#Derived-ObservableExpressions-using-@obsex">Derived <code>ObservableExpressions</code> using <code>@obsex</code></a><a id="Derived-ObservableExpressions-using-@obsex-1"></a><a class="docs-heading-anchor-permalink" href="#Derived-ObservableExpressions-using-@obsex" title="Permalink"></a></h2><p>Sometimes it is useful to plot or observe simple derived quantities. For that, one can use the <a href="../API/#NetworkDynamics.@obsex"><code>@obsex</code></a> macro to define simple derived quantities.</p><p>For example, we can directly plot the storage difference with respect to storage of node 1.</p><pre><code class="language-julia hljs">plot(sol; idxs=@obsex(vidxs(nw,:,:storage) .- VIndex(1,:storage)))</code></pre><img src="7c8885e0.svg" alt="Example block output"/><p>Other examples include calculating the magnitude and argument of complex values that are modeled using real and  imaginary parts.</p><pre><code class="nohighlight hljs">@obsex mag = sqrt(VIndex(1, :u_r)^2 + VIndex(2, :u_i)^2)</code></pre><h2 id="Low-level-accessors-for-flat-array-indices"><a class="docs-heading-anchor" href="#Low-level-accessors-for-flat-array-indices">Low-level accessors for flat array indices</a><a id="Low-level-accessors-for-flat-array-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-accessors-for-flat-array-indices" title="Permalink"></a></h2><p>Sometimes, you want to know the indices of your states in the flat arrays. For that, you can use the low-level methods defined in <code>SymbolicIndexingInterface.jl</code>:</p><pre><code class="language-julia hljs">using NetworkDynamics: SII # SII = SymbolicIndexingInterface
idxs = SII.variable_index(nw, vidxs(nw, 1:2, :storage))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 1
 2</code></pre><pre><code class="language-julia hljs">uflat(s)[idxs] == s.v[1:2, :storage]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Analogous with parameters:</p><pre><code class="language-julia hljs">idxs = SII.parameter_index(nw, [EIndex(1, :K), EIndex(2, :K)])
pflat(s)[idxs] == s.p.e[1:2, :K]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>If you need the symbols of all the states/parameters in order, you can use:</p><pre><code class="language-julia hljs">SII.variable_symbols(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{NetworkDynamics.SymbolicIndex{Int64, Symbol}}:
 VIndex(1, :storage)
 VIndex(2, :storage)
 VIndex(3, :storage)
 VIndex(4, :storage)
 VIndex(5, :storage)</code></pre><p>and</p><pre><code class="language-julia hljs">SII.parameter_symbols(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{NetworkDynamics.SymbolicIndex{Int64, Symbol}}:
 EIndex(1, :K)
 EIndex(2, :K)
 EIndex(3, :K)
 EIndex(4, :K)
 EIndex(5, :K)
 EIndex(6, :K)
 EIndex(7, :K)
 EIndex(8, :K)</code></pre><p>These functions return the symbolic indices in the exact order they appear in the flat arrays returned by <a href="../API/#NetworkDynamics.uflat"><code>uflat</code></a> and <a href="../API/#NetworkDynamics.pflat"><code>pflat</code></a>, making them essential when you need to map between flat array indices and symbolic representations.</p><p>All above examples also work on other &quot;symbolic containers&quot;, e.g. <code>SII.variable_symbols(::NWState)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structure/">« Data Structure</a><a class="docs-footer-nextpage" href="../metadata/">Metadata »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 23 October 2025 09:15">Thursday 23 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
