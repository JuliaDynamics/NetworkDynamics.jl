<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gas Network · NetworkDynamics</title><meta name="title" content="Gas Network · NetworkDynamics"/><meta property="og:title" content="Gas Network · NetworkDynamics"/><meta property="twitter:title" content="Gas Network · NetworkDynamics"/><meta name="description" content="Documentation for NetworkDynamics."/><meta property="og:description" content="Documentation for NetworkDynamics."/><meta property="twitter:description" content="Documentation for NetworkDynamics."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NetworkDynamics</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">General</a></li><li><a class="tocitem" href="../../mathematical_model/">Mathematical Model</a></li><li><a class="tocitem" href="../../network_construction/">Network Construction</a></li><li><a class="tocitem" href="../../data_structure/">Data Structure</a></li><li><span class="tocitem">Features</span><ul><li><a class="tocitem" href="../../symbolic_indexing/">Symbolic Indexing</a></li><li><a class="tocitem" href="../../metadata/">Metadata</a></li><li><a class="tocitem" href="../../initialization/">Initialization</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks and Events</a></li><li><a class="tocitem" href="../../mtk_integration/">ModelingToolkit Integration</a></li><li><a class="tocitem" href="../../sparsity_detection/">Sparsity Detection</a></li><li><a class="tocitem" href="../../external_inputs/">External Inputs</a></li><li><a class="tocitem" href="../../inspector/">Interactive Solution Inspection</a></li></ul></li><li><a class="tocitem" href="../../API/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_network_dynamics/">Getting Started</a></li><li><a class="tocitem" href="../heterogeneous_system/">Heterogeneous Systems</a></li><li><a class="tocitem" href="../init_tutorial/">Initialization</a></li><li><a class="tocitem" href="../cascading_failure/">Cascading Failure</a></li><li class="is-active"><a class="tocitem" href>Gas Network</a><ul class="internal"><li><a class="tocitem" href="#Node-Models"><span>Node Models</span></a></li><li><a class="tocitem" href="#Pipe-Model"><span>Pipe Model</span></a></li><li><a class="tocitem" href="#Parametrization"><span>Parametrization</span></a></li><li><a class="tocitem" href="#Load-Profile"><span>Load Profile</span></a></li><li><a class="tocitem" href="#Building-the-Network"><span>Building the Network</span></a></li><li><a class="tocitem" href="#Finding-a-Steady-State"><span>Finding a Steady State</span></a></li><li><a class="tocitem" href="#Solving-the-ODE"><span>Solving the ODE</span></a></li><li><a class="tocitem" href="#Inspect-the-Solution"><span>Inspect the Solution</span></a></li></ul></li><li><a class="tocitem" href="../stress_on_truss/">Stress on Truss</a></li><li><a class="tocitem" href="../directed_and_weighted_graphs/">Directed and Weighted Graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Gas Network</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gas Network</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/NetworkDynamics.jl/blob/main/docs/examples/gas_network.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="gas-example"><a class="docs-heading-anchor" href="#gas-example">Dynamic Flow in Simple Gas Network</a><a id="gas-example-1"></a><a class="docs-heading-anchor-permalink" href="#gas-example" title="Permalink"></a></h1><p>This example is based on the paper</p><blockquote><p>Albertus J. Malan, Lukas Rausche, Felix Strehle, Sören Hohmann, Port-Hamiltonian Modelling for Analysis and Control of Gas Networks, IFAC-PapersOnLine, Volume 56, Issue 2, 2023, https://doi.org/10.1016/j.ifacol.2023.10.193.</p></blockquote><p>and tries to replicate a simple simulation of flow in a 3-node gas network.</p><p>This example can be dowloaded as a normal Julia script <a href="../gas_network.jl">here</a>.</p><p>We start by importing the necessary packages:</p><pre><code class="language-julia hljs">using NetworkDynamics
using ModelingToolkit
using DynamicQuantities
using ModelingToolkit: D as Dt, t as t
using Test
using StaticArrays
using DataInterpolations
using OrdinaryDiffEqTsit5
using CairoMakie</code></pre><h2 id="Node-Models"><a class="docs-heading-anchor" href="#Node-Models">Node Models</a><a id="Node-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Node-Models" title="Permalink"></a></h2><p>In this example, we use equation-based modeling using <code>ModelingToolkit.jl</code>. To verify the equations on a basic level, we also provide units to everything to perform dimensionality checks.</p><p>There are 2 node models used in the paper. The first node type has a constant pressure. Additionally, we add some &quot;internal&quot; state <code>q̃_inj</code> which we want to plot later (see also <a href="../../symbolic_indexing/#Observables">Observables</a>).</p><pre><code class="language-julia hljs">@mtkmodel ConstantPressureNode begin
    @parameters begin
        p_set, [description=&quot;Constant pressure setpoint&quot;, unit=u&quot;Pa&quot;]
    end
    @variables begin
        p(t) = p_set, [description=&quot;Pressure&quot;, unit=u&quot;Pa&quot;, output=true]
        q̃_nw(t), [description=&quot;aggregated flow from pipes into node&quot;, unit=u&quot;m^3/s&quot;, input=true]
        q̃_inj(t), [description=&quot;internal state for introspection&quot;, unit=u&quot;m^3/s&quot;]
    end
    @equations begin
        p ~ p_set
        q̃_inj ~ -q̃_nw
    end
end</code></pre><p>The second node model is a variable pressure node. It has one output state (the pressure) and one input state, the aggregated flows from the connected pipes. As an internal state we have the injected flow from our source/load. The source/load behavior itself is provided via a time-dependent function.</p><pre><code class="language-julia hljs">@mtkmodel VariablePressureNode begin
    @structural_parameters begin
        load_profile # time dependent load profile
    end
    @constants begin
        load_unit = 1, [description=&quot;unit of the load profile&quot;, unit=u&quot;m^3/s&quot;]
    end
    @parameters begin
        C, [description=&quot;Lumped capacitance of connected pipes&quot;, unit=u&quot;m^4 * s^2 / kg&quot;]
    end
    @variables begin
        p(t)=5e6, [description=&quot;Pressure&quot;, unit=u&quot;Pa&quot;, output=true]
        q̃_inj(t), [description=&quot;external injection into node&quot;, unit=u&quot;m^3/s&quot;]
        q̃_nw(t), [description=&quot;aggregated flow from pipes into node&quot;, unit=u&quot;m^3/s&quot;, input=true]
    end
    @equations begin
        q̃_inj ~ load_profile(t) * load_unit
        C * Dt(p) ~ q̃_inj + q̃_nw # (30)
    end
end</code></pre><h2 id="Pipe-Model"><a class="docs-heading-anchor" href="#Pipe-Model">Pipe Model</a><a id="Pipe-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Pipe-Model" title="Permalink"></a></h2><p>The pipe is modeled as a first-order ODE for the volumetric flow at the <code>dst</code> end. It has two inputs: the pressure at the source and the pressure at the destination end. Later on, we&#39;ll specify the model to be antisymmetric, thus the flow is calculated explicitly for the destination end, but the source end will just receive that times (-1).</p><pre><code class="language-julia hljs">@mtkmodel Pipe begin
    @parameters begin
        L, [description=&quot;Length of pipe&quot;, unit=u&quot;m&quot;]
        D, [description=&quot;Diameter of pipe&quot;, unit=u&quot;m&quot;]
        A, [description=&quot;Cross-sectional area of pipe&quot;, unit=u&quot;m^2&quot;]
        sinθ, [description=&quot;Angle of inclination&quot; ]
        γ, [description=&quot;Friction efficiency factor&quot;]
        η, [description=&quot;Dynamic viscosity&quot;, unit=u&quot;kg/(m*s)&quot;]
        r, [description=&quot;Pipe roughness&quot;, unit=u&quot;m&quot;]
        g, [description=&quot;Gravitational acceleration&quot;, unit=u&quot;m/s^2&quot;]
        T, [description=&quot;simulation temperature&quot;, unit=u&quot;K&quot;]
        Tc, [description=&quot;crictical temperature&quot;, unit=u&quot;K&quot;]
        pc, [description=&quot;critical pressure&quot;, unit=us&quot;Pa&quot;]
        Rs, [description=&quot;Specific gas constant for natural gas&quot;, unit=us&quot;J/(kg*K)&quot;]
        c̃, [description=&quot;Speed of sound in fluid at standard conditions&quot;, unit=u&quot;m/s&quot;]
        ρ̃, [description=&quot;standard density&quot;, unit=u&quot;kg/m^3&quot;]
        p̃, [description=&quot;standard pressure&quot;, unit=us&quot;Pa&quot;]
    end
    @variables begin
        p_src(t), [description=&quot;Pressure at source end&quot;, unit=us&quot;Pa&quot;, input=true]
        p_dst(t), [description=&quot;Pressure at destination end&quot;, unit=us&quot;Pa&quot;, input=true]
        q̃(t)=1, [description=&quot;Flow through pipe&quot;, unit=u&quot;m^3/s&quot;, output=true]
        Re(t), [description=&quot;Reynolds number&quot;]
        λ(t), [description=&quot;Friction factor&quot;]
        λe(t), [description=&quot;Effective friction factor&quot;]
        pM(t), [description=&quot;mean pressure&quot;, unit=us&quot;Pa&quot;]
        Z(t), [description=&quot;compressibility factor&quot;]
        ρ(t), [description=&quot;density&quot;, unit=u&quot;kg/m^3&quot;]
        c(t), [description=&quot;speed of sound&quot;, unit=u&quot;m/s&quot;]
    end
    @equations begin
        Z ~ 1 - 3.52 * pM/pc * exp(-2.26*(T/Tc)) + 0.274 * (pM/pc)^2 * exp(-1.878*(T/Tc)) # (5)
        ρ ~ pM / (Rs * T * Z) # (4)

        # TODO: Whats the correct speed of sound?
        c ~ sqrt(T * Rs * Z) # (4) # pressure/temp dependent
        # c ~ c̃                   # &quot;standard&quot; speed of sound based on standard conditions

        # TODO: Whats the correct Reynolds number?
        Re ~ (ρ * abs(q̃*p̃/pM) * D) / (η * A) # (6) # based &quot;actual&quot; conditions
        # Re ~ (ρ̃ * abs(q̃) * D) / (η * A) # (6)   # based on standard conditions

        λ ~ ifelse(Re &lt; 2300,
            64/Re, # laminar (7)
            (2*log10(4.518/Re * log10(Re/7) + r/(3.71*D)))^(-2) # turbulent (8)
        )
        λe ~ λ/γ^2 # (10)
        pM ~ 2/3*(p_src + p_dst - (p_src*p_dst)/(p_src + p_dst)) # (20)

        Dt(q̃) ~ A/(L*ρ̃)*(-(λe * ρ̃^2 * c^2 * L * abs(q̃))/(2 * D * A^2 * pM) * q̃ - (g * L * sinθ)/(c^2) * pM + (p_src - p_dst)) # (31)
    end
end</code></pre><h2 id="Parametrization"><a class="docs-heading-anchor" href="#Parametrization">Parametrization</a><a id="Parametrization-1"></a><a class="docs-heading-anchor-permalink" href="#Parametrization" title="Permalink"></a></h2><p>The parameterization turned out to be a bit tricky. There might be errors in there.</p><p>Some of them are quite cleare and explicitly given.</p><pre><code class="language-julia hljs">g = 9.81u&quot;m/s^2&quot;       # that we just know
Rs = 518.28u&quot;J/(kg*K)&quot; # Specific gas constant for natural gas
η  = 1e-5u&quot;kg/(m*s)&quot;   # Dynamic viscosity
pc = 46.5u&quot;bar&quot;        # Critical pressure
p̃  = 1.01325u&quot;bar&quot;     # standard pressure
Tc = 190.55u&quot;K&quot;        # critical temperature
T̃  = 273.15u&quot;K&quot;        # standard temperature
T  = 278u&quot;K&quot;           # simulation temperature
γ  = 0.98              # friction efficiency factor
r  = 0.012u&quot;mm&quot;        # pipe roughness
D  = 0.6u&quot;m&quot;           # pipe diameter

L₁₂ = 90u&quot;km&quot;
L₁₃ = 80u&quot;km&quot;
L₂₃ = 100u&quot;km&quot;
Δh₁ = 0u&quot;km&quot;           # this value is different for different sims in the paper
p₁_set = 50u&quot;bar&quot;</code></pre><p>The geometric parameters for the pipes can be directly derived.</p><pre><code class="language-julia hljs">A = π/4 * D^2
sinθ₁₂ = ustrip(Δh₁ / L₁₂)
sinθ₁₃ = ustrip(Δh₁ / L₁₃)
sinθ₂₃ = 0.0</code></pre><p>Lastly, we need to calculate the compressibility factor, the speed of sound, and the density at standard conditions:</p><pre><code class="language-julia hljs">Z̃ = 1 - 3.52 * p̃/pc * exp(-2.26*(T̃/Tc)) + 0.274 * (p̃/pc)^2 * exp(-1.878*(T̃/Tc)) # (5)
c̃ = sqrt(T̃ * Rs * Z̃) # (4) at standard conditions
ρ̃ = p̃ / (Rs * T̃ * Z̃) # (4) at standard conditions</code></pre><p>The equivalent &quot;pressure capacity&quot; at the nodes is calculated as a sum of the connected pipe parameters according to (28).</p><p>Here we use definitions based on the speed and &quot;standard&quot; conditions.</p><pre><code class="language-julia hljs">C₂ = L₁₂*A/(2*ρ̃*c̃^2) + L₂₃*A/(2*ρ̃*c̃^2) # (28)
C₃ = L₁₃*A/(2*ρ̃*c̃^2) + L₂₃*A/(2*ρ̃*c̃^2) # (28)</code></pre><p>Alternatively, we could calculate <code>Z2</code> and <code>Z3</code> based on the actual pressure and simulation temperature. Then we could calculate the speed of sound for the &quot;correct&quot; conditions at the node. It seems to have very little effect on the actual results, so I kept it simple.</p><h2 id="Load-Profile"><a class="docs-heading-anchor" href="#Load-Profile">Load Profile</a><a id="Load-Profile-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Profile" title="Permalink"></a></h2><p>The paper specifies the load profile at two nodes. We use the package <a href="https://github.com/SciML/DataInterpolations.jl"><code>DataInterpolations.jl</code></a> to get a callable object which represents this piecewise linear interpolation.</p><p>Currently, the linear interpolation does not support any units yet. To satisfy the static unit check, we multipy the interpolation output by a constant 1 of that unit.</p><p>Note however, that the unit check is only performed at the construction of the model. Later on, when the nummeric code will be generated from the symbolic representation, all units will be stripped.</p><div class="admonition is-info" id="Discontinuities-in-RHS-d02725d6e9ccbb85"><header class="admonition-header">Discontinuities in RHS<a class="admonition-anchor" href="#Discontinuities-in-RHS-d02725d6e9ccbb85" title="Permalink"></a></header><div class="admonition-body"><p>The piecewise linear interpolated function creates discontinuities in the RHS of the system. However, since we know the times exactly, we can handle this by simply giving a list of explicit tstops to the solve command, to make sure those are hit exactly.</p></div></div><pre><code class="language-julia hljs">load2 = LinearInterpolation(-1*Float64[20, 30, 10, 30, 20], [0, 4, 12, 20, 24]*3600.0; extrapolation=ExtrapolationType.Constant)
load3 = LinearInterpolation(-1*Float64[40, 50, 30, 50, 40], [0, 4, 12, 20, 24]*3600.0; extrapolation=ExtrapolationType.Constant)
ModelingToolkit.get_unit(::LinearInterpolation, _ ) = 1.0 # type piracy!</code></pre><p>As a workaround we had to explicitly define <code>LinearInterpolations</code> as unitless, which is type piracy! Don&#39;t to this in any package code!</p><h2 id="Building-the-Network"><a class="docs-heading-anchor" href="#Building-the-Network">Building the Network</a><a id="Building-the-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-Network" title="Permalink"></a></h2><p>To build the network, we first need to define the components. This is a two-step process:</p><ul><li>first create the symbolic <code>ODESystem</code> using ModelingToolkit</li><li>secondly build a NetworkDynamics component model (<a href="../../API/#NetworkDynamics.VertexModel-Tuple{}"><code>VertexModel</code></a>/<a href="../../API/#NetworkDynamics.EdgeModel-Tuple{}"><code>EdgeModel</code></a>) based on the symbolic system.</li></ul><p>In the first step we can use the keyword arguments to pass &quot;default&quot; values for our parameters and states. Those values will be automatically transferred to the metadata of the component model in the second step.</p><p>The second step requires to define the interface variables, i.e. what are the &quot;input&quot; states of your component model and what are the &quot;output&quot; states. For <code>VertexModel</code> the input state is the aggregated flow of all connected pipes. The output state is the pressure of the node.</p><pre><code class="language-julia hljs">@named v1_mtk = ConstantPressureNode(p_set=p₁_set)
v1 = VertexModel(v1_mtk, [:q̃_nw], [:p]; name=:v1, vidx=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:v1</span> <span class="sgr94">NoFeedForward()</span> @ Vertex 1
 ├─ 1 input:  [q̃_nw]
 ├─ 0 states: []
 ├─ 1 output: [p=5e6]
 └─ 1 param:  [p_set=5e6]</code></pre><pre><code class="language-julia hljs">@named v2_mtk = VariablePressureNode(C=C₂, load_profile=load2)
v2 = VertexModel(v2_mtk, [:q̃_nw], [:p]; name=:v2, vidx=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:v2</span> <span class="sgr94">PureStateMap()</span> @ Vertex 2
 ├─ 1 input:  [q̃_nw]
 ├─ 1 state:  [p=5e6]
 ├─ 1 output: [p=5e6]
 └─ 1 param:  [C=0.26509]</code></pre><pre><code class="language-julia hljs">@named v3_mtk = VariablePressureNode(C=C₃, load_profile=load3)
v3 = VertexModel(v3_mtk, [:q̃_nw], [:p]; name=:v3, vidx=3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VertexModel <span class="sgr1">:v3</span> <span class="sgr94">PureStateMap()</span> @ Vertex 3
 ├─ 1 input:  [q̃_nw]
 ├─ 1 state:  [p=5e6]
 ├─ 1 output: [p=5e6]
 └─ 1 param:  [C=0.25114]</code></pre><p>For the edge model we have two inputs: the pressure on both source and destination end. There is a single output state: the volumetric flow. However, we also need to tell NetworkDynamics about the coupling type. In this case we use <code>AntiSymmetric</code>, which means that the source end will receive the same flow, just with inverted sign.</p><pre><code class="language-julia hljs">@named e12_mtk = Pipe(; L=L₁₂, sinθ=sinθ₁₂, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)
@named e13_mtk = Pipe(; L=L₁₃, sinθ=sinθ₁₃, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)
@named e23_mtk = Pipe(; L=L₂₃, sinθ=sinθ₂₃, D, A, γ, η, r, g, T, Tc, pc, Rs, c̃, ρ̃, p̃)

e12 = EdgeModel(e12_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e12, src=1, dst=2)
e13 = EdgeModel(e13_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e13, src=1, dst=3)
e23 = EdgeModel(e23_mtk, [:p_src], [:p_dst], AntiSymmetric([:q̃]); name=:e23, src=2, dst=3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EdgeModel <span class="sgr1">:e23</span> <span class="sgr94">PureStateMap()</span> @ Edge 2=&gt;3
 ├─ 1/1 inputs:  src=[p_src] dst=[p_dst]
 ├─   1 state:   [q̃=1]
 ├─ 1/1 outputs: src=[₋q̃] dst=[q̃=1]
 └─  15 params:  [ρ̃=0.71788, T=278, Rs=518.28, L=1e5, γ=0.98, D=0.6, p̃=1.0132e5, pc=4.65e6, η=1e-5, sinθ=0, Tc=190.55, A=0.28274, r=1.2e-5, c̃=375.69, g=9.81]</code></pre><p>To build the network object we just need to pass the vertices and edges to the constructor.</p><p>Note that we&#39;ve used the <code>vidx</code> and <code>src</code>/<code>dst</code> keywords in the constructors to define for each component to which &quot;part&quot; of the network it belongs.</p><p>This means the constructor can automatically construct a graph based on that information and we don&#39;t need to pass it explicitly.</p><pre><code class="language-julia hljs">nw = Network([v1, v2, v3], [e12, e13, e23])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Network with 5 states and 48 parameters
 ├─ 3 vertices (3 unique types)
 └─ 3 edges (1 unique type)
Edge-Aggregation using SequentialAggregator(+)</code></pre><p>As a result, we recive a network with 3 unique types (v2 and v3 are similar but structurally different, because both functions capure a unique loadprofile function).</p><h2 id="Finding-a-Steady-State"><a class="docs-heading-anchor" href="#Finding-a-Steady-State">Finding a Steady State</a><a id="Finding-a-Steady-State-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-a-Steady-State" title="Permalink"></a></h2><p>To simulate the system, we first need to find a steady state. As a &quot;guess&quot; for that, we create a <code>NWState</code> object from the network. This will allocate flat arrays for states <code>u</code> and parameters <code>p</code> and fill them with the default values.</p><pre><code class="language-julia hljs">uguess = NWState(nw)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (3 vertices, 3 edges)
  ├─ VIndex(2, :p)  =&gt; 5.0e6
  ├─ VIndex(3, :p)  =&gt; 5.0e6
  ├─ EIndex(1, :q̃)  =&gt; 1.0
  ├─ EIndex(2, :q̃)  =&gt; 1.0
  └─ EIndex(3, :q̃)  =&gt; 1.0
 p = NWParameter([5.0e6, 0.265094, 0.251141, 0.717884, 278.0, 518.28, 90000.0, 0.98, 0.6, 101325.0  …  0.6, 101325.0, 4.65e6, 1.0e-5, 0.0, 190.55, 0.282743, 1.2e-5, 375.691, 9.81])
 t = nothing</code></pre><p>This is not a steady state of the system however. To find a true steady state, we want to ensure that the LHS of the system is zero.</p><p>We can use the <a href="../../API/#NetworkDynamics.find_fixpoint"><code>find_fixpoint</code></a> from <code>NetworkDynamics.jl</code> to initialize the system. Internally, this uses a nummerical solve for the rootfind problem <code>0 = rhs</code>. The result is automaticially wrapped as a <a href="../../API/#NetworkDynamics.NWState"><code>NWState</code></a> object.</p><pre><code class="language-julia hljs">u0 = find_fixpoint(nw, uguess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NWState{Vector{Float64}} of Network (3 vertices, 3 edges)
  ├─ VIndex(2, :p)  =&gt; 4.895109070989141e6
  ├─ VIndex(3, :p)  =&gt; 4.883573000934716e6
  ├─ EIndex(1, :q̃)  =&gt; 28.277070738768995
  ├─ EIndex(2, :q̃)  =&gt; 31.722929261231005
  └─ EIndex(3, :q̃)  =&gt; 8.277070738768995
 p = NWParameter([5.0e6, 0.265094, 0.251141, 0.717884, 278.0, 518.28, 90000.0, 0.98, 0.6, 101325.0  …  0.6, 101325.0, 4.65e6, 1.0e-5, 0.0, 190.55, 0.282743, 1.2e-5, 375.691, 9.81])
 t = nothing</code></pre><h2 id="Solving-the-ODE"><a class="docs-heading-anchor" href="#Solving-the-ODE">Solving the ODE</a><a id="Solving-the-ODE-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-ODE" title="Permalink"></a></h2><p>Using this as our initial state we can create the actual <code>ODEProblem</code>. Since the ODE always operates on flat state and parameter arrays, we use <code>uflat</code> and <code>pflat</code> to extract them.</p><pre><code class="language-julia hljs">prob = ODEProblem(nw, uflat(u0), (0.0,24*3600), copy(pflat(u0)))
sol = solve(prob, Tsit5(), tstops=[0,4,12,20,24]*3600)</code></pre><h2 id="Inspect-the-Solution"><a class="docs-heading-anchor" href="#Inspect-the-Solution">Inspect the Solution</a><a id="Inspect-the-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Inspect-the-Solution" title="Permalink"></a></h2><p>Inspecting the solution is all which is left to do.</p><pre><code class="language-julia hljs">xticks = ((0:4:24)*3600, string.(0:4:24)) # its nice to display hours
fig = begin
    _fig = Figure()
    row = 1
    ax = Axis(_fig[row, 1]; xlabel=&quot;time [h]&quot;, ylabel=&quot;pressure [Pa]&quot;, title=&quot;Pressure at nodes&quot;, xticks)
    xlims!(ax, sol.t[begin], sol.t[end])
    ylims!(ax, 47.9e5, 49.9e5)
    for i in 1:3
        lines!(ax, sol, idxs=vidxs(nw, i, :p); label=&quot;v$i&quot;, color=Cycled(i))
    end
    axislegend(ax)
    row += 1

    ax = Axis(_fig[row, 1]; xlabel=&quot;time [h]&quot;, ylabel=&quot;flow [m³/s]&quot;, title=&quot;Flow through pipes&quot;, xticks)
    xlims!(ax, sol.t[begin], sol.t[end])
    ylims!(ax, 16, 44)
    for i in 1:2
        lines!(ax, sol, idxs=eidxs(nw, i, :q̃); label=&quot;e$i flow&quot;, color=Cycled(i))
    end
    axislegend(ax, position=:rb)
    row += 1
    _fig
end</code></pre><img src="9582b528.svg" alt="Example block output"/><p>Notably, the &quot;internal&quot; states defined in the symbolic models are not &quot;states&quot; in the sense of the ODE. For example, we captured the load profile in the <code>q̃_inj</code> state of the <code>VariablePressureNode</code>. The only dynamic state of the model however is <code>p</code>. Using the &quot;observables&quot; mechanism from SciML, which is implemented by NetworkDynamics, we can reconstruct those &quot;optimized&quot; states which have been removed symbolically. Here we plot the reconstructed load profile of nodes 2 and 3. Also, we know that node 1 is infinitely stiff, acting as an infinite source of volumetric flow. We can reconstruct this flow too.</p><pre><code class="language-julia hljs">fig = begin
    _fig = Figure()
    row = 1
    ax = Axis(_fig[row, 1]; xlabel=&quot;time [h]&quot;, ylabel=&quot;flow [m³/s]&quot;, title=&quot;Flow at nodes&quot;, xticks)
    xlims!(ax, sol.t[begin], sol.t[end])
    lines!(ax, sol, idxs=vidxs(nw, 1, :q̃_inj); label=&quot;v1 compensation&quot;, color=Cycled(1))
    for i in 2:3
        lines!(ax, sol, idxs=vidxs(nw, i, :q̃_inj); label=&quot;v$i load profile&quot;, color=Cycled(i))
    end
    axislegend(ax, position=:rc)
    _fig
end</code></pre><img src="9cfba7b7.svg" alt="Example block output"/><p>Lastly we want to observe two internal states of the pipes: the Reynolds number and the mean pressure. We see, that we&#39;re purely in the turbulent flow regime.</p><pre><code class="language-julia hljs">fig = begin
    _fig = Figure()
    row = 1
    ax = Axis(_fig[row, 1]; xlabel=&quot;time [h]&quot;, ylabel=&quot;Reynolds number&quot;, title=&quot;Reynolds number&quot;, xticks)
    xlims!(ax, sol.t[begin], sol.t[end])
    for i in 1:3
        lines!(ax, sol, idxs=eidxs(nw, i, :Re); label=&quot;e $i&quot;, color=Cycled(i))
    end
    hlines!(ax, 2300, color=:black, linestyle=:dash, label=&quot;L/T transition&quot;)
    axislegend(ax, position=:rb)
    row += 1

    ax = Axis(_fig[row, 1]; xlabel=&quot;time [h]&quot;, ylabel=&quot;Mean pressure [Pa]&quot;, title=&quot;Mean pressure in pipes&quot;, xticks)
    xlims!(ax, sol.t[begin], sol.t[end])
    for i in 1:3
        lines!(ax, sol, idxs=eidxs(nw, i, :pM); label=&quot;e $i&quot;, color=Cycled(i))
    end
    axislegend(ax, position=:rb)
    _fig
end</code></pre><img src="2080adbf.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cascading_failure/">« Cascading Failure</a><a class="docs-footer-nextpage" href="../stress_on_truss/">Stress on Truss »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 8 August 2025 18:49">Friday 8 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
